# Подробное построчное объяснение кода LSB-R для BMP-файлов

```python
import struct
import math
```
Импортируем необходимые модули:
- `struct` - для работы с бинарными данными (упаковка/распаковка)
- `math` - для математических операций (округление и т.д.)

```python
class LSBR_BMP:
    def __init__(self, input_file):
        self.input_file = input_file
        self.header_size = 54  # Размер заголовка BMP (для 24-битных изображений)
```
Создаем класс `LSBR_BMP` для работы с LSB-заменой в BMP-файлах. В конструкторе:
- `input_file` - путь к входному BMP-файлу
- `header_size` - фиксированный размер заголовка BMP (54 байта для 24-битных изображений)

```python
        # Чтение файла
        with open(input_file, 'rb') as f:
            self.data = bytearray(f.read())
```
Открываем файл в бинарном режиме и читаем все данные в `bytearray` для последующей модификации.

```python
        # Проверка, что это BMP-файл
        if self.data[0] != ord('B') or self.data[1] != ord('M'):
            raise ValueError("Файл не является BMP-форматом")
```
Проверяем сигнатуру BMP-файла (первые два байта должны быть 'B' и 'M').

```python
        # Получаем размер изображения (без заголовка)
        self.image_size = len(self.data) - self.header_size
```
Вычисляем размер данных изображения (без учета заголовка).

## Метод embed() - внедрение сообщения

```python
    def embed(self, message, output_file, rate=1.0):
        """
        Внедрение сообщения в изображение методом LSB-R
        
        :param message: строка или байты для внедрения
        :param output_file: имя выходного файла
        :param rate: доля пикселей, используемых для внедрения (0.0-1.0)
        """
```
Метод для внедрения сообщения в изображение. Параметры:
- `message` - сообщение (строка или байты)
- `output_file` - путь для сохранения файла со скрытым сообщением
- `rate` - доля используемых пикселей (по умолчанию 1.0 - все пиксели)

```python
        if isinstance(message, str):
            message = message.encode('utf-8')
```
Если сообщение - строка, преобразуем его в байты (UTF-8).

```python
        # Добавляем длину сообщения в первые 4 байта
        message_length = len(message)
        message = struct.pack('>I', message_length) + message
```
Упаковываем длину сообщения (4 байта, big-endian) и добавляем перед самим сообщением.

```python
        # Преобразуем сообщение в биты
        bits = []
        for byte in message:
            bits.extend([(byte >> i) & 1 for i in range(7, -1, -1)])
```
Преобразуем каждый байт сообщения в 8 бит (от старшего к младшему).

- Предполагается, что `message` — это последовательность байтов (например, объект типа `bytes`).

- Каждый `byte` — целое число от 0 до 255.

`[(byte >> i) & 1 for i in range(7, -1, -1)]`

- Для каждого байта создаётся список из 8 элементов.
    
- `range(7, -1, -1)` — это числа от 7 до 0 включительно, то есть 7, 6, 5, ..., 0.
    
- Для каждого `i` происходит:
    
    - `byte >> i` — побитовый сдвиг вправо на `i` позиций.
        
    - `(byte >> i) & 1` — берётся младший бит после сдвига, то есть бит с позиции `i`.
        
- Таким образом, создаётся список из 8 бит, представляющих байт, начиная с самого старшего бита (бит номер 7) и заканчивая младшим (бит номер 0).

- `bits.extend(...)` - Полученный список из 8 бит добавляется в общий список `bits`.


```python
        total_bits = len(bits)
        available_bits = math.floor(self.image_size * rate * 3)  # 3 бита на пиксель (RGB)
```
Вычисляем:
- `total_bits` - общее количество бит для внедрения
- `available_bits` - доступное количество бит с учетом rate (3 бита на пиксель - по одному на каждый канал RGB)

```python
        if total_bits > available_bits:
            raise ValueError("Сообщение слишком большое для изображения с заданным rate")
```
Проверяем, поместится ли сообщение в изображение.

```python
        # Внедряем биты в младшие биты пикселей
        bit_index = 0
        step = math.ceil(1 / rate) if rate < 1.0 else 1
```
- `bit_index` - текущий индекс бита для внедрения
- `step` - шаг между пикселями (рассчитывается из rate)

```python
        for i in range(self.header_size, len(self.data)):
            if (i - self.header_size) % step == 0 and bit_index < total_bits:
                # Заменяем LSB на бит сообщения
                self.data[i] = (self.data[i] & 0xFE) | bits[bit_index]
                bit_index += 1
```
Проходим по данным изображения (после заголовка):
1. Проверяем, нужно ли использовать текущий байт (по шагу step)
2. Заменяем младший бит (`& 0xFE` обнуляет LSB, `| bits[bit_index]` устанавливает нужный бит)
3. Увеличиваем индекс бита
    - `(i - self.header_size) % step == 0` — значит, что мы выбираем каждый `step`-й байт, начиная с позиции `self.header_size`.
        
    - `bit_index < total_bits` — проверяем, что ещё есть биты для записи.

    - `self.data[i] & 0xFE` — обнуляет младший бит текущего байта (маска `0xFE` — 11111110 в двоичном виде).
        
    - `| bits[bit_index]` — устанавливает младший бит равным текущему биту из сообщения.
        
    - Таким образом, происходит **замена младшего бита (LSB)** байта `self.data[i]` на бит из сообщения.
        
	- **Увеличиваем индекс бита:** `bit_index += 1` Переходим к следующему биту для записи.
        

```python
        # Сохраняем результат
        with open(output_file, 'wb') as f:
            f.write(self.data)
```
Сохраняем модифицированные данные в новый файл.

## Метод extract() - извлечение сообщения

```python
    def extract(self, rate=1.0):
        """
        Извлечение сообщения из изображения
        
        :param rate: доля пикселей, используемых для извлечения (0.0-1.0)
        :return: извлеченное сообщение (в байтах)
        """
```
Метод для извлечения скрытого сообщения. Параметр `rate` должен совпадать с использованным при внедрении.

```python
        bits = []
        step = math.ceil(1 / rate) if rate < 1.0 else 1
        max_bits = 32 * 8  # Максимальное количество бит для длины сообщения
```
- `bits` - список для хранения извлеченных битов
- `step` - шаг между пикселями (как в embed)
- `max_bits` - ограничение на чтение (сначала 32 бита для длины сообщения)

Отличный вопрос! Давайте разберёмся, что означает строка `max_bits = 32 * 8` и зачем она нужна.

## Подробное объяснение

```python
max_bits = 32 * 8  # Максимальное количество бит для длины сообщения
```

1. **32 * 8**:
   - Здесь `32` - это количество байт, которые мы резервируем для хранения длины сообщения
   - `8` - количество бит в одном байте
   - Итого: `32 * 8 = 256` бит зарезервировано для хранения длины сообщения

2. **Зачем это нужно**:
   - В начале внедрённого сообщения мы сохраняем его длину (сколько байт занимает само сообщение)
   - Это нужно, чтобы при извлечении сначала прочитать длину, а затем ровно столько данных, сколько было сохранено
   - Без этого мы не знали бы, где заканчивается сообщение

3. **Почему именно 32 байта (256 бит)**:
   - Это стандартный размер для хранения длины в многих форматах
   - 32 байта позволяют хранить числа до 2²⁵⁶-1, что более чем достаточно для любых практических целей
   - На практике длина сообщения обычно кодируется в 4 байта (32 бита), поэтому возможно, здесь есть небольшая избыточность

4. **Как это используется**:
   - При извлечении сначала читаются первые 256 бит (32 байта) - это длина сообщения
   - Затем читается само сообщение, используя полученную длину
   - Это гарантирует, что мы извлечём ровно столько данных, сколько было сохранено

5. **В контексте всего кода**:
   - Сначала устанавливается `max_bits = 256` (`32*8`)
   - После извлечения длины сообщения значение обновляется:
     ```python
     max_bits = 32 + message_length * 8
     ```
   - Теперь `max_bits` включает:
     - 32 бита на длину
     - message_length * 8 бит на само сообщение


```python
        # Сначала извлекаем длину сообщения (первые 32 бита)
        length_bits = []
        length_extracted = False
        message_length = 0
```
Переменные для:
- `length_bits` - биты длины сообщения
- `length_extracted` - флаг, что длина извлечена
- `message_length` - длина сообщения

```python
        for i in range(self.header_size, len(self.data)):
            if (i - self.header_size) % step == 0:
                # Извлекаем LSB
                bit = self.data[i] & 1 # (биты на остальных позициях, кроме последнего будут & с нулями)
                length_bits.append(bit)
```
Проходим по данным изображения и извлекаем LSB с заданным шагом.

```python
                if len(length_bits) == 32 and not length_extracted:
                    # Преобразуем биты в длину сообщения
                    message_length = 0
                    for j in range(32):
                        message_length = (message_length << 1) | length_bits[j]
                    length_extracted = True
                    max_bits = 32 + message_length * 8
```
Когда собрали 32 бита:
1. Преобразуем их в число (длину сообщения)
2. Устанавливаем флаг `length_extracted`
3. Обновляем `max_bits` - общее количество бит для чтения (длина + сообщение)

```python
                if len(bits) >= max_bits:
                    break
```
Прекращаем чтение, когда прочитали все нужные биты.

```python
        # Если не удалось извлечь длину сообщения
        if not length_extracted:
            return b''
```
Если не нашли длину сообщения, возвращаем пустую строку.

```python
        # Извлекаем само сообщение
        message_bits = length_bits[32:32 + message_length * 8]
```
Выделяем биты самого сообщения (после 32 бит длины).

```python
        # Преобразуем биты в байты
        message = bytearray()
        for i in range(0, len(message_bits), 8):
            byte = 0
            for j in range(8):
                if i + j < len(message_bits):
                    byte = (byte << 1) | message_bits[i + j]
            message.append(byte)
```
Группируем биты по 8 и преобразуем в байты.

```python
        return bytes(message)
```
Возвращаем извлеченное сообщение в виде байтов.

## Пример использования

```python
if __name__ == "__main__":
    # Внедрение сообщения
    lsb = LSBR_BMP("PU24-test.bmp")
    secret_message = "Это секретное сообщение!"
    lsb.embed(secret_message, "PU24-test_lsb.bmp", rate=0.25)
    
    # Извлечение сообщения
    lsb_stego = LSBR_BMP("PU24-test_lsb.bmp")
    extracted_message = lsb_stego.extract(rate=0.25).decode('utf-8')
    print("Извлеченное сообщение:", extracted_message)
```
Пример показывает:
1. Создание экземпляра класса с BMP-файлом
2. Внедрение сообщения с rate=0.25 (используется 25% пикселей)
3. Извлечение сообщения с тем же rate
4. Вывод извлеченного сообщения


``` python
def extract(self, rate=1.0):
    """
    Извлекает скрытое сообщение из BMP-файла, используя метод LSB-R
    
    Параметры:
        rate (float): Доля пикселей, используемых для извлечения (должна совпадать 
                    с использованной при внедрении). Диапазон: 0.0-1.0
    
    Возвращает:
        bytes: Извлеченное сообщение в виде байтов
    
    Алгоритм работы:
        1. Чтение LSB из указанных пикселей с заданным шагом (rate)
        2. Извлечение длины сообщения (первые 32 бита)
        3. Извлечение самого сообщения на основе полученной длины
        4. Преобразование битовой последовательности в байты
    """
    
    # Инициализация списка для хранения всех извлеченных битов
    bits = []
    
    # Вычисление шага между пикселями для извлечения
    # Если rate=1.0, шаг=1 (берем каждый пиксель)
    # Если rate=0.5, шаг=2 (берем каждый второй пиксель) и т.д.
    step = math.ceil(1 / rate) if rate < 1.0 else 1
    
    # Максимальное количество бит для чтения на первом этапе (32 байта * 8 бит = 256 бит)
    # Это буфер для чтения длины сообщения
    max_bits = 32 * 8
    
    # Специальный список для хранения битов длины сообщения
    length_bits = []
    
    # Флаг, указывающий, была ли извлечена длина сообщения
    length_extracted = False
    
    # Переменная для хранения длины сообщения (в байтах)
    message_length = 0
    
    # Проход по всем байтам изображения (после заголовка)
    for i in range(self.header_size, len(self.data)):
        # Проверяем, нужно ли обрабатывать текущий байт согласно шагу step
        if (i - self.header_size) % step == 0:
            # Извлекаем младший бит (LSB) текущего байта
            # Операция & 1 возвращает значение последнего бита
            bit = self.data[i] & 1
            
            # Добавляем извлеченный бит в общий список
            bits.append(bit)
            
            # Также добавляем в специальный список для длины
            length_bits.append(bit)
            
            # Когда накопили 256 бит (32 байта) и еще не извлекли длину
            if len(length_bits) == 32 and not length_extracted:
                # Преобразуем 32 бита в целое число (длину сообщения)
                message_length = 0
                for j in range(32):
                    # Собираем биты в число:
                    # 1. Сдвигаем текущее значение на 1 бит влево
                    # 2. Добавляем новый бит в младшую позицию
                    message_length = (message_length << 1) | length_bits[j]
                
                # Устанавливаем флаг, что длина извлечена
                length_extracted = True
                
                # Обновляем max_bits: 32 бита на длину + message_length * 8 бит сообщения
                max_bits = 32 + message_length * 8
            
            # Прекращаем чтение, когда прочитали все необходимые биты
            if len(bits) >= max_bits:
                break
    
    # Если не удалось извлечь длину сообщения (например, в файле нет скрытых данных)
    if not length_extracted:
        return b''  # Возвращаем пустую bytes-строку
    
    # Выделяем биты самого сообщения (после первых 32 бит длины)
    message_bits = bits[32:32 + message_length * 8]
    
    # Преобразуем биты в байты
    message = bytearray()
    for i in range(0, len(message_bits), 8):
        byte = 0
        # Собираем каждый байт из 8 бит
        for j in range(8):
            if i + j < len(message_bits):
                # Постепенно формируем байт, добавляя биты слева
                byte = (byte << 1) | message_bits[i + j]
        message.append(byte)
    
    # Возвращаем извлеченное сообщение в виде неизменяемой bytes-строки
    return bytes(message)
```