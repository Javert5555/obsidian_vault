>[!tip] Main
>**Функция называется **"вложенной"**, если она создаётся внутри другой функции.**
## LexicalEnvironment (Лексическое окружение)

>[!abstract]
>_Лексическое окружение – объект спецификации. «Лексическое окружение» – это объект спецификации: он существует только «теоретически» в спецификации языка для описания того, как все работает. Мы не можем получить этот объект в нашем коде и манипулировать им напрямую. JavaScript-движки также могут оптимизировать его, отбрасывать неиспользуемые переменные для экономии памяти и выполнять другие внутренние действия, но при этом видимое поведение остается таким, как описано._

У каждого выполняемого блока кода `{...}` _(if, for, тело функции и т.д.)_ есть связанный с ним внутренний (скрытый) объект `LexicalEnvironment`, который состоит из 2 частей:
1. `Environment Record` - в котором, как свойства/методы хранятся все локальные переменные/функции (также другая информация, например, значение `this`).
2. Ссылка на внешнее лексическое окружение, т.е. то, внутри которого объявлен данный блок кода `{...}`.

>[!info]
>**«Переменная» – это просто свойство специального внутреннего объекта: `Environment Record`. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».**

Глобальное лексическое окружения - это лексическое окружение, связанное со всем скриптом.

>[!danger]
>У глобального лексического окружения нет внешнего окружения, так что _"ссылка на внешнее лексическое окружение"_ указывает на `null`.

По мере выполнения кода лексическое окружение меняется.

>[!danger]
>Лексическое окружение создаётся только в момент запуска блока кода или скрипта.

При запуске скрипта, лексическое окружение заполняется всеми объявленными переменными, изначально они находятся в статусе `Uninitialized` - это особое состояние, которое говорит о том, что движок уже знает о существовании этих переменных, но на них ещё нельзя ссылаться, пока они не будут объявлены.

>[!main]
Объект лексического окружения существует только до тех пор, пока на него ссылается хотя бы одна вложенная функция, в противном случае, он полностью исчезает (удаляется из памяти).

Пример глобального лексического окружения. _Прямоугольник означает Environment Record (хранилище переменных), а стрелка означает ссылку на внешнее окружение._
![[Pasted image 20250124004745.png]]

>[!info]
>Функция – это тоже значение, как и переменная. Разница заключается в том, что Function Declaration **мгновенно инициализируется полностью**.

Например:
![[Pasted image 20250124005040.png]]

При создании лексического окружения, Function Declaration сразу становится функцией, готовой к использованию. Поэтому мы можем использовать функции, объявленные с помощью Function Declaration до их явного объявления.

>[!danger]
>Такое поведение касается только функций, объявленных с помощью Function Declaration, но не Function Expression или Arrow Function, в которых мы присваиваем функции переменным.

### Внутреннее и внешнее лексическое окружение

Когда вызывается функция, автоматически создаётся новое лексическое окружение для хранения локальных переменных/функций и параметров вызова.

Пример:
![[Pasted image 20250124005931.png]]

Лексическое окружение функции в данном случае будет являться внутренним лексическим окружением по отношению к внешнему лексическому окружению (в данном случае глобальному). У внутреннего лексического окружения есть ссылка на внешнее лексическое окружение `outer`.

>[!main]
>**Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.**

Пример поиска переменной в лексических окружениях:
![[Pasted image 20250124011203.png]]

Для переменной `name`, `alert` внутри `say` сразу же находит ее во внутреннем лексическом окружении. Когда `alert` хочет получить доступ к `phrase`, он не находит её локально, поэтому вынужден обратиться к внешнему лексическому окружению и находит `phrase` там.

>[!danger]
>Если переменная не была найдена ни в одном лексическом окружении (в цепочке внутреннего и внешних лексических окружений), это будет ошибкой в строгом режиме (`use strict`). Без строгого режима для обратной совместимости, присваивание несуществующей переменной приведёт к созданию новой глобальной переменной с таким же именем.

### Возврат функции

Пример:
```javascript
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
```

В начале каждого вызова `makeCounter()` создается новый объект лексического окружения, в котором хранятся переменные для конкретного запуска `makeCounter`:
![[Pasted image 20250124014001.png]]

Во время выполнения `makeCounter()` создается вложенная функция, состоящая всего из одной строки: `return count++`. Мы ее еще не запускаем, а только создаем.

>[!info]
>Все функции имеют скрытое свойство `[[Environment]]`, которое хранит ссылку на лексическое окружение, в котором была создана функция. Функция запоминает, где она была создана, независимо от того, где она вызывается. Ссылка на внешний `[[Environment]]` устанавливается один раз и навсегда при создании функции.

![[Pasted image 20250124014411.png]]

Таким образом, `counter.[[Environment]]` имеет ссылку на `{count: 0}` лексического окружения внешнего лексического окружения (функции `makeCounter`).

Впоследствии, при вызове `counter()`, для этого вызова создается новое лексическое окружение, а его внешняя ссылка на лексическое окружение берется из `counter.[[Environment]]`:
![[Pasted image 20250124014804.png]]

Теперь, когда код внутри `counter()` ищет переменную `count`, он сначала ищет ее в собственном лексическом окружении (пустом, так как там нет локальных переменных), а затем в лексическом окружении внешнего вызова `makeCounter()`, где находит `count` и изменяет ее.

>[!tip] Main
>**Переменная обновляется в том лексическом окружении, в котором она существует.**

Состояние после выполнения:
![[Pasted image 20250124021055.png]]
_Если вызвать `counter()` несколько раз, то в одном и том же месте переменная `count` будет увеличена до `2`, `3` и т.д._

#### Замыкания
>[!tip] Main
>**Замыкание - это функция, которая запоминает свои внешние переменные и может получить к ним доступ.**

>[!danger]
>Все функции в JS являются замыканиями, исключением являются функции, объявленные с помощью `new Function()`, так как при таком объявлении у функции в скрытое свойство `[[Environment]]` записывается ссылка не на внешнее лексическое окружение, в котором была объявлена данная функция, а на глобальное лексическое окружение. Поэтому такая функция имеет доступ только к переменным, объявленным в самой функции, и глобальным переменным.

