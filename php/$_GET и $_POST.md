## $\_GET

`$_GET` — это суперглобальная переменная в PHP, которая используется для сбора данных, отправленных с помощью метода HTTP GET. Это ассоциативный массив, который содержит переменные, переданные в скрипт через параметры URL, также известные как строка запроса.

>[!info]
>Массив не только заполняется для GET-запросов, а скорее для всех запросов со строкой запроса.

### Основные моменты $_GET

- **Доступ к параметрам URL**: Параметры включаются в URL после знака вопроса (`?`). Например, в URL `http://example.com/?name=John` параметр `name` можно получить в PHP с помощью `$_GET['name']`, что вернет "John", если это значение вывести.

- **Суперглобальная природа**: Будучи суперглобальной переменной, `$_GET` доступен из любой части скрипта без необходимости объявлять его как глобальный. Это означает, что вы можете использовать его в функциях, методах и в любом другом месте вашего PHP-кода.

- **Тип данных**: Данные в `$_GET` всегда являются строками. Если вам нужны другие типы данных (например, целые числа), вам нужно будет вручную выполнить их преобразование.

- **Отправка форм**: Когда HTML-форма отправляется с установленным методом "GET", данные формы добавляются к URL в виде строки запроса. Например, форма с полями `name` и `email` отправит данные в виде `welcome_get.php?name=John&email=john@example.com`.

### Пример использования:

```php
// http://localhost/?name=testName

if (isset($_GET['name'])) {
    var_export($_GET['name']); // 'testName'
} else {
    var_export('username');
}
```

### Важные моменты

- **Безопасность**: Поскольку данные из `$_GET` могут быть изменены пользователями, крайне важно очищать и проверять все входные данные, чтобы предотвратить уязвимости безопасности, такие как XSS (межсайтовый скриптинг) и SQL-инъекции.

- **Ограничения**: У URL есть ограничения по длине, поэтому использование `$_GET` не подходит для передачи больших объемов данных. Для более крупных отправок данных можно рассмотреть возможность использования метода POST.

## $\_POST

В PHP суперглобальный массив `$_POST` представляет собой ассоциативный массив, который содержит данные, отправленные методом HTTP POST. Он часто используется для обработки отправок форм, где атрибут `method` формы установлен в значение `"POST"`.

### Доступ к данным POST

- Каждое поле формы хранится в массиве `$_POST`, где атрибут `name` поля является ключом, а отправленное значение — значением.
- Например, если форма имеет поле ввода с `name="name"`, его значение можно получить с помощью `$_POST['name']`.

### Пример использования:

Файл `index.php`:
```php
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHP</title>
</head>
<body>
    <form action="form.php" method="POST">
        <p>Имя: <input type="text" name="name"> </p>
        <p>Возраст: <input type="number" name="age"> </p>
        <input type="submit">
    </form>
</body>
</html>
```

Файл `form.php`:
```php
<?php

$name = isset($_POST['name']) ? $_POST['name'] : 'не определено';
$age = isset($_POST['age']) ? (int) $_POST['age'] : 'не определено';
var_export($name . ' ' . $age);

?>
```

Или всё в одном файле:

``` php
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHP</title>
</head>
<body>
    <?php
    
    $name = isset($_POST['name']) ? $_POST['name'] : 'не определено';
    $age = isset($_POST['age']) ? (int) $_POST['age'] : 'не определено';
    var_export($name . ' ' . $age);

    ?>
    <form method="POST">
        <p>Имя: <input type="text" name="name"> </p>
        <p>Возраст: <input type="number" name="age"> </p>
        <input type="submit">
    </form>
</body>
</html>
```

### Экранирование строк

Для предотвращения XSS-атак (передача джаваскрипт-скрипта в параметр запроса), необходимо экранировать вывод полученного значения на экран:

Без экранирования вывода, сработает скрипт `<script>alert('hey')</script>`:

```php
// http://localhost/?test=<script>alert('hey')</script>

echo $_GET['test'];
```

Результат работы скрипта `<script>alert('hey')</script>`:

![[Pasted image 20240720021558.png]]

С экранированием вывода:

```php
// http://localhost/?test=<script>alert('hey')</script>

echo htmlentities($_GET['test']);
// Вывод: <script>alert('hey')</script>

echo htmlspecialchars($_GET['test']);
// Вывод: <script>alert('hey')</script>

echo strip_tags($_GET['test']);
// Вывод: alert('hey')
```

![[Pasted image 20240720022402.png]]

Функция `htmlentities` преобразует все применимые символы в HTML-сущности. Это особенно полезно, когда вы хотите гарантировать, что специальные символы в строке корректно отображаются в HTML. Например, она преобразует символы `<`, `>`, и `&` в соответствующие HTML-сущности (`&lt;`, `&gt;`, `&amp;`).

Функция `htmlspecialchars` похожа на `htmlentities`, но преобразует только ограниченный набор символов: `&`, `"`, `'`, `<` и `>`. Она часто предпочтительнее `htmlentities` для общего использования, так как менее ресурсоемка и достаточно для большинства случаев.

Функция `htmlentities()` работает идентично функции `htmlspecialchars()`, за исключением того, что функция `htmlentities()` преобразовывает в HTML-сущности каждый символ, для которого в таблице перевода содержится эквивалентная HTML-сущность. _Таблицу перевода, которую использует эта функция и которая зависит от констант, которые передали в параметр `flags`, возвращает функция `get_html_translation_table()`._

Функция `strip_tags` удаляет все HTML и PHP теги из строки. Эта функция полезна, когда вы хотите очистить ввод, удалив любые потенциально опасные теги перед обработкой или сохранением данных.

### Безопасность доп.
#### Пример использования `htmlspecialchars()`

Функция `htmlspecialchars()` используется для преобразования специальных символов в HTML-сущности. Это помогает предотвратить XSS-атаки, когда злоумышленник пытается вставить вредоносный JavaScript-код в веб-страницу.

#### Пример кода

```php
if ($_SERVER["REQUEST_METHOD"] == "POST") {
    // Получение данных из формы
    $name = $_POST['name'];
    $email = $_POST['email'];

    // Защита от XSS
    $safe_name = htmlspecialchars($name, ENT_QUOTES, 'UTF-8');
    $safe_email = htmlspecialchars($email, ENT_QUOTES, 'UTF-8');

    // Отображение безопасных данных
    echo "Имя: $safe_name, Email: $safe_email";
}
```

В этом примере, если пользователь введет что-то вроде `<script>alert('XSS')</script>`, функция `htmlspecialchars()` преобразует это в `&lt;script&gt;alert('XSS')&lt;/script&gt;`, что предотвратит выполнение скрипта.

#### Пример использования `mysqli_real_escape_string()`

Функция `mysqli_real_escape_string()` используется для экранирования специальных символов в строках, которые будут использоваться в SQL-запросах. Это помогает предотвратить SQL-инъекции.

#### Пример кода

```php
// Подключение к базе данных
$mysqli = new mysqli("localhost", "username", "password", "database");

// Проверка подключения
if ($mysqli->connect_error) {
    die("Ошибка подключения: " . $mysqli->connect_error);
}

if ($_SERVER["REQUEST_METHOD"] == "POST") {
    // Получение данных из формы
    $name = $_POST['name'];
    $email = $_POST['email'];

    // Защита от SQL-инъекций
    $safe_name = $mysqli->real_escape_string($name);
    $safe_email = $mysqli->real_escape_string($email);

    // Выполнение SQL-запроса
    $sql = "INSERT INTO users (name, email) VALUES ('$safe_name', '$safe_email')";
    if ($mysqli->query($sql) === TRUE) {
        echo "Новая запись успешно добавлена";
    } else {
        echo "Ошибка: " . $sql . "<br>" . $mysqli->error;
    }
}

// Закрытие соединения
$mysqli->close();
```

В этом примере, если пользователь введет что-то вроде `'); DROP TABLE users; --`, функция `mysqli_real_escape_string()` экранирует специальные символы, и SQL-запрос будет безопасным.