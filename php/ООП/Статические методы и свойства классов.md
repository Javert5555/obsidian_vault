Кроме обычных методов и свойств с разными модификаторами доступа класс может содержать статические методы и свойства. Такие методы и свойства помечаются ключевым словом `static`.

Статические методы и свойства создаются один раз для всего класса и относятся ко всему классу, тогда как для нестатических свойств и методов создается отдельная копия для каждого объекта. Статические методы и свойства могут быть вызваны без необходимости создания экземпляра класса. Это отличает их от нестатических методов и свойств, которые требуют создания объекта для доступа.

Чтобы получить доступ к статическому свойству, необходимо использовать оператор `::`.

```php
class User {

	static string $planet = 'Earth';

	public function __construct(
		public string $name
	) {}

	public function sayName() {
		var_export($this->name);
	}

	static function sayPlanet() {
		var_export($this->name); // Fatal error: Uncaught Error: Using $this when not in object context
		var_export(self::$planet);
	}
}

$user = new User('newUser');

// Попытка доступа к статическому свойству через экземпляр класса приведет к ошибке:
$user->planet; // Notice: Accessing static property User::$planet as non static
$user->sayName(); // 'newUser'
// можно вызвать статический метод через экземпляр класса
$user->sayPlanet(); // 'Earth'
User::sayPlanet(); // 'Earth'
```

Попытка доступа к статическому свойству через экземпляр класса приведет к ошибке, однако можно вызвать статический метод через экземпляр класса, но это не рекомендуется, т.к. может привести к путанице. Статические методы и свойства принадлежат классу в целом, а не конкретным объектам, поэтому правильный способ их вызова — через имя класса с использованием оператора `::`.

>[!info]
>Статические свойства принадлежат классу, а не конкретному объекту.

>[!warning]
>Внутри статических методов нельзя использовать `$this`, так как они не связаны с конкретным экземпляром класса. Вместо этого для доступа к другим статическим свойствам или методам используется `self`. **В статических методах мы можем обращаться только к статическим свойствам и методам**.

Cтатические методы и свойства также могут иметь модификаторы доступа.

```php
class User {

	static string $planet = 'Earth';
	private static $counter = 0;

	public function __construct(
		public string $name
	) {
		self::$counter += 1;
	}

	public function sayName() {
		var_export($this->name);
	}

	static function sayPlanet() {
		// var_export($this->name); // Fatal error: Uncaught Error: Using $this when not in object context
		var_export(self::$planet);
	}

	public static function getCounter() {
		return self::$counter;
	}
}

$user = new User('newUser');
$user1 = new User('newUser');
$user2 = new User('newUser');

var_export(User::$counter); // Fatal error: Uncaught Error: Cannot access private property User::$counter
var_export(User::getCounter()); // 3
```

### Вызов статического метода/свойства у экземпляра класса

В PHP можно вызывать статические методы у экземпляров класса, но нельзя напрямую вызывать статические свойства. **Статические методы** можно вызывать у экземпляров класса, потому что PHP автоматически преобразует вызов статического метода через объект в вызов через имя класса.

```php
$obj->staticMethod();
```

эквивалентно:

```php
ClassName::staticMethod();
```

Это сделано для обратной совместимости, чтобы код с вызовами статических методов через объекты продолжал работать.

**Статические свойства** нельзя вызывать напрямую через объекты, только через имя класса. Попытка обратиться к статическому свойству через объект приведет к ошибке:

```php
$obj->staticProperty; // Ошибка
```

Правильный синтаксис:

```php
ClassName::$staticProperty;
```

Это связано с тем, что статические свойства принадлежат классу, а не объектам. Поэтому для доступа к ним используется имя класса.

Таким образом, в PHP можно вызывать статические методы через объекты, но нельзя напрямую обращаться к статическим свойствам через объекты. Для доступа к статическим свойствам всегда используется имя класса.