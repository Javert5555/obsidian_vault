
Лекция от 11.09.2024

Вопросы лекции:

1.              Выводные замечания

2.              Вредоносные программы: вирусы, черви, трояны

3.              Ущерб от вредоносных программ

4.              Угрозы безопасности информации

Зачем нужно проводить классификацию изучаемых объектов ?

Почему задача обнаружения вирусов неразрешима ?

**Вопрос №1**

Решить задачу теоретического обнаружения вирусов невозможно, поэтому на практике приходится решать частные задачи относительно частных случаев вредоносных программ. В зависимости от свойств вирусов для их обнаружения и нейтрализации могут применяться различные методы. Необходимо отметить, что на практике классификации, принятые различными производителями антивирусных продуктов, отличаются, хотя и построены на близких принципах. Поэтому в ходе изложения будут формулироваться в первую очередь принципы, и уже потом примеры из классификации, используемой в Лаборатории Касперского.

Определение компьютерного вируса — исторически проблемный вопрос, поскольку достаточно сложно дать четкое определение вируса, очертив при этом свойства, присущие только вирусам и не касающиеся других программных систем. Наоборот, давая жесткое определение вируса как программы, обладающей определенными свойствами, практически сразу же можно найти пример вируса, таковыми свойствами не обладающего.

Определение по ГОСТ Р 51188-98:

Вирус — программа, способная создавать свои копии (необязательно совпадающие с оригиналом) и внедрять их в файлы, системные области компьютера, компьютерных сетей, а также осуществлять иные деструктивные действия. При этом копии сохраняют способность дальнейшего распространения. Компьютерный вирус относится к вредоносным программам. Легко заметить, что определение в ГОСТ практически полностью повторяет определение Е. Касперского.

Оно в большой степени повторяют определение Ф. Коэна, из чего следует, вывод что позволяет распространить на них (определения) вывод о невозможности создать алгоритм, обнаруживающий все такие программы или даже все "инкарнации" одного из вирусов. Тем не менее, на практике оказывается, что все известные вирусы могут быть обнаружены антивирусными программами. Результат достигается в частности еще и за счет того, что поврежденные или неудачные экземпляры вирусов, неспособные к созданию и внедрению своих копий, обнаруживаются и классифицируются наравне со всеми остальными "полноценными" вирусами. Следовательно, с практической точки зрения, т. е. с точки зрения алгоритмов поиска, способность к размножению вовсе не является обязательной для причисления программы к вирусам.

Другая проблема, связанная с определением компьютерного вируса кроется в том, что сегодня под вирусом чаще всего понимается не "традиционный" вирус, а практически любая вредоносная программа. Это приводит к путанице в терминологии, осложненной еще и тем, что практически все современные антивирусы способны выявлять указанные типы вредоносных программ, таким образом ассоциация "вредоносная программа-вирус" становится все более устойчивой. Исходя из этого, а также из назначения антивирусных средств, в дальнейшем, если это не будет оговорено отдельно, под вирусами будут подразумеваться именно вредоносные программы.

Вредоносная программа — компьютерная программа или переносной код, предназначенный для реализации угроз информации, хранящейся в КС, либо для скрытого нецелевого использования ресурсов КС, либо иного воздействия, препятствующего нормальному функционированию КС. К вредоносным программам относятся компьютерные вирусы, трояны, сетевые черви и др. Компьютерные вирусы, трояны и черви являются основными типами вредоносных программ. 

**Жизненный цикл вируса**

Поскольку отличительной особенностью вирусов в традиционном смысле является способность к размножению в рамках одного компьютера, деление вирусов на типы происходит в соответствии со способами размножения. Сам процесс размножения может быть условно разделен на несколько стадий:

1.              Проникновение на компьютер

2.              Активация вируса

3.              Поиск объектов для заражения

4.              Подготовка вирусных копий

5.              Внедрение вирусных копий

Особенности реализации каждой стадии порождают атрибуты, набор которых фактически и определяет класс вируса.

**Проникновение**

Вирусы проникают на компьютер вместе с зараженными файлами или другими объектами (загрузочными секторами дискет), никак, в отличие от червей, не влияя на процесс проникновения. Следовательно, возможности проникновения полностью определяются возможностями заражения и классифицировать вирусы по этим стадиям жизненного цикла отдельно смысла нет. Например, они внедряются внутрь этих программ и активируются вместе с их запуском. И вирусы-черви (или просто черви )., используют только ресурсы вычислительных систем ( оперативную и долговременную память, непрограммные файлы), рассылая свои копии по сетям, раскладывая их по носителям информации, буферами памяти, чужим архивам и т.п. Черви автономны, к другим программам они не прикрепляются.

**Активация**

Для активации вируса необходимо, чтобы зараженный объект получил управление. На данной стадии деление вирусов происходит по типам объектов, которые могут быть заражены:

·                Загрузочные вирусы - вирусы, заражающие загрузочные сектора постоянных и сменных носителей.

·                Файловые вирусы —вирусы, заражающие файлы. Эта группа дополнительно делится на три: собственно файловый- те, которые непосредственно работают с ресурсами ОС. ( Самый известный файловый – Virus. Win9x.CIH ).

·                Макро-вирусы способны заражать не только документы Microsoft Word и Excel. Существуют вредоносные программы ориентированные и на другие типы документов: Macro.Visio.Radiant заражает файлы известной программы для построения диаграмм -Visio, Virus.Acad.Pobresito - документы AutoCAD, Macro.AmiPro.Green - документы популярного раньше текстового процессора Ami Pro.

·                Скрипт-вирусы — вирусы, исполняемые в среде определенной командной оболочки: раньше - bat-файлы в командной оболочке DOS, сейчас чаще VBS и JS - скрипты в командной оболочке Windows Scripting Host (WSH).Отдельно стоит отметить тот факт, что вирусы, рассчитанные для работы в среде определенной ОС или приложения, оказываются неработоспособными в среде других ОС и приложений. Поэтому как отдельный атрибут вируса выделяется среда, в которой он способен выполняться. Для файловых вирусов это DOS, Windows, Linux, MacOS, OS/2. Для макровирусов - Word, Excel, PowerPoint, Office. Иногда вирусу требуется для корректной работы какая-то определенная версия ОС или приложения, тогда атрибут указывается более узко: Win9x, Excel97.

  На стадии поиска объектов для заражения встречается два способа поведения вирусов.1.Получив управление, вирус производит разовый поиск жертв, после чего передает управление ассоциированному с ним объекту (зараженному объекту).2.Получив управление, вирус так или иначе остается в памяти и производит поиск жертв непрерывно, до завершения работы среды, в которой он выполняется Вирусы второго типа во времена однозадачной DOS было принято называть резидентными. С переходом на Windows проблема остаться в памяти перестала быть актуальной: практически все вирусы, исполняемые в среде Windows, равно как и в среде приложений MS Office, являются вирусами второго типа. И напротив, скрипт-вирусы являются вирусами первого типа. Соответственно, атрибут резидентный применим только к файловым DOS вирусам. Существование нерезидентных Windows вирусов возможно, но на практике они являются редким исключением.

Отдельно имеет смысл рассмотреть так называемые stealth-вирусы - вирусы, которые находясь постоянно в памяти, перехватывают обращения к зараженному файлу и на ходу удаляют из него вирусный код, передавая в ответ на запрос неизмененную версию файла. Таким образом эти вирусы маскируют свое присутствие в системе. Для их обнаружения антивирусным средствам требуется возможность прямого обращения к диску в обход средств операционной системы. Наибольшее распространение Stealth-вирусы получили во времена DOS.

**Подготовка вирусных копий**

Сигнатура вируса — в широком смысле, информация, позволяющая однозначно определить наличие данного вируса в файле или ином коде. Примерами сигнатур являются: уникальная последовательность байт, присутствующая в данном вирусе и не встречающаяся в других программах; контрольная сумма такой последовательности. Процесс подготовки копий для распространения может существенно отличаться от простого копирования. Авторы наиболее сложных в технологическом плане вирусов стараются сделать разные копии максимально непохожими для усложнения их обнаружения антивирусными средствами. Как следствие, составление сигнатуры для такого вируса крайне затруднено либо вовсе невозможно.

Шифрование — вирус состоит из двух составляющих: собственно вирус и шифратор. Каждая копия вируса состоит из шифратора, случайного ключа и собственно вируса, зашифрованного этим ключом.

Метаморфизм — создание различных копий вируса путем замены блоков команд на эквивалентные, перестановки местами кусков кода, вставки между значащими кусками кода "мусорных" команд, которые практически ничего не делают.

Сочетание этих двух технологий приводит к появлению следующих типов вирусов.

·                 **_Шифрованный вирус_** — вирус, использующий простое шифрование со случайным ключом и неизменный _шифратор_. Такие вирусы легко обнаруживаются по сигнатуре _шифратора_.

·                 **_Метаморфный вирус_** — вирус, применяющий метаморфизм ко всему своему телу для создания новых копий.

·                 **_Полиморфный вирус_** — вирус, использующий метаморфный _шифратор_ для шифрования основного тела вируса со случайным ключом. При этом часть информации, используемой для получения новых копий _шифратора_ также может быть зашифрована. Например, вирус может реализовывать несколько алгоритмов шифрования и при создании новой копии менять не только команды _шифратора_, но и сам алгоритм.

Полиморфные вирусы можно делить на классы по уровню полиморфизма, желающие подробнее познакомиться с этим вопросом могут найти полезную информацию в [1].

Пик популярности _полиморфных вирусов_ пришелся на времена DOS, тем не менее, и позднее полиморфизм использовался во множестве вирусов, продолжает использоваться полиморфизм и сегодня.

**Лекция от 21.09.2024**

          К сожалению, определение червя отсутствует в государственных стандартах и распорядительных документах, поэтому здесь приведено лишь интуитивное определение, дающее представление о принципах работы и выполняемых функциях этого типа вредоносных программ.

          Червь (сетевой червь) — тип вредоносных программ, распространяющихся по сетевым каналам, способных к автономному преодолению систем защиты автоматизированных и компьютерных сетей, а также к созданию и дальнейшему распространению своих копий, не всегда совпадающих с оригиналом, и осуществлению иного вредоносного воздействия.

Так же как для вирусов, жизненный цикл червей можно разделить на определенные стадии:

1.              Проникновение в систему

2.              Активация

3.              Поиск "жертв"

4.              Подготовка копий

5.              Распространение копий

Стадии 1 и 5, вообще говоря, симметричны и характеризуются в первую очередь используемыми протоколами и приложениями.

Стадия 4 — Подготовка копий — практически ничем не отличается от аналогичной стадии в процессе размножения вирусов. Сказанное о подготовке копий вирусов без изменений применимо и к червям.

На этапе проникновения в систему черви делятся преимущественно по типам используемых протоколов:

·                 Сетевые черви — черви, использующие для распространения протоколы Интернет и локальных сетей. Обычно этот тип червей распространяется с использованием неправильной обработки некоторыми приложениями базовых пакетов стека протоколов tcp/ip

·                 Почтовые черви — черви, распространяющиеся в формате сообщений электронной почты

·                 IRC-черви — черви, распространяющиеся по каналам IRC (Internet Relay Chat)

·                 P2P-черви — черви, распространяющиеся при помощи пиринговых (peer-to-peer) файлообменных сетей

·                 IM-черви — черви, использующие для распространения системы мгновенного обмена сообщениями (IM, Instant Messenger - ICQ, MSN Messenger, AIM и др.)

На этапе активации черви делятся на две большие группы, отличающиеся как по технологиям, так и по срокам жизни:

·                 Для активации необходимо активное участие пользователя

·                 Для активации участие пользователя не требуется вовсе либо достаточно лишь пассивного участия

Под пассивным участием пользователя во второй группе понимается, например, просмотр писем в почтовом клиенте, при котором пользователь не открывает вложенные файлы, но его компьютер, тем не менее, оказывается зараженным.

Активация сетевого червя без участия пользователя всегда означает, что червь использует бреши в безопасности программного обеспечении компьютера. Это приводит к очень быстрому распространению червя внутри корпоративной сети с большим числом станций, существенно увеличивает загрузку каналов связи и может полностью парализовать сеть. Именно этот метод активации использовали черви Lovesan и Sasser. В результате вызванной таким сетевым червем эпидемии, используемая брешь закрывается администраторами либо пользователями, и по мере уменьшения компьютеров с открытой брешью эпидемия завершается.

Способ поиска компьютера-жертвы полностью базируется на используемых протоколах и приложениях. В частности, если речь идет о почтовом черве, производится сканирование файлов компьютера на предмет наличия в них адресов электронной почты, по которым в результате и производится рассылка копий червя.

Точно так же Интернет-черви сканируют диапазон IP адресов в поисках уязвимых компьютеров, а P2P черви кладут свои копии в общедоступные каталоги клиентов пиринговых сетей. Некоторые черви способны эксплуатировать списки контактов интернет-пейджеров, таких как ICQ, AIM, MSN Messenger, Yahoo! Messenger и др.

Сказанное ранее о подготовке копий для распространения вирусов, применимо и для червей.

Наиболее часто среди червей встречаются упрощенные реализации метаморфизма. Некоторые черви способны рассылать свои копии в письмах, как с внедрением скрипта приводящего к автоматической активации червя, так и без внедрения. Такое поведение червя обусловлено двумя факторами: скрипт автоматической активации повышает вероятность запуска червя на компьютере пользователя, но при этом уменьшает вероятность проскочить антивирусные фильтры на почтовых серверах.

Аналогично, черви могут менять тему и текст инфицированного сообщения, имя, расширение и даже формат вложенного файла - исполняемый модуль может быть приложен как есть или в заархивированном виде. Все это нельзя считать мета- или полиморфизмом, но определенной долей изменчивости черви, безусловно, обладают.

Троян (троянский конь, троянская программа, троянец) - тип [вредоносных программ](https://www.tadviser.ru/index.php/%D0%A1%D1%82%D0%B0%D1%82%D1%8C%D1%8F:%D0%92%D1%80%D0%B5%D0%B4%D0%BE%D0%BD%D0%BE%D1%81%D0%BD%D0%B0%D1%8F_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0 "Вредоносная программа"), основной целью которых является вредоносное воздействие по отношению к компьютерной системе. В данную категорию входят программы, осуществляющие различные несанкционированные пользователем действия: сбор информации и ее передачу злоумышленнику, ее разрушение или злонамеренную модификацию, нарушение работоспособности компьютера, использование ресурсов компьютера в неблаговидных целях.

рояны отличаются отсутствием механизма создания собственных копий.

Некоторые трояны способны к автономному преодолению защиты компьютерной системы, с целью проникновения и заражения системы. В общем случае, троян попадает в систему вместе с вирусом либо червем, в результате неосмотрительных действий пользователя или же активных действий злоумышленника.

Большинство троянских программ предназначено для сбора конфиденциальной информации. Их задача, чаще всего, состоит в выполнении действий, позволяющих получить доступ к данным, которые не подлежат широкой огласке. К таким данным относятся пользовательские пароли, регистрационные номера программ, сведения о банковских счетах и т. д. Остальные троянцы создаются для причинения прямого ущерба компьютерной системе, приводя ее в неработоспособное состояние.

Задачу проникновения на компьютер пользователя трояны решают обычно одним из двух следующих методов.

Маскировка — _троян_ выдает себя за полезное приложение, которое пользователь самостоятельно загружает из Интернет и запускает. Иногда пользователь исключается из этого процесса за счет размещения на Web-странице специального скрипта, который используя дыры в браузере автоматически инициирует загрузку и запуск трояна.

Кооперация с вирусами и червями — _троян_ путешествует вместе с червями или, реже, с вирусами. В принципе, такие пары червь-_троян_ можно рассматривать целиком как составного червя, но в сложившейся практике принято троянскую составляющую червей, если она реализована отдельным файлом, считать независимым трояном с собственным именем. Кроме того, троянская составляющая может попадать на компьютер позже, чем файл червя.

**_Похитители паролей_** — трояны, также предназначенные для получения паролей, но не использующие слежение за клавиатурой. В таких троянах реализованы способы извлечения паролей из файлов, в которых эти пароли хранятся различными приложениями.

**_Утилиты удаленного управления_** — трояны, обеспечивающие полный удаленный контроль над компьютером пользователя. ' Существуют легальные утилиты такого же свойства, но они отличаются тем, что сообщают о своем назначении при установке или же снабжены документацией, в которой описаны их функции. Троянские _утилиты удаленного управления_, напротив, никак не выдают своего реального назначения, так что пользователь и не подозревает о том, что его компьютер подконтролен злоумышленнику. Наиболее популярная утилита удаленного управления - Back Orifice.

_Люки (backdoor)_ — трояны предоставляющие злоумышленнику ограниченный контроль над компьютером пользователя. От утилит удаленного управления отличаются более простым устройством и, как следствие, небольшим количеством доступных действий. Тем не менее, обычно одними из действий являются возможность загрузки и запуска любых файлов по команде злоумышленника, что позволяет при необходимости превратить ограниченный контроль в полный.

Лекция от 05.10.2024

Самые крупные и быстро развивающиеся эпидемии вызываются сетевыми Интернет-червями. Червь такого типа способен атаковать любой компьютер, имеющий собственный IP-адрес, вне зависимости от его географического местоположения. Этой ситуации соответствует модель в виде «полного» (или «гомогенного») графа, каждый узел которого связан со всеми остальными. Такой граф из N узлов имеет N (N - 1) / 2 ребер, причем степень каждого узла равна N – 1.

![Изображение выглядит как Симметрия, круг, линия, дизайн
Автоматически созданное описание](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image001.png)

Лекция от 19.10.2024

Обнаружения вирусов

Вопросы лекции:

1.              Принципы действия антивирусных программ

2.              Анализ Косвенных признаков

3.              Простые сигнатуры

4.              Контрольные суммы  
  

Методы этапа, **выделения и сбора характеристик** «подозрительной» программы, целесообразно разделить на:

- статические — оперирующие с двоичным образом программы на носителе информации или в памяти;
- динамические — рассматривающие программу как процесс выполнения алгоритма, то есть как последовательную смену состояний.

В свою очередь, методы этапа, посвященного **обработке данных и анализу характеристик**, принято разделять на:

- формальные — оперирующие фиксированной моделью вируса и использующие заранее определенные алгоритмы;
- эвристические — пытающиеся воспроизвести процесс познания, присущий человеку.

Далее рассмотрим типичные комбинации методов, используемых на разных этапах процедуры детектирования компьютерных вирусов.

**2. Анализ косвенных признаков**

Наиболее примитивные методы обнаружения вирусов основаны на изучении косвенных признаков («слабых сигнатур»), характеризующих зараженность. Как правило, проверка наличия или отсутствия этих признаков возможна либо «на глазок», либо с применением штатных утилит операционной системы.

- Примерами подобных признаков являются отличительные метки, проставляемые внутри зараженных программ самими вирусами: строчка «MsDos» в конце файла (вирусы семейства **Jerusalem**);
- значение «62 секунды» в атрибуте времени последнего доступа к файлу (вирусы семейства **Vienna**);
- байт со значением 55h перед PE-заголовком (вирус **Win9X.CIH**) и прочие.

Другими косвенными признаками могут служить нетрадиционная структура программы (например, наличие нескольких кодовых сегментов в PE-модуле), бит разрешения записи в кодовый сегмент, «свежая» дата создания у заведомо «несвежего» файла и т. п.

Кроме того, большое количество косвенных признаков можно обнаружить, сканируя код программы на характерные фрагменты. Например:

- байт E9h в начале COM-файлов соответствует команде «JMP» и может свидетельствовать о зараженности ее «стандартным» методом;
- цепочка байтов E80000h или E8000000h в начале программы может означать попытку вычислить «дельта-смещение».

Однозначным признаком зараженности «слабые сигнатуры» служить не могут и не должны. В качестве примера, подтверждающего этот тезис, можно вспомнить историю, произошедшую в конце 1980-х годов. Один из популярных «импортных» антивирусов — программа TNTVIRUS — «вакцинировал» все программы на диске, записывая в конец строчку «MsDos», чтобы вирус Jerusalem считал их уже зараженными и не трогал. Другой же «антивирус», отечественный ANTIKOT, «лечил» файлы, распознавая наличие в них вируса исключительно по строчке «MsDos». Нетрудно догадаться, к чему приводило массовое «лечение» ранее вакцинированных программ. Тем не менее контроль «слабых сигнатур» до сих пор остается на вооружении вирусологов — как один из методов эвристического анализа. Более подробно этот вопрос будет рассмотрен дальше.

**3. Простые сигнатуры**

Наиболее популярным методом детектирования вредоносных программ является проверка сигнатур. Под **сигнатурой** понимается: фрагмент (или набор фрагментов), который всегда встречается в конкретном вирусе и никогда — в иных программах (в том числе и в других вирусах). Сигнатуры используются для детектирования вредоносных программ, сохраняющих свой код постоянным от копии к копии. Кроме того, сигнатурный поиск можно применить и для поиска некоторых разновидностей **полиморфных вирусов**. Единственная разновидность вирусов, к которой совсем не применимо сигнатурное детектирование, — это **метаморфные вирусы**. В идеале сигнатура должна включать в себя всю постоянную часть вируса, но на практике — для минимизации требуемой памяти и ускорения поиска в файле — используются сравнительно короткие цепочки байтов, состоящие из нескольких отрезков.

В общем случае сигнатура S может быть представлена в виде множества троек: S={(Ci,Pi,Ti)}, где **i** — номер отрезка сигнатуры (если она состоит из нескольких частей); **Ci** — значение отрезка; **Pi** — позиция отрезка; **Ti** — шаг трассировки, на котором необходимо контролировать отрезок. То есть три различных компонента сигнатуры отвечают на вопросы «что», «где» и «когда». Разумеется, в составе сигнатуры могут встречаться и другие компоненты вспомогательного назначения. В частности, это может быть признак: откуда отсчитывать смещение фрагмента — от начала файла, конца файла или точки входа в программу. Впрочем, этот признак тоже отвечает на вопрос «где».

Можно обойтись и без компонента «где». Самые ранние образцы антивирусов, датированные второй половиной 1980-х, занимались глобальным поиском образцов вирусного кода в подозрительных файлах — без учета их внутренней структуры. Примерно так же приходится поступать и современным антивирусам при детектировании вирусов, использующих технологию **EPO (Entry Point Obscured)**.

Итак, обязательным для сигнатуры является только компонент «что». Но каким он должен быть? Как выбрать «правильную» сигнатуру, которая однозначно характеризовала бы вирус и не встречалась более нигде?

Лет 15–20 назад, когда вирусов было мало, вирусолог мог позволить себе тщательно изучить код очередного представителя «электронной фауны» и выбрать оптимальный вариант сигнатуры.

В современных условиях такой подход трудно применим, так как, например, дежурной смене «дятлов» (как в Лаборатории Касперского величают вирусных аналитиков) приходится ежедневно иметь дело с сотнями и тысячами новых вирусов и троянских программ! Существует потребность в алгоритмах, позволяющих автоматизировать процесс выбора «хороших» сигнатур.

И такие алгоритмы есть. Например, можно вести большую базу данных со всевозможными сигнатурами всевозможных вирусов, а также наиболее типичных прикладных и системных программ. Тогда в качестве «хорошей» сигнатуры вируса можно выбирать любую цепочку его байтов, не встретившуюся в этой базе. Но, с одной стороны, такая база будет очень велика.

С другой — нет никакой гарантии, что эта сигнатура не встретится в какой-нибудь прикладной программе, отсутствующей в базе. Как, например, произошло в 2011 г. с антивирусом **Avira**, который случайно внес в свои антивирусные базы сигнатуру, характерную для программного кода антивируса Avira.

Более корректный алгоритм выбора «хороших» сигнатур в 1994 году обнародовали сотрудники IBM Дж. Кепхарт и В. Арнольд. Предположим, что стоит задача выбора сигнатуры **P** для вредоносной программы с **V = B₁B₂...Bn** длиной **S** байтов и постоянным фрагментом длиной **Q**. Нетрудно сообразить, что всего возможно **Q₅ = Q - S + 1** различных вариантов сигнатуры. Какой из них — лучший? Очевидно, тот, который не встречается ни в других вирусах, ни в «нормальных» программах, и вероятность появления его в пока еще не написанных программах тоже невелика.

Для того чтобы оценить эту вероятность, сигнатуру рассматривают как совокупность из S−n+1S - n + 1S−n+1 возможных непрерывных цепочек длиной по nnn байтов — так называемых **n-грамм**. Например, в сигнатуре V=B1B2B3B4B5V = B_1B_2B_3B_4B_5V=B1​B2​B3​B4​B5​ можно выделить три 3-граммы: B1B2B3B_1B_2B_3B1​B2​B3​, B2B3B4B_2B_3B_4B2​B3​B4​ и B3B4B5B_3B_4B_5B3​B4​B5​. Очевидно, что сигнатура, состоящая из «типичных» n-грамм, хуже сигнатуры, состоящей из «редких» n-грамм. Ее использование в антивирусе может приводить к ложным срабатываниям (**false positives**). Например, 2-грамма «MZ» характерна не только для сетевых червей, но и для любых EXE-программ, и поэтому использовать ее в составе сигнатуры нежелательно.

**4. Контрольные суммы**

Существенно уменьшить объемы требуемой памяти позволяет отказ от сигнатур в пользу контрольных сумм. **Контрольная сумма** — результат применения к произвольному набору данных некой **хеш-функции**, рассчитывающей короткий «дайджест» постоянной длины (например, всего 4 байта).

В базе данных антивируса можно хранить не сами сигнатуры, а их короткие контрольные суммы. Такие же суммы рассчитываются «на лету» по содержимому тестируемых файлов. Несовпадение хранимого по образцу с результатом расчета означает отсутствие соответствующего вируса. А совпадение лишь очень высокой (но не единичной!) вероятностью зараженности. Причина кроется в сути контрольных сумм: они, как и любые другие хеш-цифры, представляют собой отображение большого множества «объектов»-прообразов на малое множество «дайджест»-образов.

Соответственно, всегда возможна **коллизия**: несколько различных «объектов» могут иметь одинаковые «дайджесты», в частности «плохие» контрольные суммы могут оказаться не только у зараженных, но и у вполне «здоровых» файлов.

![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image002.png)

Невысокая вероятность коллизий и трудность их целенаправленного генерирования — суть критериев качества того или иного метода расчета контрольных сумм. С этой точки зрения хороши так называемые «криптографические» хеш-функции: **MD5**, **SHA-1**, **RIPEMD**, **ГОСТ 34.11-94** и др.

К сожалению, эти алгоритмы довольно сложны с вычислительной точки зрения и не способны обеспечить высокую скорость расчета контрольных сумм. Поэтому на практике в антивирусах нашли применение несколько менее стойкие к коллизиям, зато гораздо быстрее вычислимые «технические» хеш-функции.

Чаще всего используются циклические избыточные коды (**CRC** — cyclic redundancy code). Метод использования основан на представлении блока данных в виде непрерывного полинома с битовыми коэффициентами. В качестве контрольного кода используется остаток от деления этого полинома на более короткий «порождающий» полином, имеющий длину N битов.

Техника деления такова:

1.              в конец блока данных добавляется N-1 нулевых битов;

2.              вместо арифметического деления используется операция «сложение по модулю 2»;

3.              сложение с «левыми» нулями промежуточных остатков неыыы производится.

Существуют как программные реализации, так и оптимизированные по скорости благодаря сдвигу сразу на 8 битов и использованию таблицы корректирующих коэффициентов.

Ускорения расчета CRC связаны с «разворачиванием» циклов или использованием одновременного сдвига на 16 битов (что потребует увеличения таблицы корректирующих коэффициентов).

Альтернативой для CRC являются контрольные суммы, рассчитанные по алгоритму Марка Адлера. Они также представляют собой 32-битовый «дайджест» блока данных. Алгоритм Адлера выполняется несколько быстрее, чем CRC, но обеспечивает более высокую вероятность коллизий, особенно на коротких наборах данных.

Лекция от 23.10.2024

Оптимизация сигнатурного поиска

1.    Постановка задачи

2.    Фильтр Блума

3.    Метод половинного деления

4.    Разбиение на страницы

**Оптимизация сигнатурного поиска**

**1. Постановка задачи**

Ранее неоднократно отмечалось, что одним из важнейших критериев качества современного антивируса является эффективность использования вычислительных ресурсов. Речь идет о быстродействии, требованиях к дисковой и оперативной памяти и т.п.

В настоящее время известны несколько миллионов разновидностей вредоносных программ, следовательно, антивирус в общем случае вынужден выполнять такое же количество детектирующих операций (сравнений сигнатур) по отношению к каждому файлу. Неудивительно, что антивирусный монитор способен вызывать многосекундные задержки при контроле доступа к файлам, а антивирусный сканер — затрачивать десятки часов на проверку диска.

Необходимо отметить, что в современных условиях удовлетворительного решения проблемы не существует. Современные антивирусы — это клубок компромиссов: одни жертвуют надежностью детектирования, другие — быстродействием, третьи — количеством распознаваемых вредоносных программ, четвертые — возможностью лечения.

Рассмотрим основные направления оптимизации работы антивируса, использующего сигнатурное детектирование.

Итак, задача ставится следующим образом. Имеются две таблицы (БД) с записями, содержащими два атрибута: «позиция в файле» и «сигнатура постоянной длины». 1-я таблица — модель тестируемого файла, 2-я — набора вирусных сигнатур. Цель поиска — найти запись, встречающуюся сразу в обеих таблицах, либо...

Можно ставить и другие задачи оптимизации: например, уменьшение "среднего" времени поиска. Такой антивирус несколько быстрее работает при сканировании вирусных коллекций (т.е. когда любой проверяемый файл обязательно чем-нибудь заражен), но по-прежнему будет долго проверять носители, на которых процент зараженных файлов невелик.

Итак, первая таблица — это тестируемый файл. Атрибут «позиция» в нем физически отсутствует, а цепочки байтов, соответствующие различным файловым смещениям, играют роль атрибута «сигнатура».

Вторая таблица — это справочная база вирусов. В ней уникальны только пары «позиция + сигнатура», но по отдельности и «позиция», и «сигнатура» могут встречаться неоднократно. На физическую структуру этой базы пока не накладывается никаких ограничений, но именно ее мы...

Напомним суть алгоритма, позволяющего несколько ускорить процедуру глобального сигнатурного поиска при использовании метода n-грамм: Проиллюстрируем идею одного из таких алгоритмов — Бойера-Мура-Хорспула — на примере поиска образца «ЛОМ» (сигнатура) в строке «ГОЛОВОЛОМКА» (проверяемый файл). Она (идея) заключается в том, чтобы выполнять сравнение данных с образцом, начиная с его (образца) последней буквы — справа налево.

![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image003.png)

Алгоритм Бойера-Мура-Хорспула работает тем эффективнее, чем более длинные образы предлагаются ему для поиска. Основной недостаток сигнатурного детектирования — неспособность обнаружения "новых", еще не изученных вирусов. Кроме того, неприятной особенностью сигнатурных антивирусов является большой объем справочных данных. Согласно материалам «Лаборатории Касперского», количество записей в антивирусных базах растет по экспоненте. Теперь можем вернуться к вопросу оптимизации сигнатурного поиска.

Сначала будем минимизировать быстродействие антивируса за счет уменьшения размера первой, «файловой» БД.

Речь идет о том, чтобы искать «сигнатуры» в файле не везде, а только в избранных позициях. К сожалению, применение «метода n-грамм» при выборе «хороших» сигнатур приводит к необходимости поиска сигнатур по самым разнообразным смещениям в файле.

В худшем случае все эти смещения окажутся различны, и антивирусу придется считывать данные из стольких позиций в файле, сколько записей в его справочной базе.

Удачным компромиссом было бы использование для выбора (и поиска) сигнатур конечного числа файловых позиций, например:

1.              начало файла (или тела вируса, или кодовой секции...).

Другой вариант — введение дискретного ряда смещений: 0, Δ, 2Δ, ..., где Δ — некий интервал, который зависит от длины вируса V. Можно, например, положить Δ = V/100, и тогда для любого вируса всегда имеет ровно Q = 100 различных позиций, из которых могут считываться цепочки байтов — потенциальные сигнатуры. Это означает, что при помощи «метода n-грамм» будет осуществляться выбор из небольшого количества сигнатур, расположенных в заранее определённых файловых позициях. Однако, слишком маленьким это число тоже не должно быть, иначе многие «похожие» вирусы (например, принадлежащие одному семейству вирусов) могут оказаться неразличимыми.

Дальнейшие рассуждения проиллюстрируем на примере маленьких таблиц, моделирующих N = 6 различных вирусов. «Коды» этих вирусов формируются всего из трёх...

![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image005.png)

Понятно, что проще всего сформировать «антивирусную» базу, разместив в ней записи в том порядке, в каком изначально были перечислены вирусы. Увы, при такой организации антивирусной базы возможен только последовательный поиск: брать запись из одной таблицы и сравнивать её со всеми записями из второй таблицы. Потом брать следующую запись... затем ещё одну... и т.д. — до тех пор, пока не обнаружится совпадение записей либо записи в обеих таблицах не исчерпаются.

**2. Фильтр Блума**

Это метод хеширования, позволяющий отбрасывать записи, отсутствующие в вирусной БД. Идея заключается в том, чтобы вместе с БД, содержащей N записей о вирусах, хранить «битовую карту» — массив из M первоначально обнулённых битов. При добавлении к базе новой сигнатуры для нее рассчитываются K различных хеш-функций, и в «карте» устанавливаются в «1» K битов. (K < M) Индексами (адресами в карте) для этих битов становятся значения рассчитанных хешей.

После завершения создания базы «карта» оказывается заполнена перемешанными значениями «0» и «1».

![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image006.png)

При детектировании для проверяемой цепочки байтов снова рассчитывается набор индексов и проверяется, все ли соответствующие биты в «карте» установлены в «1». Искать прочитанную из файла цепочку байтов среди сигнатур базы данных имеет смысл лишь при отсутствии расхождений. Если хотя бы один из «адресов» указывает на «0»-бит, значит, соответствующей цепочки байтов (сигнатуры) в базе заведомо нет, и искать ее не стоит.

Причем, попадание исключительно в «1»-биты тоже не означает, что сигнатура в базе обязательно присутствует. Она всего лишь «может встретиться». Вероятность не обнаружить сигнатуру в базе составляет:

![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image008.png)

Оптимальное количество хеш-функций, рассчитываемых для каждой сигнатуры, ![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image010.png), но и меньшее количество не сильно ухудшит свойства фильтра. Более того, имеет смысл использовать настолько маленькие значения...

**3.**    **Метод половинного деления**

Существенно ускорить поиск позволяет «дихотомия» («половинное деление», бинарный поиск) лексикографически упорядоченной таблицы с пронумерованными по порядку записями.

Поисковый алгоритм, который последовательно делит пополам заранее отсортированный массив данных, чтобы обнаружить нужный элемент.

Основная последовательность действий алгоритма выглядит так:

1.              Сортируем массив данных.

2.              Делим его пополам и находим середину.

3.              Сравниваем срединный элемент с заданным искомым элементом.

4.              Если искомое число больше среднего — продолжаем поиск в правой части массива (если он отсортирован по возрастанию), иначе — в левой части.

Существуют два способа реализации бинарного поиска.

1.              Итерационный метод. Цикл повторяется, пока не найдется заданный элемент либо не будет установлено, что его нет в массиве. В Python для этой цели удобно использовать цикл while.

2.              Рекурсивный подход. В этом случае пишется функция, которая вызывает сама себя до тех пор, пока не будет найден искомый элемент.

![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image011.png)

Двоичный поиск подходит для нахождения позиции элемента в упорядоченном списке: в этом случае он эффективнее линейного, поскольку массив данных на каждом шаге разделяется надвое, и одна половина сразу отбрасывается.

Последовательная сложность двоичного метода в худшем и среднем случаях равна O(log n), в лучшем — O(1) (если обнаруживаем искомый элемент на первой итерации).

Для сравнения: вычислительная сложность линейного поиска равна O(n) (обычный проход по всем элементам в поисках нужного).

У бинарного поиска есть недостаток — он требует упорядочивания данных по возрастанию. Сложность сортировки — не менее O(n log n). Поэтому, если список короткий, используется всё-таки линейный поиск.

В случае сигнатурного детектирования в состав ключа, по которому выполняется упорядочивание, входит не только сигнатура, но и ее позиция (см. рис.).

![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image013.png)

**Рис.** Упорядоченная таблица сигнатур.

Если известно, что аргумент поиска меньше среднего ключа в таблице, то можно не проверять элементы в диапазоне от этого среднего и до конца таблицы. Исходная таблица окажется разделена на две примерно равные части, в одной из которых заведомо находится искомая запись. Эту «половину» можно вновь разделить пополам по средней записи и т. д., пока либо искомая...

**4.**    **Разбиение на страницы**

Это концепция, предусматривающая разделение таблицы по какому-либо признаку на независимые части («страницы») и поиск только в некоторых из них.

Наиболее естественно разделить таблицу вирусной БД на отдельные страницы в зависимости от значения поля «позиция» или комбинации «позиция + начало сигнатуры». Внутри страницы записи упорядочены лексикографически по значению поля. Какие каналы могут быть актуальные, неактуальные, почему

Лекция от 02.11.2024  
**Использование сигнатур для детектирования полиморфных вирусов**

**Вопросы лекции:**

1.              Аппаратная трассировка

2.              Эмуляция программ

3.              Противодействие эмуляции

4.              Рентгеноскопия полиморфных вирусов

Сигнатурный подход вполне применим для детектирования некоторых разновидностей полиморфных вирусов. Прежде всего легко детектируются полиморфные вирусы, построенные по «классической схеме»:

- основное тело зашифровано с переменным ключом;
- фрагмент расшифровки конструируется таким образом, чтобы алгоритм его работы в разных экземплярах вируса сохранялся прежним, но конкретные реализации этого алгоритма различались.

Идея детектирования подобных вирусов основана на том, что постоянная сигнатура в них все же присутствует — но не в начальный момент времени, а только после завершения работы расшифровщика.

1.    Аппаратная трассировка

Проще всего воспользоваться штатными средствами процессора — «отладочными прерываниями», поскольку при установке в «1» бита T регистра флагов (по умолчанию он сброшен) после выполнения процессором каждой очередной команды вызывается прерывание «INT 1».

Этот механизм доступен автору антивируса как в «реальном», так и в «защищенном» режимах процессора.

При работе под управлением MS-DOS антивирус первым делом должен обеспечить наличие большого и непрерывного, никем не используемого блока оперативной памяти. Код «подозрительной» программы загружается в свободную память и подготавливается к выполнению с использованием недокументированного режима функции 4Bh (Выполнить или загрузить программу).

Windows также предоставляет средства для использования отладочных прерываний. Правда, в этом случае обработчик прерывания принадлежит операционной системе, а «следящей» программе посылаются только сообщения о том, что прерывание произошло.

Принцип использования этого механизма таков:

- трассируемая программа запускается при помощи CreateProcess с параметром DEBUG_ONLY_THIS_PROCESS (чтобы отслеживались шаги одной-единственной программы, а не всех сразу);
- организуется цикл ожидания и обработки событий в трассируемой программе в этом цикле ловятся события – сначала одно CREAT_PROCESS_DEBUG_EVENT=0 (процесс стартовал), а потом много EXCEPTION_DEBUG_EVENT=1 (пришло отладочное прерывание) с кодом EXCEPTION_SINGLE_STEP=80000004h;

Недостатки (общие как для Windows, так и для DOS). Трассируемый вирус может сравнительно легко обнаружить в регистре флагов установленный бит T. Вирус может использовать «INT 1» и «INT 3» для своих нужд (например, для расшифровки тела) и, таким образом, заблокировать процесс трассировки.

Этот механизм доступен автору антивируса как в «реальном», так и в «защищенном» режимах процессора. Наконец, вирус может использовать известным обстоятельством, что если трассируемый код содержит команду «POP SS», то после ее выполнения процессор одно (и только одно) трассировочное прерывание пропустит, а потом снова продолжит работу в прежнем режиме. А это означает, что если автор вируса поместит наиболее «интересный» фрагмент своего «изделия» в обработчик какого-нибудь 60-го прерывания и обратиться к нему, напимер, вот таким образом: push ss pop ss int 60h nop то антивирусный обработчик в этот фрагмент не попадет, со всеми вытекающими из этого неприятными последствиями.

В принципе, «умный» обработчик трассировочного прерывания, принадлежащий антивирусу, должен постоянно «щупать» код трассируемой программы на несколько шагов вперед, подобно тому, как это делает слепец, вооруженный тростью, и по мере возможности обходить вирусные ловушки. Но это неоправданно усложняет антивирус и замедляет его работу. Отметим, что аппаратная трассировка невозможна, например, для макровирусов.

2.Эмуляция программ

Альтернативой аппаратной трассировке является эмуляция подозрительных программ. В этом случае в состав антивируса должна входить «виртуальная машина», моделирующая работу процессора, а также, по мере необходимости, внешних устройств и ОС. В случае, если эмулируется работа макровируса, «виртуальная машина» антивируса должна имитировать работу своего аналога, включенного в состав MS Office.

Эмуляция — это один из стандартных методов, который сам по себе не обеспечивает детектирования вирусов, но служит удобным и необходимым инструментом, с участием которого конкретные методы реализуются.

Работа эмулятора, в общем случае, содержит цикл выполнения последовательных действий:

- выборку и дизассемблирование очередной команды;
- моделирование выполнения очередной команды.

Дизассемблирование машинных команд (инструкций процессора) основано на знании их внутренней структуры. Размер инструкции может колебаться от 1 до 15 байтов. Результатом дизассемблирования инструкции должно быть получение следующих сведений:

- откуда извлекаются данные, с которыми манипулирует инструкция;
- какой тип действий производится над данными;
- куда помещается результат выполнения инструкции.

В фирменной документации содержатся подробные описания работы команд, выполняющих определенный тип действий:

- что происходит с данными в результате этих действий;
- какие биты регистра флагов изменяются;
- изменяются ли явно не адресуемые области памяти (например, стек);
- изменяется ли режим работы процессора и его подсистем и т. п.

Все эти сведения необходимы для точного моделирования выполнения команд. При этом приходится моделировать и внутреннюю структуру процессора (регистры, очереди и т. п.), оперативную и долговременную память компьютера, некоторые внешние устройства и прочее. Правда, в силу объемности и сложности это не всегда удается.

3.    Противодействие эмуляции

Могут ли авторы полиморфных вирусов противодействовать работе антивирусного эмулятора? Да, разумеется.

Первая группа методов противодействия направлена на использование слабостей дизассемблера. Наиболее общей проблемой является неполнота охвата системы команд процессора. Ведь с каждым новым поколением процессорных чипов к ней добавлялись и добавляются новые группы команд.

Кроме того, смена поколений процессоров приводит не только к появлению новых инструкций, но и к исчезновению старых.

Современные вирусы включают в свой код «редкие» команды, надеясь тем самым сбить с толку дизассемблирующую подсистему эмуляторов.

Другой проблемой дизассемблеров является незнание «априорного контекста», то есть условий выполнения анализируемой программы.

Одна и та же последовательность байтов может быть дизассемблирована по-разному в зависимости от режима работы процессора.

Например, программа, запущенная в среде MS-DOS, может сначала работать в 16-битовом реальном режиме, а потом переключиться в 32-битовый защищенный. В первом случае последовательность байтов «FFh 04 58h» будет проинтерпретирована как пара команд «INC/POP»:

|**FF 04**|**inc**|**[si]**|
|---|---|---|
|58|pop|ax|

А во втором случае дизассемблер должен рассматривать ее как единственную команду «INC» со «сложным» методом адресации:

FF 04 58 inc [eax+ebx*2]

Вторая группа методов противодействия эмуляции пытается помешать правильному моделированию выполнения команд.

Прежде всего следует отметить, что моделирующая часть эмулятора не всегда выполняет операции над данными в точном соответствии со спецификацией. Это связано как со вполне понятным желанием вирусологов упростить себе работу, так и с неполнотой или неоднозначностью описаний, приведенных в фирменной документации. Еще одна проблема возникает у моделирующей подсистемы, когда она не знает условий выполнения команды, в частности типа процессора. Отметим, что младшие модели процессоров Intel содержали «конвейер» — буферную память, в которую загружался фрагмент выполняемого кода. Это означало, что если уже после заполнения буфера код окажется видоизменен, то процессор будет выполнять старые, немодифицированные команды.

Но подобная конвейеризация исчезла вместе с появлением процессора Pentium. Получается, что один и тот же участок кода на процессорах разных поколений может выполняться абсолютно по-разному!

**«Глубина» трассировки и эмуляции**

Обязательно должен быть исследован вопрос: когда следует прекращать трассировку или эмуляцию подозрительной программы. Условий завершения трассировки и эмуляции несколько:

- в указанной точке программы обнаружена искомая сигнатура;
- превышено предельное количество трассируемых или эмулируемых команд (в качестве этого предела целесообразно брать максимальное поле T из всех сигнатурных записей, находящихся в распоряжении антивируса);
- превышено время, отведенное на эмуляцию или трассировку одной программы (выполнение этого условия позволяет бороться с зацикливанием антивируса);
- программа завершила работу — либо штатно, либо в результате ошибки;
- встретились участки кода, характерные для незащифрованной программы (например, обращения к операционной системе путем «INT 21h» или API-функций).

**Рентгеноскопия полиморфных вирусов**

Практически каждый полиморфный вирус обладает слабыми местами, которые можно использовать для его детектирования. Систему методов, использующих эти слабые места, назвал «рентгеноскопией» («X-Raying») вирусных тел.

Наиболее общая уязвимость полиморфных вирусов связана с используемым принципом шифрования основного тела. В большинстве случаев оно (шифрование) выполняется в соответствии с правилом:

B′=B∘K

где B — старое значение элемента кода (байта, слова или двойного слова), B′ — его новое, зашифрованное значение; K — некое число, играющее роль шифровального «ключа»; ∘\circ∘ — арифметическая или логическая операция.

Важно, что для операции ∘\circ∘ обязательно должна существовать обратная ей операция ∘′\circ'∘′, так что расшифрование всегда может быть выполнено по правилу: B=B′∘′K

Чаще всего в качестве операции шифрования используется «XOR» (она же «исключающее ИЛИ» и «сложение по модулю 2»), поскольку обратной к ней является она же сама.

Заметно реже встречается пара «ADD/SUB», не говоря уже о других комбинациях. Используя для каждой копии полиморфного вируса разные значения K, автор вируса получает индивидуальным образом зашифрованный программный код, что не позволяет выполнять для него сигнатурного детектирования. Тем не менее у описанного принципа шифрования имеются «изъяны», которые давно и с успехом используются вирусологами.

Лекция от 18.11.2024

Эвристические методы детектирования вирусов

Вопросы лекции:

1.              Постановка задачи

2.              Выделение характерных признаков

3.              Логические методы

4.              Методы на основе формулы Байеса

5.              Методы, использующие искусственные нейронные сети

6.              Концепция современного антивирусного детектора

Постановка задачи

Существуют технологии, позволяющие обнаруживать «новые», заранее не изученные вирусы. Их называют «проактивными», то есть предотвращающими активацию вируса. Рассмотрим проактивные технологии, которые базируются на методах «эвристического анализа». Под «эвристикой» (от греч. heurisco — отыскивание, открытие) понимается воспроизведение подходов, свойственных человеческому мышлению. В общем, решение задачи детектирования «нового» вируса лежит в сфере компетенции сложной математической дисциплины, известной как «распознавание образов». Эта дисциплина занимается:

·                 «кластеризацией» — выделением на множестве объектов непересекающихся классов;

·                 «классификацией» — отнесением конкретного объекта к тому или иному заранее определённому классу.

          Предполагается, что каждый объект однозначно характеризуется множеством своих признаков (числовых, логических и т. п.). Можно представить значения признаков координатами объектов в многомерном пространстве, тогда задача сведется к построению сложной поверхности, разделяющей пространство на такие области, чтобы в каждой из них группировались бы объекты только одного класса. Обычно такие поверхности строятся на основе анализа большого количества объектов, принадлежащих разным классам. При этом, возможны «неудачные» поверхности, которые не всегда правильно разделяют пространство. Их использование может привести к «ошибкам классификации»:

·                 «первого рода» – когда объект не попадает в свой класс,

·                 «второго рода» – когда объект попадает в «чужой» класс.

![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image015.png)

Исходными данными для классификации является вектор признаков, характеризующих конкретный объект.  Результатом – вывод о принадлежности этого объекта. Классификацией занимается некий «решатель», в который «зашита» (в виде математической формулы, системы правил или алгоритма) заранее построенная разделяющая поверхность. Как правило, вывод о принадлежности объекта к тому или иному классу не является однозначным.

**2 Выделение характерных признаков**

В качестве признаков, характеризующих конкретный тип вирусов, могут выступать самые разнообразные свойства или особенности «подозрительного» объекта. Все как в жизни – врач может поставить больному диагноз «грипп»:

1.              Обнаружив во время лабораторных исследований в крови соответствующие антитела;

2.              Воспользовавшись объективными симптомами – повышенной температурой, наличием кашля и насморка;

3.              А еще выслушав субъективные жалобы на головную боль и ломоту в суставах.

Можно использовать характеристики одной группы, а можно все сразу.

Современные методы распознавания образов позволяют применять как «числовые», так и «логические». Но более просто реализуется и более достоверные результаты дает использование признаков «логического» типа.

В начале в качестве «симптомов» использовалось наличие или отсутствие характерных для компьютерных вирусов «n-грамм».  
Не менее характерным признаком может служить наличие или отсутствие в программе более длинных байтовых цепочек – сигнатур и масок, присущих не конкретным вирусам и семействам, а обширным классам однотипных вредоносных программ. Например, сигнатуры «CD 21h», «9Ch 9Ah 84h 00 00 00» и маска «9Ch 68h ???? EAh 84h 0000 00» могут служить признаком того, что подозрительная MS-DOS программа вызывала некоторое системное прерывание.  
А маска «68h???????? E8h» обычно соответствует вызову некоторого системного сервиса Win32-программой. В качестве косвенных признаков, характеризующих Win32-вирусы, можно использовать следующий перечень:

·                 точка входа располагается в последней секции файла;

·                 для секции одновременно установлены флаги «writeable» и «executable»;

·                 в PE-заголовке значение поля SizeOfImage не выровнено на длину страницы;

·                 большой «зазор» между секциями (например, между предпоследней и последней);

·                 программный код начинается с «JMP» или «CALL»;

·                 нестандартное имя секции (например, «ATOMIC99»);

·                 точка входа располагается вне секций (в Win9X такие программы считались корректными);

·                 импорт производится не по именам, а по ординалам (особенно для функций GetProcAddress и GetModuleHandleA);

·                 программа содержит несколько PE-заголовков и две таблицы импортируемых имен (характерно для вирусов, использующих «оверлейный» принцип заражения);

·                 в коде программы присутствуют «CALL $+5/POP» или «CMP EAX, 00004550h»;

·                 в заголовке DLL неверна контрольная сумма (в Win9X такие DLL считались корректными);

·                 обращение к функциям «KERNEL32.DLL» или «NTDLL.DLL» выполняется по конкретным адресам;

·                 в программе используется копирование в область, начинающуюся с адреса 0xC0000000 (это неиспользуемая область в регионе VMM для Win9X);

·                 в PE-заголовке неверно значение для SizeOfCode.

Числовые и логические признаки зашифрованных и сжатых программных файлов:

·                 количество секций с одновременно установленными флагами «executable» и «writeable»;

·                 количество секций с флагом «executable», не содержащих код, и секций, не являющихся «executable», но содержащих код;

·                 количество секций с «нечитабельным» (не содержащим букв, цифр и точек) именем;

·                 отсутствие секций с признаком «executable»;

·                 превышение суммы размеров секций над длиной файла;

·                 расположение сигнатуры ‘PE’ внутри области MZ-заголовка и «заглушки»;

o       секция с точкой входа не имеет признака «executable»;

o       секция с точкой входа не содержит кода (кроме, возможно, самой первой команды).

Признаками макровирусов могут служить коды команд и функций:

·                 MacroCopy – для Wordbasic;

·                 OrganizerCopy, .Export и .Import, .AddFromFile – для VBA.

Все вышеперечисленные признаки получаются «статистическими» методами – в результате анализа двоичного образа программы. Еще больше информации для размышлений можно добыть, эмулируя (или трассируя) программу и анализируя происходящие события.

Для любого характерического вектора, составленного из перечня признаков, должны выполняться условия:

·                 небольшой размер (как правило, несколько десятков признаков);

·                 информативность (отсутствие «нехарактерных» признаков);

·                 некоррелированность (статистическая независимость) признаков.

Однако если набор признаков получен автоматизированно, например путем сканирования «тестовых корпусов» и выделения часто встречающихся «n-грамм», выбор некоррелированных признаков может оказаться непростой задачей. Для ее решения придется применять довольно сложные методы факторного анализа, например «метод главных компонентов».

**3. Логические методы**

Наиболее простой и естественный способ построения «решателей» основан на применении ко множеству обнаруженных симптомов системы «продукций».  
Продукцией называется правило вида:  
ЕСЛИ «предикат» ТО «вывод».

Предикаты (условия) могут представлять собой сложные функции над различными симптомами и ранее полученными выводами, образованные при помощи логических действий «И», «ИЛИ» и «НЕ», например:

``` Логический язык
ЕСЛИ  
"Открыть_На_Запись" И "Прочитать_Начало" И "Записать_В_Конец" И "Записать_В_Начало" И "Закрыть" ТО  
Вывод := "COM.VIRUS"; КОНЕЦ_ЕСЛИ

ЕСЛИ  
Вывод="COM.VIRUS" И "Поиск_Файлов"  
ТО  
Вывод := Вывод + "SEARCH"; КОНЕЦ_ЕСЛИ

ЕСЛИ  
Вывод="COM.VIRUS" И "Остаться_в_памяти"  
ТО  
Вывод := Вывод + "TSR"  
КОНЕЦ_ЕСЛИ

```

          У такого подхода масса недостатков:

1.              объективность итогового вывода сильно зависит от того, насколько корректно, четко и непротиворечиво вирусолог составит и опишет систему правил;

2.              при необходимости видоизменить эту систему (например, при появлении нового типа вирусов) может потребоваться переписать ее полностью с самого начала;

3.              система не позволяет учесть порядок появления симптомов в файле и т. п.

4.              Зная принципы работы, обойти его не составляло труда. Антивирус обнаруживал массу подозрительных признаков в специально образом составленных безвредных (более того, бессмысленных) программах.

Тем не менее авторов антивирусных пакетов привлекают простота и наглядность подхода.

**4. Методы на основе формулы Байеса**

Выше был упомянут неприятный недостаток «логического» подхода: «решатель» приходилось настраивать «вручную», и качество его работы зависело от опыта и умения человека.

Как альтернативу рассмотрим очень известный метод, использующий «автоматическое» обучение решателя и основанный на формуле Байеса:

![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image016.png)

где S – «симптомы»;

D – «диагнозы»;

![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image018.png) – априорная вероятность i-го «диагноза»;

![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image020.png)– частота появления i-го «симптома» при j-ом «диагнозе»;

![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image022.png) – условная вероятность истинности i-го «диагноза» при обнаружении j-го «симптома»;

N – количество возможных «диагнозов».

Сначала берется большая обучающая выборка вирусов и нормальных программ (причем количественные пропорции их должны быть примерно такими же, как в жизни), и по ней определяются исходные значения ![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image024.png)

Впрочем, для простоты можно считать, что все они одинаковы и равны ![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image026.png). Потом берется коллекция из вирусов, заранее расклассифицированных по N типам, и по ней определяются ![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image028.png) На этом обучение Байесовского «решателя» завершено. Полученные данные «зашиваются» в антивирус.

**Работа «решателя» заключается в следующем.**

Допустим, имеется подозрительная программа. Антивирус сканирует ее и находит в ней некоторый набор из KKK «симптомов» ![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image030.png)

Необходимо оценить, какова вероятность «диагноза» ![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image032.png). В этом случае по формуле Байеса вычисляются вероятности ![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image022.png) для всех ![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image034.png), входящих в набор S. Далее, в предположении, что все «симптомы» статистически независимы, можно определить вероятность:

![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image035.png)

Можно посчитать аналогичные вероятности для всех «диагнозов» и выбрать максимальную – этот «диагноз» и будет результатом классификации.

**5. Методы, использующие искусственные нейронные сети**

Это семейство «модных» методов, имитирующих работу мозга живых существ. Есть много разновидностей нейросетей (сети Кохонена, Хопфилда, рекуррентные т. п.), мы кратко рассмотрим самую изученную разновидность – «многослойный нелинейный перцептрон».

Подобную сеть можно представить как ориентированный граф из большого количества узлов («нейронов»), которые располагаются слоями.

Есть несколько «входных» слоев (с симптомами), несколько «выходных» слоев (результатов), и «внутренние слои».

На ребрах графа распространяются числовые значения – веса W. Распознающие свойства заключаются именно в значениях этих весов.

![](file:///C:/Users/Alex/AppData/Local/Packages/oice_16_974fa576_32c1d314_1edf/AC/Temp/msohtmlclip1/01/clip_image037.png)

**Описание нейронной сети**

По ребрам распространяются числовые значения. Кроме того, каждому ребру графа приписано некоторое переменное число W – «вес» ребра (еще их называют «синапсами» по аналогии с похожими элементами в биологических нейронах). Распознающие свойства нейронной сети заключаются именно в системе фиксированных значений весов W.

**6. Концепция современного антивирусного детектора**

На протяжении последних десятилетий представление специалистов и пользователей о том, как должен выглядеть и работать «идеальный» антивирусный детектор, менялось.

В общем и целом, процесс этого изменения можно представить как разделение, конкуренцию и синтез двух концепций:

·                 детектирование вирусов «в статике» – по их двоичному образу на диске или в памяти;

·                 детектирование вирусов «в динамике» – по их поведению.

Первая группа, включающая поиск сигнатур, расчет контрольных сумм, эвристический анализ признаков и прочее, была рассмотрена ранее.

При этом «Динамика» (в форме эмуляции и трассировки) играла подчиненную роль, как средство получения иного – более удобного для исследования, – но все равно статичного образа «подозрительных» программ.