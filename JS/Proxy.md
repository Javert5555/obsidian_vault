**Proxy** в JavaScript представляет объект, который позволяет перехватывать выполнение операций по отношению к другому объекту и изменять его поведение. Объект `Proxy` «оборачивается» вокруг другого объекта и может перехватывать (и, при желании, самостоятельно обрабатывать) разные действия с ним, например чтение/запись свойств и другие. С помощью _Proxy_  можно изменять поведение объекта, не меняя код объекта.

```javascript
let proxy = new Proxy(target, handler);
```

- `target` – это объект, для которого нужно сделать прокси, может быть чем угодно, включая функции.
- `handler` – конфигурация прокси: объект с «ловушками» («traps»): методами, которые перехватывают разные операции, например, ловушка `get` – для чтения свойства из `target`, ловушка `set` – для записи свойства в `target` и так далее.

_Прокси-объекты в JavaScript являются мощным инструментом, позволяющим управлять доступом к свойствам объектов, изменять их поведение, а также добавлять дополнительные функциональности. Они могут использоваться для различных целей, таких как мониторинг, отладка, создание виртуальных свойств и методов, а также другие манипуляции с объектами. Объект Proxy в JavaScript добавляет гибкость и возможность динамической реализации методов на основе их имён, что делает код более ясным и читаемым._

```js
let target = {}

let proxy = new Proxy(target, {}) // пустой handler

proxy.test = 5 // записываем в прокси (1)
console.log(target.test) // 5, свойство появилось в target!
console.log(proxy.test) // 5, мы также можем прочитать его из прокси (2)

for (let key in proxy) console.log(key) // test, итерация работает (3)
```

Так как нет ловушек, то все операции на `proxy` применяются к оригинальному объекту `target`.

1. Запись свойства `proxy.test=` устанавливает значение на `target`.
2. Чтение свойства `proxy.test` возвращает значение из `target`.
3. Итерация по `proxy` возвращает значения из `target`.

Как мы видим, без ловушек `proxy` является прозрачной обёрткой над `target`.

`Proxy` – это особый, «экзотический», объект, у него нет собственных свойств. С пустым `handler` он просто перенаправляет все операции на `target`.


![[Pasted image 20240507160401.png]]

>[!warning]
>JavaScript налагает некоторые условия – инварианты на реализацию внутренних методов и ловушек.
Большинство из них касаются возвращаемых значений:
>- Метод `[[Set]]` должен возвращать `true`, если значение было успешно записано, иначе `false`.
>- Метод `[[Delete]]` должен возвращать `true`, если значение было успешно удалено, иначе `false`.
>- …и так далее, мы увидим больше в примерах ниже.
Есть и другие инварианты, например:
>- Метод `[[GetPrototypeOf]]`, применённый к прокси, должен возвращать то же значение, что и метод `[[GetPrototypeOf]]`, применённый к оригинальному объекту. Другими словами, чтение прототипа объекта прокси всегда должно возвращать прототип оригинального объекта.
>Ловушки могут перехватывать вызовы этих методов, но должны выполнять указанные условия.
Инварианты гарантируют корректное и последовательное поведение конструкций и методов языка. Полный список инвариантов можно найти в [спецификации](https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots), хотя скорее всего вы не нарушите эти условия, если только не соберётесь делать что-то совсем уж странное.
## Значение по умолчанию с ловушкой «get»

Чаще всего используются ловушки на чтение/запись свойств.
Чтобы перехватить операцию чтения, `handler` должен иметь метод `get(target, property, receiver)`.
Он срабатывает при попытке прочитать свойство объекта, с аргументами:
- `target` – это оригинальный объект, который передавался первым аргументом в конструктор `new Proxy`,
- `property` – имя свойства,
- `receiver` – если свойство объекта является геттером, то `receiver` – это объект, который будет использован как `this` при его вызове. Обычно это сам объект прокси (или наследующий от него объект). Прямо сейчас нам не понадобится этот аргумент, подробнее разберём его позже.

Для массива:
```js
let numbers = [1,2,3]

numbers = new Proxy(numbers, {
    get(target, prop) {
        if (prop in target) {
            return target[prop]
        }
        return 0
    }
})

console.log(numbers[0]) // 1
console.log(numbers[5]) // 0
```

Для объекта:
```js
let dictionary = {
    'Hello': 'Hola',
    'Bye': 'Adiós'
}

dictionary = new Proxy(dictionary, {
    get(target, phrase) {
        if (phrase in target) {
            return target[phrase]
        }
        return phrase
    }
})

console.log(dictionary['Hello'] ) // Hola
console.log(dictionary['Welcome'] ) // undefined
```

>[!info]
Прокси следует использовать везде вместо `target`
Обратите внимание: прокси перезаписывает переменную:
>```javascript
>dictionary = new Proxy(dictionary, ...);
>```
>Прокси должен заменить собой оригинальный объект повсюду. Никто не должен ссылаться на оригинальный объект после того, как он был проксирован. Иначе очень легко запутаться.

## Валидация с ловушкой «set»

Ловушка `set` срабатывает, когда происходит запись свойства.
`set(target, property, value, receiver)`:
- `target` – это оригинальный объект, который передавался первым аргументом в конструктор `new Proxy`,
- `property` – имя свойства,
- `value` – значение свойства,
- `receiver` – аналогично ловушке `get`, этот аргумент имеет значение, только если свойство – сеттер.

Ловушка `set` должна вернуть `true`, если запись прошла успешно, и `false` в противном случае (будет сгенерирована ошибка `TypeError`).

>[!warning]
>Не забывайте вернуть `true`
Как сказано ранее, нужно соблюдать инварианты.
Для `set` реализация ловушки должна возвращать `true` в случае успешной записи свойства.
Если забыть это сделать или возвратить любое ложное значение, это приведёт к ошибке `TypeError`.

https://learn.javascript.ru/proxy