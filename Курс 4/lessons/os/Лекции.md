# Семестр1
# Лекция 1
# Операционные системы. Основы

**Операционная система** - комплекс управляющих и обрабатывающих программ, которые с одной строны выступают как интерфейс между пользователями и приложениями и с другой стороны с аппаратным обеспечением, а также предназначены для управления устройствами и процессами, для эффективного распределения вычислительных ресурсов между процессами и организации надёжных вычислений.

ПО взаимодействует с ОС с помощью системных вызовов, это запросы на выполнение ОС каких-то действий.
Совокупность системных вызовов образует интерфейс API.

## Функции ОС
1. Предоставление интрфейсов пользователя для взаимодействия с аппаратурой.
2. Эффективное распределение ресурсов между процессами, управление процессами.
3. Управляет оперативной и внешней памятью.
4. Управление вводом выводом, обеспечение работы с переферийными устр-вами.
5. Обеспечение выполнения программ.
6. Обеспечение безопасности.
7. Организация сетевого взаимодействия.
8. Сохранение информации об ошибках системы.
9. Параллельное и псевдопараллельное выполнения задач.

## Требования к ОС
1. Масштабируемость.
2. Переносимость.
3. Совместимость.
4. Надёжность.
5. Производительность.

## Классификация
По сбособу организаций вычислений:
1. Системы пакетной обработке - формирует пакет задач.
2. Системы разделения времени - используется несколькими пользователями.
3. Системы реального времени - используется при решении задач нетерпящих задержек (либо выполняется либо команда просто не выполняется).
По типу ядра:
1. С монолитным ядром.
2. С микроядром.
3. С гибридным ядром.
4. Со смешанным ядром.
По особенностям использванного алгоритма управления прцессором:
1. Однозадачные
2. Многозадачные:
	а. Невытеснящей многозадачностью
	б. Вытеснящей многозадачностью
Также: Однопользовательские и многопользовательские/многопроцессорные и однопроцессорные/однопоточные и многопоточные.
Многопроцессорные:
1. Асиметричные
2. Симетричные
По поддержке сети:
1. Локальные
2. Сетевые
По роли в сетевом взаимодействие:
1. Клиентский
2. Серверный
По типу лицензии:
1. Открытые
2. Проприетарные
По области прменения:
1. Общего назанчения
2. Мобильные
3. ОС серверов
4. ОС маршрутизаторов
5. ОС мейнфреймов(больших компьютеров)
По особенностям аппартных платформ:
1. ОС пк
2. Мини компьютеров
3. Сетей
4. Айот устройств
5. Мобильных устройств
По семействам:
1. Unix подобные
2. Windows

## Структура ОС
Современные процессы имеют два режима работы: привелигированный и пользовательский.
В пользовательском режиме не доступны команды процессора, связанные с управлением аппартатным обеспечением, а также защитой оперативной памяти, аппаратным обеспечением и переключением режима работы процессора.

## Компоненты ОС:
1. Ядро.
2. Драйверы.
3. Системные библиотеки.
4. Оболочки и утилиты.
5. Загрузчик.(UEFI- микропрограмма встроенная в мат плату, которая управляет обородуванием на низком уровне и позволяет выполнить первоначальную настройку запуска пк).

*Вопросы для самостоятельной работы:*
1. Сравнительная характеристика BIOS и UEFI.(До 10 пунктов)
2. Эволюция ОС семейства Windows(типо с 60-х годов по десять лет примеры)
3. Эволюция ОС семейства Unix

*ДЗ:
Котнтрольные вопросы и пуНкт самостоятельные задачи*

# Ядро ОС

## Основыне понятия
Ядро - это (прграмма) центральная часть ОС, постоянно находящаяся в оперативной памяти и обеспечивающая приложениям координированный доступ к ресурсам, таким как: процессорное время, оперативная память, периферийные устройства и предоставляет сервисы файловой системы и сетевых протоколов.

## Функции ядра
1. Управление процессами.
2. Управление памятью.
3. Управление устройствами.
4. Управление прерываниями(сигнал, который поступает процессору о наступлении какого-либо процесса).
5. Выполнение операции ввода вывода.

Объект ядра - это блок пямяти, доступный только ядру для выполнения его целей, объект содержит: имя, класс защиты, счётчик пользователей, смещение в ОП и т.д.. Свойства объектов наследуются.


# Лекция 2
## Типы архитектур ядер
**Монолитное ядро** работает в едином адресном пространстве, это такаая схема при которой все составные части являются одной целой программы.

Недостатки: 1) сбой в одном компоненте программы вызывает сбой всей программы. 2) Из-за применения процедурного программирования, который подразумевает наследование от предыдущего кода занимает много памяти, следовательно падает производительность.

**Модульное ядро** - это модификация архитектуры монолитных ядер , которая оддерживает механизм поддержки модулей поддерживающих аппаратное обеспечение динамически (без перезагрузки ОС) или статически, но модули работают также в едином адресном пространстве поэтому модульность осуществляется на уровне бинарного образе, а не на архитектурном уровне ядра. Для динамической подгрузки/выгрузки модулей используется интерфейс API.

Недостатки: работа в едином адресном пространстве, ограничения связанные с применением API интерфейса
Плюсы: модульность выполнения кода, облегченная отладка.

**Микроядро** -современная архитектура ядра в котором присутствуют элементарные функции управления процессами и минимальный набор функций для управления оборудованием, большая часть работы осуществляется с помощью сервисных прграмм, которые являются специальными пользовательскими процессорами. Поэтому почти все драйвера и модули расположены в сервисных процессах и являются расширением ядра. Каждый модуль имеет своё адресное пространство. Такой тип архитектуры уменьшает размер ядра но скорость выполнения процессов и предоставления других услуг значительно меньшше чем в монолитных архитектурах

Достоинства: 
1) _расширяемостью_, которая присуща микроядерной операционной системе в очень высокой степени
2) _надежностью,_ так как каждый сервер выполняется в виде отдельного процесса в своей области памяти и таким образом защищен от других серверов операционной системы
3) поддержкой распределенных вычислений, так как используются механизмы, аналогичные сетевым
Недостатки:
1) Малая производительность.

В  ОС windows процессы, вынесенные на уровень пользователя называются сервисами, в ОС unix - демонами и работают в фоновом режиме

**Экзоядро** - тип ядра предоставляет только функции для взаимодействия между процессорами и безопасного выделения ресурсов, при этом API предоставляется внешними по отношению к ядру библиотеками.

Достоинства: доступ к устройствам на уровне контроллера;
Недостатки: нескольким прикладным программам нельзя предоставлять доступ для прямого управления памятью; низкоуровневый доступ затрудняет преносимость ОС.

**Наноядро** - выполняет обработку аппартных прерываний генерируемых устройствами компьютера. Результаты обработки передаёт вышестоящему ПО после обработки прерываний.

Достоинства: 
1) Простота реализации;
2) Надёжность
Недостатки:
1) Так как большую часть работ выполняют драйвера устройтсв соответсвенно и код становится сложнее.


**Гибридное ядро** - модифицированные микроядра.

**Смешанное ядро** - комбинация разных типов архитектур ядер.

## Виды ОС

**Сетевые ОС** - сетевая операционная система – это операционная система, которая обеспечивает обработку, хранение и передачу данных в информационной сети.

Компоненты сетевой ОС:
1) Сервер - предоставляет собстенные ресурсы и услуги в общее пользование;
2) Клиентская часть - средство управления локальными ресурсами компьютера, которая содержит компонент запроса доступа к удалённым ресурсам и услугам и их использование, эта часть выполняет распознавание и перенаправление в сеть запросов к удалённым ресурсам от приложений и пользователям, называется редиректором запрос от приложения или пользователя поступает в локальной форме, а передаётся в сеть в форме соответсвующей требованиям сервера и вобратном действии выполняет тоже.
3) Коммуникационная часть - обеспечивает адресацию и буферизацию сообщений, выбор маршрута передачи по сети, осуществляет надёжность передачи и т.д.

Типы сетевых ОС:
1) Одноранговые - все компьютеры равны в правах доступа к ресурсам друг друга
2) Двухранговые сети - сети, с выделенными серверами, которые не используются для выполнения текущих задач, а имеют специализированное назначение, например, сервер ббаз данных и т.д., при этом все другие ПК могут выполнять функции и клиента и сервера одновременно

**ОС реального времени** - это ОС в которой успешность работы любой программы зависит не только от её логической правильности, но и от времени, за которое она получила результат, если ситема не удовлетворяет врменным ограничениям, то должен быть зафиксирован сбой в её работе.

Типы ОСРВ:
1) Жёсткая (hard) ОСРВ: ОС которая может обеспевчить требуемое время выполнения задачи даже в худших условиях, не допускают задержек в системе, так как это моет привести к потере актуальности результатов и авариям. К ним относят системы управления бортового оборудования, системы аварийной защиты и регистраторы аварийных событий
2) Мягкая (soft) ОСРВ - может обеспечить требуемое время выполнения задач в среднем, характеризуются возможной задержкой реакции.



Вопросы на самост выполнение:
1) Какие типы архитектур ядер в современных ОС?
2) Архитектуры ОСРВ


## Отличительные черты ОСРВ
![[Pasted image 20221005143108.png]]

## Архитектуры осрв
![[Pasted image 20221005143502.png]]
![[Pasted image 20221005143518.png]]
![[Pasted image 20221005143530.png]]

## Основные сервисы
-   Управление задачами. Самая главная группа **сервисов**.
-   Динамическое распределение памяти. Многие (но не все) ядра **ОСРВ** поддерживают эту группу **сервисов**.
-   Управление таймерами.
-   Взаимодействие между задачами и синхронизация.
-   Контроль устройства ввода-вывода.


# Лекция 3

# Управление процессами

Процесс - это единица работы, требующая заявку на потребление системных ресурсов.

Функции подсистемы управления процессами:
1) Планирование выполнения процессов - распределние процессорного времени между несколькими одновременно существующими в системе процессорами
2) Создание и уничтожение процессов
3) Обеспечение процессов необходимыми системными ресурсами
4) Обеспечение взаимодействия между процессами

Процессы:
1) Рождение - процессу распределяется адресное пространство которое загружается в программный код, выделяются стеки системных ресурсов и устанавливается начальное значение программного счётчика этого процесса
2) Готовность - пассивное состояние процесса, когда он заблокирован в связи с внешними по отношению к нему обстоятельствами.
3) Ожидание - пассивное состояние процесса, когда он заблокирован по своим внутренним причинам и ждёт осуществление некоторого события
4) Исполнение - активное состояние процесса, при котором он обладает всеми необходимыми ресурсами и выполняется процессором
Выйти из состояния исполнения процесс может выйти по 3 причинам:
- ОС прекратила его деятельность
- Не может продолжить работы пока не наступит некоторое событие
- В результате возникновения прерывания в вычислительной системе
5) Смерть или завершения работы

## Контекст и дескриптор процесса

При создании процесса формируется некоторая структура данных, которая называется блоком управления процесса, который представляет собой модель процесса для ОС.

ПКБ состоит из контекста и дескпритора

Контекст - это содержимое всех ригистров процессора необходимое для восстановления состояния его операционнй среды в случае возобновления выполнения процессов. Включает в себя регистровый системный и пользовательский контекст процесса

Регистр процессора - сверхбыстрая память внутри процессора предназначенная для хранения просежуточных результатов вычисления и содержащая данные необходимые для работы процессора такие как: уровни доступа, смещение базовых таблиц, регистры сегментов памяти и т.д.

Дескриптор - оперативная информация, такая как: id процесса, состояние, приоритет, место нахождения кодового сегмента и смещения в этом сегмента.

Чтобы процесс выполнялся он должен быть загружен в оперативную память, выполняется процессором.

В очереди к ОП стоят дескрипторы отдельных процессов

Создать процесс со стороны ОС - это:
1) Создать информационнуе структуры, описывающие данные структуры, то есть ПКБ
2) Включить дескриптор нового процесса в очередь готовых процессов
3) Загрузить кодовый сегмент процесса в оперативную память

Виды процессов:
1) Процесс родитель - процесс который инициировал создание нового процесса, а созданный им процесс будет процессов ребёнком
2) Процесс зомби - дочерний процесс завершивший своё выполнение, но ещё присутствующий в списке процессов операционной системы, чтобы дать родительскому процессу считать код завершения.

Переключение контекста - для корректного переключения процессора с одного процесса на другой необходимо сохранить контекст исполняющегося процесса и восстановить контекст процесса на который будет переключен процессор.

# Лекция 4
## Уровни клонирования процессов

1. Долгосрочная
2. Среднесрочная
3. Краткосрочное

## Параметры планирования

Все параметры планирования делятся на:

1. Статические – такие, которые не меняются по ходу работы ОС (максимальные значения ресурса, количество переферийных устройств, объемы буферов). Это предельные значения ресурсов вычислительной системы: размер ОП, максимальный размер свопинга, кол-во подключённых устройств ввода вывода, информация о пользователе, который запустил процесс, приоритет процесса, предельное процессорное время на выполнение процессов и соотношение процессорного времени и времени, затрачиваемого необходимого на ввод/вывод.
2. Динамические – такие, которые могут меняться. Они описывают кол-во свободных ресурсов на данный момент.
**Промежуток времени непрерывного использования процессора** носит на английском языке название CPU burst, а промежуток времени непрерывного ожидания ввода-вывода - I/O burst.
Количественные показатели динамических параметров: потерянное время M=T-t показывает долю процессорного времени или долю потерянного времени вобщем времени реакции, Отношение реактивности R=t/T показывает долю процессорного времени или долю потерянного времени в общем времени реакции, штрафное отношение P=T/t показывает, во сколько раз общее время выполнения процесса превышает необходимое время, где t - процессорное время, необходимое процессу для выполнения, T - длительность пребывания процесса в системе.

## Виды алгоритмов планирования процессов
1. Алгоритмы, основанные на квантовании.
Смена активного активного процесса происходит, если: процесс завершился и покинул систему, произошла ошибка, процесс перешёл в состояние ожидания
3. Алгоритмы, основанные на приоритетах.
Приоритет - это число. Существуют алгоритмы на относительных приоритетах и на абсолютных приоритетах.

## Вытесняющие и невытесняющие алгоритмы планирования

Невытесняющая многозадачность основана на относительных приоритетах.
Вытесняющая многозадачность основана на абсолютных приоритетах.

_Невытесняющая многозадачность -_ это способ планирования процессов, при котором активный процесс выполняется до тех пор, пока он сам, по собственной инициативе, не отдаст управление планировщику операционной системы для того, чтобы тот выбрал из очереди другой, готовый к выполнению процесс.

_Вытесняющая многозадачность -_ это такой способ, при котором решение о переключении процессора с выполнения одного процесса на выполнение другого процесса принимается планировщиком операционной системы, а не самой активной задачей.

**Механизм работы планировщика ос при вытесн. многозадачн.**:
В очередь готовых процессов помещаются их дескрипторы, в соответствие с некоторым приоритетным алгоритмом, либо к поределённому разделу ОП, либо к общей ОП. Планировщик выбирает из очереди процесс с наивысшим приоритетом и загружает в ОП сначала дескриптор, контекст и тело процесса. Транслятор преобразует код процесса, написанного на языке высокого уровня в низкоуравневый язык и процессор выполняет инструкции процесса, если в очереди процессов появляется процесс с более высоким приоритетом чем у активного, то процессор выполняет до конца текущую инструкцию, фиксирует контрольную точку останова, планировщик выгружает из ОП дескриптор и тело процесса и переводит его в состояние ожидания, далее процесс с более высоким приоритетом загружается в ОП по указанной выше схеме, в ходе жизненного цикла процесс может быть неоднократно прерван и заново выбран на исполнение. Из ОП процесс выгружается на жёсткий диск. Прерванный процесс может быть обратно возвращён в ОП, если он на данный момент имеет наивысший приоритет, при этом в ОП возращается его дескриптор и тело, и выполнение начинается со следующей инструкции после точки останова. Когда процесс полностью выполнился в ОП из Оп выгружается его дескриптор тело, а потом контекст.

## Потоки
В мультипроцессорных системах поддерживается механизм многопоточной обработки: процесс делится на несколько потоков, которые выполняются псевдопараллельно или параллельно.
Потоки, относящиеся к одному процессу не изолированы друг от друга ка процессы, поэтому между ними легко организовать взаимодействие.
Потоки имеют одно и тоже адресное пространство, то есть разделяют одни и те же глобальные переменные.
Каждый поток имеет доступ к каждому виртуальному адресу в рамках адресного простанства процесса, поэтому один поток может использовать стек другого потока. При этом между потоками нет полной защиты.
Потоки имеют собственные: программный счётчик, стек, регистры, состояние и потоки-потомки.
Потоки разделяют: адресное пространство, глобальные переменные, таймеры, симофоры, статическую информацию и открытые файлы.
Широко-многопоточная обработка применяется распределённых системах.

# Лекция 5
## Алгоритмы планирования

### First-come First-Served
First-come First-Served - аналогичен алгоритму програ FIFO, это вид невытесняющего планирования.
Достоинства: 
- Простота реализации
Недостатки:
- Алгоритм не применимдля систем разделения времени, так как среднее время отклика получается большим

### Round Robin (RR)
Round Robin (RR) - вытесняющее планирование, при котором процессы выполняются циклически, при этом каждому процессу на выполнение выдаётся определённый квант времени.
Достоинства:
- Данный алгоритм применим для ОС реального времени и идеально работает, при равенстве cpu burst и выделенного кванта времени.
Недостатки:
- Если квант времени большой, то каждый процесс завершит выполнение до его окончания и алгоритм выродится в firts-come, first-served.
- Если величина кванта очень малая, то ОС будет тратить больше времени на переключение контекста, что снизит производительность системы.

### Shorted-Job-First
Делятся на вытесняющие и невытесняющие.
Приоритет отдаётся процессам с наименьшим cpu burst, то есть с наименьшим временем выполнения.

Самостоятелно посчитать среднее время ожидания и среднее полное время выполнения этого алгоритма.

Среднее время ожидания:

Пусть t(n) - это величина n-ого cpu burst, T(n+1) - это предсказываемое значение n+1 cpu burst, a -нек величина от 0 до 1:
T(N+1)=at(n)+(1-a)T(n),
если T(N+1)=T(0), то первое слагаемое этот уравнения at(n) уитывает последнее поведение процесса, а второе слагаемо учитывает предыдущее поведение; процессов;
если а=0, то последнее поведение процесса не отслеживается, то есть оценивается его поведение до последнего;
если а=1, то оценивается его последнее поведение, а предыстория не учитывается;
если а=0.5, то at(n)+(1-a)T(n) _(посчитать самостоятельно)_

Достоинства:
- Если в системе больша часть будет процессов с коротким cpu burst, то система будет высокопроизводительной
Недостатки:
- Чтобы применить этот алгоритм, необходимо знать длительность процесса, которое задано разработчиком, либо вычисляется методом экстраполяции.

### Round-Robin SJF
Round-Robin SJF - это алг. RR с переупорядочиванием процессов в очереди в соответствии с оставшимя временем выполнения.

### Лотырейное планирование
Процессам на доступ к различным системным ресурсам раздаются лотырейные билеты (самый требуемый - процессорное время), которые разыгрываются один раз в указанный промежуток времени и выигравший процесс получает квант процессорного времени.
Высокоприоритетным системным процессам раздаются дополнительноые билет, чтобы повысить их шансы на выполнение, чем у процесса больше лотерейнх билетом, тем выше у него шанс получить процессорное время.
Новому процесса или вновь появившемся процессу выдаются лотерейные билтеы, в таком количестве, чтобы уравнять его шанс на получение процессорного времени в первом раунде.
Взаимодействующие между собой процессы могут обмениваться между собой билетами.

### Гарантированное планирование
Пусть в системе имеется N-пользователей, при данном алгоритме каждый пользователь будет иметь в своём распоряжении 1/N процессорного времени, для каждого i-того пользователя Ti - время нахождения пользователя в системе, ti - суммарное проц. время, выделенное всем его процессам течение одного сеанса, для пользователя справедливо получение Ti/N проц. времени.
Если ti<<Ti/N, то i-ый пользователь обделён проц. временем.
Если ti>>Ti/N, то i-ый пользователь получит слишком много  проц. временем.
Знач. коэф справедливости для каждого пользователя будет высчитываться tiN/Ti, то есть система будет предоставлять очередной квант врмеени процессу с наименьшей величиной этого коэффициента.
_Недостаток:_ у отдельных пользователей сеанс работы может висеть долгое время, в резултате чего его процессы будут получать неоправданно много процессорного времени.

### Half-Life Round Robin
Каждому i-ому процессу присваивается некоторое приоритетное число P[i]=P[0]+U[i]/2, чем оно меньше тем выше приоритет процесса, новый процесс получает приоритет P[0] и каждый процесс связан с счётчиком процессорного времени U[i]=U[i]/2, начально значение U[i]=0.
Процесс с наименьшим значением U[i] получает квант времени q, по-окончанию кванта интервальный таймер выдаёт сигнал с прерыванием, по каждому такому сигналу счётчик U[i] активного процесса увеличивается на 1, когда процесс полностью завершил своё выполнение, пересчитываются счётчики всех активных и неактивных процессов по формуле U[i]=U[i]/2 и для всех процессов пересчитываются все приоритетные числа по формуле P[i]=P[0]+U[i]/2 и с получением новых значений модифицируется очередь. (Алгоритм с вытеснением и с приоритетом).

### Highest penalty radio next
Алгоритм без вытеснения, в котором динамически переопределяются приоритеты. Каждый раз, когда освобождается процессор, то для готовых процессов в очереди вычисляются текущие штрафное отношение: p[i]=(w[i]+t[i])/t[i], i- номер процесса, w[i]- время, затраченное процессом на ожидание, t[i]- длительность процесса, предназначенная или прогнозируемая. Для нового процесса p[i]=0. Процессорное время даётся процессу, у которого наибольшее приоритетное число.

_Недостаток:_ вычисление штрафного отношения при каждом вычислителном процессе, падает производительность; для коротких процессов HPRN переходит в HDN, в длинных в First-come First-Served

### Selfish RR
Алгоритм с вытеснением. Все процессы делятся на новые и выбранные . Новые - не получали не разу квант времени, все остальные выбранные. Для нового процесса приоритетное число=0, которое потом возрастает. В конце каждого кванта времени пересчитываются приоритеты всех процессов, причём у новых процессов приоритет возрастае на величину dA, у выбранных на величину dB. Время отдаётся процессу с наивысшим приоритетом, время отдаётся процессу, который дольше всех стоял в очереди. При dB/dA=0 алг. превращается в RR, при dB/dA>=1 алг. превращается в FCFS, при 0<dB/dA<1 работает сам алгоритм.

### Многоуровневые очереди

![[img-B0Hinm.png]]

FB(foreground-background) - очередь готовых процессов разделяется на две: Очередь переднего плана и заднего, внутри каждая очередь обслуживается алгоритмом RR, более высокий проритет имеет очередь переднего плана, пока в ней есть незавершившиеся процессы очередь заднего плана не обслуживается. Новый процесс попадает в очередь переднего плана, ему выделяется n-квантов 
процессорного времени. Если процесс не успевает завершится за выделенный квант времени он переходит в очередь заднего плана


### Многоуровневые очереди с обратной связью (Multilevel Feedback Queue)

![[6.gif]]

Алг. основан на вытесняющем приоритетном планировании. Чемы выше очередь тем больше её приоритет. Внутри очередь организована по алг. RR. Процессы из очереди 2 не могут выполняться, пока в очереди 1 есть процессы и т.д.. Новый процесс поступает в очередь 1 и ему выделяется кавнт времени Q. Если процесс не выполняется за этот квант, он помещается в очередь 2 и ему даётся проц. время размером 2Q. Если он опять не выполняется за выделенное ему время он помещается в очередь 3 и ему даётся проц. время 4Q. Если он опять не выполняется, он помещается в очередь 4 до полного завешения. Помещение процесса.
Возможна миграция процессов в обратном направлении в следующих случаях:
1) Если процесс в состоянии ожидания ввода с клавиатуры и при наступлении этого действия он из низкоприоритетной очереди может переводится в очередь 1.
2) Если процесс в состоянии ожидания завершения операции ввода/вывода, то процесс из очереди 2 или 3 перемещается в очередь 1.

## Алгоритмы планирования ОСРВ (Оба на приоритетах)

## Динамический алгоритм планирования (EDF)
Приоритет процессам присавивается динамически причём наивысший приоритет отдаётся тому процессу, у которого осталось наименьшее время выполнения.

## Статический алгоритм планирования (RMS)
Статический алгоритм планирования (RMS) - приоритетный алгоритм ОСРВ. Каждому процессу заранее назначается приоритет, приэтом процесс должени удовлетворять следующим условиям:
1) процесс должен быть заверешен за предоставленное ему время;
2) процессы не зависят друг от друга;
3) каждому процессу требуются кванты времени равного размера;
4) прерывание процесса происходит за ограниченное время.
Наивысший приоритет отдаётся процессам у которых наименьшее CPU-burst.

# Лекция 5  
# Тупики или deadlock  
  
Пусть 2 процессам в системе для выполнения их работы нужно 2 ресурса, например принтер и диск. После того как процесс A занял принтер, то есть установил блокирующую переменную, он был прерван, управление получил процесс B, который сначала занял диск, но при выполнении следующей команды был заблокирован, т.к. для дальнейшей работы ему нужен был ресурс - принтер, а он был занят процессом A, управление снова получил процесс A, который в соответствии со своей программой сделал попытку занять диск и был заблокирован, такая ситуация называется тупиком или deadlock-ом. В тупике могут участвовать 2 и более процессов, но в зависимости от соотношения скоростей процессов, они могу либо независимо использовать разделяемые ресурсы, либо строить очереди к разделяемым ресурсам, либо взаимоблокировать друг друга.  
  
Тупики могут быть предотвращены в следующих случаях:  
1) При написании программ должны быть учтены соотношение скоростей взаимных процессов;  
2) С помощью динамического подхода, который заключается в применении определённых правил, при назначении ресурсов процессам;  
3) Монитор - это набор процедур, которые могут вызывать процессы, но они не имеют доступа к внутренним данным монитора, только 1 процесс может быть активным по отношению к монитору  
  
# Управление устройствами. Прерывания  
  
Прерывание - механизм, который координирует параллельное функционирование отдельных устройств и реагирует на особые состояния, при работе процессора, путём принудительной передачи управления от выполняемой программы к системе далее в обработчик прерывания. Цель прерывания - реализация асинхронного режима функционирования с помощью аппаратно-программных средств системы.  
  
Прерывания возникают в следующих случаях:  
1) Завершение операции ввода/вывода;  
2) Истечение заранее заданного интервала времени;  
3) Попытка деления на 0;  
4) Сбой в работе аппаратного устройства  
  
### Типы прерываний  
#### Аппаратные (IRQ)  
  
Аппаратные (IRQ) - события от периферийных устройств или события в микропроцессоре, возникающие в результате подачи сигнала от аппаратуры, который передаётся на специальный вход прерывания процессора. Аппаратные прерывания не координируются с работой ПО, когда оно возникает, процессор останавливает свою работу, выполняет обработку прерывание, а затем возвращается на место останова.  
  
Аппаратные делятся на внутренние и внешние:  
1) Внешние прерывания инициируется периферийными устройствами;  
2) Внутренние - это те, что происходят в микро процессоре.  
  
**Внутренние прерывания** ещё называются исключениями и вызываются синхронно выполнению программы, при появлении аварийной ситуации в ходе исполнения какой-то инструкции, то есть возникают в ходе выполнения тактов команды процессора, возникают в следующих случаях:  
1) при нарушении адресации, когда в адресной части выполняемой команды указан запрещённый или несуществующий адрес;  
2) при наличии в поле кода незадействованной двоичной комбинации;  
3) при делении на ноль;  
4) при переполнении или исчезновении счётчика команд;  
5) при возникновении ошибок чётности после проверки устройств аппаратуры средствами контроля.  
  
**Внешние прерывания** являются асинхронными по отношению к потоку инструкций прерываемой программы, то есть возникают между выполнением двух соседних инструкций.  
Виды внешних прерываний:  
1) Прерывания которые информируют систему о том, что требуемый сектор диска уже прочитан и его содержимое доступно программе;  
2) Прерывания которые информируют систему о том, что завершилась писать символа на принтере и необходимо выдать следующий символ;  
3) Прерывания которые информируют систему о том, что была нажата/отжата определённая клавиша на клавиатуре;  
4) Прерывания по нарушению питания;  
5) Прерывания по таймеру.  
  
Виды внешних прерываний: **Маскируемые (INTR)** и **немаскируемые (NMI)** внешние прерывания.  
  
**Маскируемые прерывания** - это тип отдельных сигналов прерывания, на который выставлен запрет для запуска обработчика прерывания от процессора.  
  
**Немаскируемые** - это те, которые нельзя запретить.  
  
#### Программные прерывания  
  
Программные прерывания не являются асинхронными, процессор выполняет те же действия, что и при аппаратных прерываниях, но только это происходит в предсказуемые точки программы, там, где разработчики указал данную команду  
  
Виды программных прерываний:  
1) Привилегированная команда в режиме пользователя;  
2) Указан адрес вне диапазона;  
3) Нарушение защиты памяти;  
4) Арифметическое переполнение;  
5) Выход за границу сегмента памяти.  
  
## Обработка прерываний  
  
С каждым прерыванием связано число, называемое номером прерывания. Система распознаёт по номеру какое прерывание произошло и запускает соответствующий этому номеру обработчик прерывания, таким образом происходит принудительная передача управления от управляемой программы к системе, а далее к обработчику прерывания.  
  
Векторы прерываний -адреса программ соответв. различным прерываниям собраны в таблицу векторов прерываний, которая занимает первый килобайт оперативной памяти в адресат от 0000:0000 до 0000:03FF. Таблица состоит из 256 элементов адресов обработчиков прерываний, эти адреса называются векторами прерываний. В первом слове элемента таблицы записано смещение, а во втором адрес сегмента обработчика прерывания. Такой адрес состоит из пары двух байтов слов, поэтому весь вектор занимает 4 байта. Инициализация данной таблицы происходит через UEFI после тестирования аппаратуры и перед началом загрузки системы и захватывает частично при загрузке ОС.  

В таблице векторов существует 3 вида адресов:
1) Адреса, указывающие на bios или uefi, которые иентифицируются 16-ричной буквой цифрой F, она предшествует номеру сегмента.
2) Адреса, которые указывают на главную память, например 019A:4EE8. В этих адреса идёт указатель на подпрограммы и резидентные программы.
3) Адреса, состоящие из одних нулей, показывающие, что прерывания с конкретным номером в текущий момент не обрабатывается.

# Лекция 6
## Механизм обработки прерываний

При обработке каждого прерывания выполняется следующая последовательность:
1) Приём сигнала и идентификация прерывания;
2) Запоминание состояния прерванного процесса, а именно определяется значением счётчика команд, то есть адреса следующей команды и состоянием регистров процессора;
3) Передача управления прерывающей программе, а именно счётчик команд заносится в начальный адрес подпрограммы обработчика прерываний, а в соответствующие регистры заносится информация из слова состояния процессора;
4) Происходит обработка прерывания;
5) Восстановление прерванного процесса и возврат в прерванную программу.

## Функции механизма прервывания

1) Распознавание и идентификация прерывания;
2) Передача управления собственному обработчику прерываний;
3) Возврат к прерванному процессу;
4) Запуск на исполнение прерванного процесса.

В случае возникновения высокоприоритетного прерывания во время работы обработчика прерываний, которая назыв. **вложенным прерыванием**, работа обработчика переключается на это вложенное прерывание. 
Для каждого класса прерываний в системе имеется рабочая область прерываний, которая подразумевает первоочередность обработки прерываний, находящихся в ней.

Сохранение и восстановления состояния процессора и содержимого регистров, назыв. операцией контекстного переключения.

При сохранении состоянии процессора записывается признак определяющий в каком режиме находится процессор в пользовательском или привилегированном. Он может принимать значения 0 и 1. 0 -  будет происходить обработка программ, находящихся в пользовательском режиме, 1 - в привилегированном.

Состояние процессора определяется словом. **Первый элемент** определяет режим процессора (пользовательском или привилегированном). **Второй элемент слова** - значение указывающее на причину прерывания: при программном прерывании указывается тип вызвавшего его условия, при аппаратном прерывании указывается номер канала, вызвавший прерывания. **В третьем элементе** указывается состояние процессора(исполнение/простой(ожидание/готовност)). **Четвёртым элемент слова** - идентификатор текущей выполняемой программы. *Пятое* - указывается маска прерываний, она используется для контроля за разрешением прерываний. В маске каждый бит соответствует некоторому классу прерываний, если бит равен 1, то прерывания данного класа разрешены, если 0, то запрещены. Когда прерывания запрещены - они называются маскированными.

Маскированные прерывания не теряются, потому что сигнал, вызвавший прерывание сохраняется аппаратурой. Таким образом маскированные прерывания становятся отложенными до того момента, пока они не обработаются более высокоприоритетные прерывания другого класса. Когда значение 5-го элемента слова поменяется на 1, то маскированные прерывания разрешаются, сигнал опознаётся и происходит прерывание.

![[Pasted image 20221214152008.png]]

# Семестр 2
# Лекция 1
# Обзор Российских ОС

Всё программное обеспечение можно условно разделить на 2 категории: системное и прикладное.
Системное ПО представляет среду и сервисы для работы прикладного ПО. Именно на уровне системного ПО решаются базовые вопросы обеспечения надежной и безопасной работы приложений. Представителем системного ПО являются ОС. Классы устройств для которых сущ. ОС:
- СЕРВЕРЫ
- рабочие станции
- мобильные устройства
- системы хранения данных
Практика производителей заключается в выпуске как серверных, так и клиентских дистрибутивов одновременно, поэтому иногда эти две категории могут быть объединены в один класс продуктов

## ОС Альт

Разработчик "Альт СПО"

ОС Альт Рабочая станция, Альт Сервер, Альт 8 СП входят в Единый реестр российских программ и БД, сто предоставляет больше возможностей развёртывания и миграции как инфраструктуры, так и парка серверов и ПК организациям осуществяющим закупки в соответсвие с 44 ФЗ

Альт 8 СП - это дистрибутив ОС для серверов Альт 8 СП Сервер и рабочих станций Альт 8 СП Рабочая станция со встроенными прогр средствами защиты инф., сертифицированный в стек России на базе линукс, включает полный пакет офисных приложений, серверная версия может использоваться для управления гидрогенными сетями и бездисковыми клиентами, а также выполнять роль рабочей станции разработчика. Выпускается для след. аппаратных платформ: Intel i586/x86, Э...

Альт 8 СП является ОС типа А, соответствует требованиям документов "Требование безопасности инф. к ОС" и "И профиль защиты ОС типа А 4 класса защиты". ОС Альт 8 СП обеспеч требования по безопасности по инф по 4 уровню доверия. Дистр. Альт8 включен в единый реестр Российских программ для электронных вычислительных машин и БД. ОС Альт 8 СП в соответсвии с нормативных правовым актом требования безопасности к ОС:
- для обеспечения выполнения программ в защитной среде
- для работы со средствами виртуализации
- для применения в гос. инф. системах 1-го класса защищённости
- для применения в автоматизированных системах управления производственными и техн процессами 1-го класса защищённости
- для применения в инф. системах персональных данных, при необходимости обеспечения  1-го уровня защищённости персональных данных
- для применения в инф. системах общего пользования 2-го класса

## Astra Linux

Разработчик ОО "Рус Бит Тех Авто"

Релизы Astra Linux SE - единственная русская ОС сертифицированная всеми 3 регулят. инф без.: фсб, фтэк, мо.
Astra Linux Orel - версия ОС общего назначения без усиленных средств защиты данных.

Astra Linux SE для применения в IT в астре предусмотрены 3 варианта централивзованных систем управления аутентификации и безопасностью. Собственный домен.

ОС в полной мере поддерживает стандарт аутентификаций Kerberos.
Серверная версия продукта  имеет большой набор для серверных приложений.
Имеет интерфейс Fly? который для быстрой работы не требует высокой производительности ПК, Встроенное средство управления виртуализацией и иные, что позволяет без доп. затрат развернуть среду виртуализации. Представляет собой единую платформу для устройств с процессорной архитектурой x86-64 ноутбуков, пк и серверов, мобильных устройств, встраиваемых спецвычислителей, маршрутизаторов и межсетевых экранов.

## Astra Linux SE

Набор входящих в ос прил. обеспечивает:
- систем убд
- пакетов программ электронной почты
- web-серверов и серверов эл почты
- косплексов по для резервного копирования
- пакетов офисных программ для работы с докумментами и др

Система не требует применения наложенных средств защиты и оптимально подходит для
- госинф систем и торговых площадок
- компонентов критической инф ифраструктуры
- систем для работы с гос. тайной, в том числе с грифом особой важности
- инф систем для обработки персональных данных

Соответсвие требования регуляторов обеспечивают:
- встроенная система безопасности PARSEC
- мандатное разграничение доступа
- изоляция модулей
- очистка перативной и вешней памяти и гарантированное удаление файлов
- маркировка документов 
- регистрация событий
- защита инф. в графической подсистеме
- ограничение действий пользователя
- защита адресного пространства процессов 
- контроль замкннутости программной среды и целостности
- средства организации единого пространства пользователей
- защищенная среда виртуализации
- защищённая среда виртуализации
- защищённая реляционная СУБД
- защищенные комплексы программ эл. почты и гипертекстовой обработки данных
- средства для работы с мультимедиа

## ROSA Linux

Разработчик "НТЦ ИТ Роса"
три программных продукта: "Роса Хром", " Роса Кобальт" и Enterprise Linux Server.
Роса Хром - для работы с данными, содерж гостайну и включает большое кол-во технологий управления контролем доступа, обеспечения защиты регистрации и учёта
Роса Кобальт - для работы с конфиденц. инф коммерческих компаний и содержит аналогичный набор технологий.
Серверный дистрибутив этой ОС предназначен для широкого круга пользователей и не содержит сертифицированных средств защиты.
Семейство ОС РОСА "Кобальт", сертифицировано фтэк России В КЛИЕНТСКОМ И СЕРВЕРНОМ вариантах, рекомендуется для использования коммерческими структурами, проммышленными предприятиями и органами гос. власти, работая с конф. инф.. Средства защиты инф. обеспечивают идентификацию и аутентификацию управления доступом, регистрацию событий безопасности, ограничения программной среды изоляцию процессов, защиту памяти контроль целостности  надёжного функционирования и фильтрацию сетевого потока. Особенности:
- поддержка средств рабочего стола MATE и GNOME
- поддержка ipa и active directory
- возможность запуска виндовс-приложений
- система печати CUPS
- совместимость с СУСВ "ROSA Virtualization"
- набор прикладных программ, доступных сразу после установки ОС
- WEB-браузер firefox
- почтовый клиент
- офисные пакеты libre
- система вёрстки
- файловые менеджеры
- медиаплееры
- torrent-клиент
- графические редакторы GIMP
- программы для сканирования
- программа для записи дисков
- клиент мгновенных сообщений
- наличие утили ЗИ собственной разработки
- средство расширенного управления атрибутами ROSA
- средство шифрования инф. ROSA Crypto Tool
- средство гарантированного удаления файлов

## ОС ROSA Enterprise Desktop

Список основных программных компонетов:
- ядро Linux c долгосрочной поддержкой
- последняя актуальная версия рабочего стола KDE 4 с собственными доработками и возможностями двухфакторной аутентификацией
- браузеры Firefox-ESR и Chromium
- почтовый клиент Thunderbird с интегр. календарём и планировщиком Lighting
- офисный пакет libreoffice
- актуальные версии свободных и проприетарных драйверов для различных видеокарт
- менджер фотографий
- программа просмотра изображений
- граф. редактор
- средства надёжного восстановления системы
- аудио и видеопроигрыватели
- средства взаимодействия с машинами

Основные особенности:
- совместимость с популярными свободными прил.
- гибкость при развёртывании
- доступность исходных кодов
- возможность выбора между ядром 3.10 и 4.9 для лучшей совместимости с оборудованием
- наличие в репозитории ядер Linux 5.x
- официальная поддержка техническими специалистами ООО "РОСА"

## Ред ОС
Разработчик компании Ред Софт
Дистрибутив для серверов и рабочих пк, сертиф ФСТЭК система на базе ядра Linux, ориентированная на импользование в госинф системах до 1-го класса защищённости включительно и спдн до 1-го уровня защищённости включительно. Ред ОС обеспечивает безопасность обрабатываемых данных, соотв отечественным требованиям по защите инф., имеет преднастроенные конфигурации для каждой аппаратной архитектуру, использует алгоритмы ГОСТ - 34.11-2012, а так же поддерживает списки управления доступом. Поддерживает сетевую аутентификацию с помощбю подключаемых модулей аутентификации и имеет в своём составе специализированную подсистему распределённого аудита, которая позволяет отслеживать критические события безопасности корпоративной сети и предоставляет сисадмину необходимые инструменты для оперативного реагирования на инцеденты инф безопасности.

Kaspersky OS

# Лекция 2

# Управление памятью
Сформировать систематизировать представление о концепциях и принципах построения и управления локальными ресурсами ОС.
Вопросы:
1. Типы адресов
2. Методы распределения памяти без 

Память является важнейшим ресурсом, требующим управления со стороны мультипрограммной ОС. Распределению подлежит вся оперативная память, не занятая ОС. Фуекциями ОС по управлению память явл.:
- Отслеживание свободной и занятой памяти
- Выеделние памяти процессам и освобождение памяти, при завершении процессов. Вытеснение процессов и оперативной памяти на диск, когда размеры основной памяти не достаточны для размещения в ней всех процессов
- А также настройка адресов программы на конкретную область физической памяти

## Типы адресов

Для идентификации переменных и команд используются символьные имена, виртуальные имена и физические.

Символьные имена присваивает пользователь при написании программы на алгоритмическом языке.

Виртуальные адреса вырабатывает транслятор, переводящий программу на машинный язык, так как во время трансляции неизвестно какое место оперативной памяти будет загружена программа, то транслятор присваивает переменным и командам условные адреса, начиная с нулевого адреса. Совокупность виртуальных адресов процесса называется виртуальным адресным пространством, каждый процесс имеет собственное виртуальное адресное пространство

![[Pasted image 20230314180455.png]]

## Переход от виртуальных адресов к физическим

Физические адреса соответствуют номерам ячеек оперативной памяти, где в действительности расположены или будут расположены переменные и команды. Переход от виртуальных адресов к физическим может осуществляться двумя способами:

1. В первом случае замену виртуальных адресов на физические делает специальная системная программа - перемещающий загрузчик. Перемещающий загрузчик на основании имеющихся у него исходных данных о начальном адресе физической памяти, в которую предстоит загружать программу, и информации, предоставленной транслятором об адресно-зависимых константах программы, выполняет загрузку программы, совмещая ее с заменой виртуальных адресов физическими.
2. Второй способ заключается в том, что программа загружается в память в неизмененном виде в виртуальных адресах, при этом операционная система фиксирует смещение действительного расположения программного кода относительно виртуального адресного пространства. Во время выполнения программы при каждом обращении к оперативной памяти выполняется преобразование виртуального адреса в физический. Второй способ является более гибким, он допускает перемещение программы во время ее выполнения, в то время как перемещающий загрузчик жестко привязывает программу к первоначально выделенному ей участку памяти. Вместе с тем использование перемещающего загрузчика уменьшает накладные расходы, так как преобразование каждого виртуального адреса происходит только один раз во время загрузки, а во втором случае - каждый раз при обращении по данному адресу.

## Методы распределния памяти:

Без использования внешней памяти:
- Фиксированными разделами
- Динамическими разделами
- Перемещаемыми разделами
С использованием внешней памяти:
- Страничное распрделение
- Сегметное распределение
- Сегментно-страничное распределение

## Распределение памяти фиксированными разделами

Самым простым способом управления оперативной памятью является разделение ее на несколько разделов фиксированной величины. Это может быть выполнено вручную оператором во время старта системы или во время ее генерации. Очередная задача, поступившая на выполнение, помещается либо в общую очередь (рисунок 2.9,а), либо в очередь к некоторому разделу (рисунок 2.9,б).

![[Pasted image 20230314181203.png]]
Распределение памяти фиксированными разделами:   
а - с общей очередью; б - с отдельными очередями

Подсистема управления памятью в этом случае выполняет следующие задачи:
- сравнивая размер программы, поступившей на выполнение, и свободных разделов, выбирает подходящий раздел,
- осуществляет загрузку программы и настройку адресов.

При очевидном преимуществе - простоте реализации - данный метод имеет существенный недостаток - жесткость. Так как в каждом разделе может выполняться только одна программа, то уровень мультипрограммирования заранее ограничен числом разделов не зависимо от того, какой размер имеют программы. Даже если программа имеет небольшой объем, она будет занимать весь раздел, что приводит к неэффективному использованию памяти. С другой стороны, даже если объем оперативной памяти машины позволяет выполнить некоторую программу, разбиение памяти на разделы не позволяет сделать этого.

## Распределение памяти разделами переменной величины

В этом случае память машины не делится заранее на разделы. Сначала вся память свободна. Каждой вновь поступающей задаче выделяется необходимая ей память. Если достаточный объем памяти отсутствует, то задача не принимается на выполнение и стоит в очереди. После завершения задачи память освобождается, и на это место может быть загружена другая задача. Таким образом, в произвольный момент времени оперативная память представляет собой случайную последовательность занятых и свободных участков (разделов) произвольного размера. На рисунке показано состояние памяти в различные моменты времени при использовании динамического распределения. Так в момент t0 в памяти находится только ОС, а к моменту t1 память разделена между 5 задачами, причем задача П4, завершаясь, покидает память. На освободившееся после задачи П4 место загружается задача П6, поступившая в момент t3.

## Распределение памяти динамическими разделами

![[Pasted image 20230314181437.png]]

В произвольный момент времени оперативная память представляет собой случайную последовательность занятых и своюодных участков произвольного размера. Программный код не перемещается во время выполнения то есть может быть проведена единовременная настройка адресов посредством использования перемещающего загрузчика.

### Задачами операционной системы при распределении памяти динамическими разделами:

1. Ведение таблиц свободных и занятых областей, в которых указываются начальные адреса и размеры участков памяти,
2. При поступлении новой задачи - анализ запроса, просмотр таблицы свободных областей и выбор раздела, размер которого достаточен для размещения поступившей задачи,
3. Загрузка задачи в выделенный ей раздел и корректировка таблиц свободных и занятых областей,
4. После завершения задачи корректировка таблиц свободных и занятых областей.

### Правила для выбора раздела памяти

Выбор раздела для вновь поступившей задачи может осуществляться по разным правилам, таким, например, как "первый попавшийся раздел достаточного размера", или "раздел, имеющий наименьший достаточный размер", или "раздел, имеющий наибольший достаточный размер". Все эти правила имеют свои преимущества и недостатки.

Достоинства гибкость метода; недостаток: фрагментация.
### Недостаток метода

По сравнению с методом распределения памяти фиксированными разделами данный метод обладает гораздо большей гибкостью, но ему присущ очень серьезный недостаток - фрагментация памяти. Фрагментация - это наличие большого числа несмежных участков свободной памяти очень маленького размера (фрагментов). Настолько маленького, что ни одна из вновь поступающих программ не может поместиться ни в одном из участков, хотя суммарный объем фрагментов может составить значительную величину, намного превышающую требуемый объем памяти.

## Перемещаемые разделы

Одним из методов борьбы с фрагментацией является перемещение всех занятых участков в сторону старших либо в сторону младших адресов, так, чтобы вся свободная память образовывала единую свободную область. 

![[8znyLbF_BwU.jpg]]

Дополняния к функциям, которые выполняетс ОС при распределение памяти переменными разделами, она ещё должна время от времени копировать содержимое разделов из одного места памяти в другое - это называется сжатием. Сжатие может выполняться либо при каждом завершении задачи, либо тогда когда вновь поступившие задачи нет свободного раздела

### Достоинство
более эффективное использование памяти.

### Недостаток метода
Хотя процедура сжатия и приводит к более эффективному использованию памяти, она может потребовать значительного времени, что часто перевешивает преимущества данного метода.

# Методы распределения памяти с использованием дискового пространства

## Оверлеи

Уже достаточно давно пользователи столкнулись с проблемой размещения в памяти программ, размер которых превышал имеющуюся в наличии свободную память. Решением было разбиение программы на части, называемые оверлеями. 0-ой оверлей начинал выполняться первым. Когда он заканчивал свое выполнение, он вызывал другой оверлей. Все оверлеи хранились на диске и перемещались между памятью и диском средствами операционной системы. Однако разбиение программы на части и планирование их загрузки в оперативную память должен был осуществлять программист.

## Виртуальная память

Развитие методов организации вычислительного процесса в этом направлении привело к появлению метода, известного под названием виртуальная память. Виртуальным называется ресурс, который пользователю или пользовательской программе представляется обладающим свойствами, которыми он в действительности не обладает. Так, например, пользователю может быть предоставлена виртуальная оперативная память, размер которой превосходит всю имеющуюся в системе реальную оперативную память. Пользователь пишет программы так, как будто в его распоряжении имеется однородная оперативная память большого объема, но в действительности все данные, используемые программой, хранятся на одном или нескольких разнородных запоминающих устройствах, обычно на дисках, и при необходимости частями отображаются в реальную память.

Таким образом, виртуальная память - это совокупность программно-аппаратных средств, позволяющих пользователям писать программы, размер которых превосходит имеющуюся оперативную память; для этого виртуальная память решает следующие задачи:

- размещает данные в запоминающих устройствах разного типа, например, часть программы в оперативной памяти, а часть на диске;
- перемещает по мере необходимости данные между запоминающими устройствами разного типа, например, подгружает нужную часть программы с диска в оперативную память;
- преобразует виртуальные адреса в физические.

Все эти действия выполняются автоматически, без участия программиста, то есть механизм виртуальной памяти является прозрачным по отношению к пользователю.
Наиболее распространенными реализациями виртуальной памяти является страничное, сегментное и странично-сегментное распределение памяти, а также свопинг.

## Страничное распределение
Виртуальное адресное пространство каждого процесса делится на части одинакового, фиксированного для данной системы размера, называемые _виртуальными страницами._ В общем случае размер виртуального адресного пространства не является кратным размеру страницы, поэтому последняя страница каждого процесса дополняется фиктивной областью.

Вся оперативная память машины также делится на части такого же размера, называемые _физическими страницами_ (или блоками).

При загрузке процесса часть его виртуальных страниц помещается в оперативную память, а остальные – на диск. Смежные виртуальные страницы не обязательно располагаются в смежных физических страницах. При загрузке ОС создает для каждого процесса _информационную структуру_ – таблицу страниц, в которой устанавливается соответствие между номерами виртуальных и физических страниц для страниц, загруженных в оперативную память, или делается отметка о том, что виртуальная страница выгружена на диск. Кроме того, в таблице страниц содержится управляющая информация, такая как признак модификации страницы, признак невыгружаемости (выгрузка некоторых страниц может быть запрещена), признак обращения к странице (используется для подсчета числа обращений за определенный период времени) и другие данные, формируемые и используемые механизмом виртуальной памяти.

При каждом обращении к памяти происходит чтение из таблицы страниц информации о виртуальной странице, к которой произошло обращение. Если данная виртуальная страница находится в оперативной памяти, то выполняется преобразование виртуального адреса в физический. Если же нужная виртуальная страница в данный момент выгружена на диск, то происходит так называемое _страничное прерывание._

_Механизм преобразования виртуального адреса в физический  
__при страничной организации памяти_:
![[img00018.gif]]

Виртуальный адрес при страничном распределении может быть представлен в виде пары (p, s), где p - номер виртуальной страницы процесса (нумерация страниц начинается с 0), а s - смещение в пределах виртуальной страницы. Учитывая, что размер страницы равен 2 в степени к, смещение s может быть получено простым отделением k младших разрядов в двоичной записи виртуального адреса. Оставшиеся старшие разряды представляют собой двоичную запись номера страницы p.

Достоинства: отсутствие фрагментации.

_Недостатком_ данного метода распределения памяти является фрагментация на уровне сегментов и более медленное по сравнению со страничной организацией преобразование адреса.

## Сегментное распределение

При страничной организации виртуальное адресное пространство процесса делится на равные части _механически,_ без учета смыслового значения данных. В одной странице могут оказаться и коды команд, и инициализируемые переменные, и массив исходных данных программы. Такой подход не позволяет обеспечить дифференцированный доступ к разным частям программы, а это свойство могло бы быть очень полезным во многих случаях. Например, можно было бы запретить обращаться с операциями записи в сегмент программы, содержащий коды команд, разрешив эту операцию для сегментов данных.

Итак, виртуальное адресное пространство процесса делится на части - _сегменты,_ размер которых определяется с учетом смыслового значения содержащейся в них информации. Отдельный сегмент может представлять собой подпрограмму, массив данных и т. п. Деление виртуального адресного пространства на сегменты осуществляется компилятором на основе указаний программиста или по умолчанию, в соответствии с принятыми в системе соглашениями. Максимальный размер сегмента определяется разрядностью виртуального адреса, напри- мер, при 32-разрядной организации процессора он равен 4 Гбайт. При этом максимально возможное виртуальное адресное пространство процесса представляет собой набор изNвиртуальных сегментов, каждый размером по 4 Гбайт. В каждом сегменте виртуальные адреса находятся в диапазоне от 0000000016доFFFFFFFF16. Сегменты не упорядочиваются друг относительно друга, так что общего для сегментов линейного виртуального адреса не существует, виртуальный адрес задается парой чисел: номером сегмента и линейным виртуальным адресом внутри сегмента (называемым также смещением).

![[img-qVO0GN.png]]


На этапе создания процесса во время загрузки его образа в оперативную память система создает_таблицу сегментов_ процесса (аналогичную таблице страниц), в которой для каждого сегмента указывается:

![[49.png]]

-   базовый физический адрес сегмента в оперативной памяти;
    
-   размер сегмента;
    
-   правила доступа к сегменту;
    
-   признаки модификации, присутствия и обращения к данному сегменту, а также некоторая другая информация.

Недостаток сегментного распределения - это фрагментация, которая возникает из-за непредсказуемости размеров сегментов. В процессе работы системы в памяти образуются небольшие участки свободной памяти, в которые не может быть загружен ни один сегмент. Суммарный объем, занимаемый фрагментами, может составить существенную часть общей памяти системы, приводя к ее неэффективному использованию.

## Сегментно-страничная организация памяти

Виртуальное пр-во процесса делится на сегменты, а каждый сегмент в свою очередь делится на виртуальные страницы, которые нумеруются в предеах сегмента. ОП делится на физ страницы. Загрузка процесса выполняется ОС постранично, при это часть страниц размещается в ОП, а часть на диске. Для каждого сегмента создаётся своя таблица страниц. Для каждого процесса создаётся таблица сегментов, в которой указываеются адреса таблиц страниц для всех сегментов данного процесса. Адрес таблицы сегментов загружается в спец. регистр процессора, когда активизируется соотв. процесс.

В большинстве современных реализаций сегментно-страничной организации памяти в отличие от набора виртуальных диапазонов адресо при сегментной орг. памяти все вирт сегменты образуют 1 непрерывное линейное виртуальное адресное пр-во.

## Разновидностью виртуальной памяти является свопинг.

При свопинге, в отличие от рассмотренных ранее методов реализации виртуальной памяти, процесс перемещается между памятью и диском целиком, то есть в течение некоторого времени процесс может полностью отсутствовать в оперативной памяти. Существуют различные алгоритмы выбора процессов на загрузку и выгрузку, а также различные способы выделения оперативной и дисковой памяти загружаемому процессу.

## Иерархия запоминающих устройств. Принцип кэширования данных

Память вычислительной машины представляет собой иерархию запоминающих устройств (внутренние регистры процессора, различные типы сверхоперативной и оперативной памяти, диски, ленты), отличающихся средним временем доступа и стоимостью хранения данных в расчете на один бит (рисунок 2.17). Пользователю хотелось бы иметь и недорогую и быструю память. Кэш-память представляет некоторое компромиссное решение этой проблемы.

### Иерархия ЗУ

![[Pasted image 20230328182605.png]]

## Кэш-память

Кэш-память - это способ организации совместного функционирования двух типов запоминающих устройств, отличающихся временем доступа и стоимостью хранения данных, который позволяет уменьшить среднее время доступа к данным за счет динамического копирования в "быстрое" ЗУ наиболее часто используемой информации из "медленного" ЗУ.

Кэш-памятью часто называют не только способ организации работы двух типов запоминающих устройств, но и одно из устройств - "быстрое" ЗУ. Оно стоит дороже и, как правило, имеет сравнительно небольшой объем. Важно, что механизм кэш-памяти является прозрачным для пользователя, который не должен сообщать никакой информации об интенсивности использования данных и не должен никак участвовать в перемещении данных из ЗУ одного типа в ЗУ другого типа, все это делается автоматически системными средствами.

## Кэширование данных

_Кэш-память,_ или просто_кэш –_ это способ совместного функционирования двух типов запоминающих устройств, отличающихся временем доступа и стоимостью хранения данных, который за счет динамического копирования в «быстрое» ЗУ наиболее часто используемой информации из «медленного» ЗУ позволяет, с одной стороны, уменьшить среднее время доступа к данным, а с другой стороны, экономить более дорогую быстродействующую память.

Неотъемлемым свойством кэш-памяти является ее прозрачность для программ и пользователей. Система не требует никакой внешней информации об интенсивности использования данных; ни пользователи, ни программы не принимают никакого участия в перемещении данных из ЗУ одного типа в ЗУ другого типа, все это делается автоматически системными средствами.

![[f1-FHOBSKh4.jpg]]

![[Pasted image 20230425180309.png]]

В системах, оснащенных кэш-памятью, каждый запрос к оперативной памяти выполняется в  
соответствии со следующим алгоритмом:  
1. Просматривается содержимое кэш-памяти с целью определения, не находятся ли  нужные данные в кэш-памяти; кэш-память не является адресуемой, поэтому поиск нужных данных осуществляется по содержимому - значению поля "адрес в  оперативной памяти", взятому из запроса.  
2. Если данные обнаруживаются в кэш-памяти, то они считываются из нее, и результат передается в процессор.  
3. Если нужных данных нет, то они вместе со своим адресом копируются из оперативной памяти в кэш-память, и результат выполнения запроса передается в процессор. При копировании данных может оказаться, что в кэш-памяти нет свободного места, тогда выбираются данные, к которым в последний период было меньше всего обращений,  для вытеснения из кэш-памяти. Если вытесняемые данные были модифицированы за время нахождения в кэш-памяти, то они переписываются в оперативную память. Если  же эти данные не были модифицированы, то их место в кэш-памяти объявляется свободным.

На практике в кэш-память считывается не один элемент данных, к которому произошло обращение, а целый блок данных, это увеличивает вероятность так называемого "попадания в кэш", то есть нахождения нужных данных в кэш-памяти.  
Покажем, как среднее время доступа к данным зависит от вероятности попадания в кэш. Пусть имеется основное запоминающие устройство со средним временем доступа к данным t1 и кэш-память, имеющая время доступа t2, очевидно, что t2<t1. Обозначим через t среднее время доступа к данным в системе с кэш-памятью, а через p -вероятность попадания в кэш. По формуле полной вероятности имеем:
`t = t1((1 - p) + t2(p)`

Из нее видно, что среднее время доступа к данным в системе с кэш-памятью линейно зависит от вероятности попадания в кэш и изменяется от среднего времени доступа в основное ЗУ (при р=0) до среднего времени доступа непосредственно в кэш-память (при р=1).

## Понятие пространственной и временной локальности    

В реальных системах вероятность попадания в кэш составляет примерно 0,9. Высокое значение вероятности нахождения данных в кэш-памяти связано с наличием у данных объективных свойств: пространственной и временной локальности.

-   Пространственная локальность. Если произошло обращение по некоторому адресу, то с высокой степенью вероятности в ближайшее время произойдет обращение к соседним адресам.
    
-   Временная локальность. Если произошло обращение по некоторому адресу, то следующее обращение по этому же адресу с большой вероятностью произойдет в ближайшее время.

