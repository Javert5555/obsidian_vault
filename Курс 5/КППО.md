Кросс-платформенное ПО - это по, которое работает более чем на одной аппаратной платформе или ОС. Типичным примером для определения КП являются различные пакеты, функционирующие на различных ОС: VScode, LibreOffice, Eclipse

КП - это программы, написанные на языках высокого уровня, C++, C, Java и т.д.

90% андроид в России
70% андроид в мире

JVM -Java Virtual Machine

так как КП-зыки при компиляции очень сложны, то часто пользуются интерпретаторами, которые можно запускать на виртуальных машинах.

КП - интерпретаторы - это ActionScript, Perl, Python, PHP

Нативные приложения

Преимущества нативных приложений;
Высокая скорость работы, быстрота отклика интерфейса, 

углублённая работа с функциями смартфона
Недостатко нативной разработки - дороговизна разработки и поддержки, для каждой платформы нужно писать свой код

КП-приложения
Достоинства:
Совместимость различных платформ.
КП пишутся на 1 языке, отличном от нативного.

Преимущества КП - увеличение количества пользователей
Маркетинг становится проще, так как не нужно таргетировать рекламу на узкие сегменты
Повышение эффективности ресурсов устройства

недостатки: не родной  интерфейс
Проблемы в реализации сложных функций
Трудность работы с разными форматами
Низкая скорость работы

## ЖЦКППО - Жизненный цикл КППО
1) Зарождение проекта
2) Проектирования/макетирование приложения: рабочий поток application flow, wireframe/ (проволочный каркас), прототип, mocap
3) Этап разработки и стабилизации: прототип, создание альфа-версии программы, бета-версия, релиз.
4) Развёртывание и распространение.
5) Сопровождение: консультации, инструкции, обучение, обновление




тест:

81) кроссплатформенных языков программирования; кроссплатформенного интерфейса пользователя; специальных кроссплатформенных сред программирования; адаптации программного кода для его запуска на различных платформах; адаптацией дизайна и следованием общим стандартам оформления интерфейса пользователя, и др.

82) А) Увеличение количества пользователей. Чем с большим числом платформ работает программное приложение, тем больше пользователей смогут установить его на свои устройства. Рынки iOS и Android конкурируют между собой за пользователей, а кросс- платформенность приложения позволяет получить пользователей обоих рынков. Б) Упрощается маркетинг. При большой аудитории пользователей нет необходимости нацеливать маркетинг на узкие сегменты покупателей – можно обращаться ко всем сразу. Проблема выбора средств связи с пользователем становится менее насущной – для аудитории можно выбирать любые средства распространения информации. В) Повышение эффективности ресурсов. Современные программные средства позволяют разрабатывать одно приложение, которое будет доступно для нескольких платформ сразу. При тех же трудозатратах увеличивается и аудитория, и денежные потоки.

83) А) Неродной интерфейс, и необходимость работы с интерфейсом каждой платформы отдельно. У каждой операционной системы есть свои требования к дизайну элементов, и иногда они являются взаимоисключающими, что необходимо учитывать при разработке. Б) Проблемы в реализации сложных функций, возможные сбои при работе даже с простыми процедурами из-за ошибок фреймворков разработки. Кроссплатформенная среда транслирует запросы к системным вызовам и интерфейсам, в распознаваемый конкретной операционной системой формат, и потому на этом этапе возникают сложности с пониманием и возникновение ошибок внутри самого фреймворка. В) Скорость работы. Так как кроссплатформенная среда является «надстройкой» над программным кодом (не всегда, но в определённых ситуациях), то в ней возникают задержки и паузы в отработке действий пользователя и выводе на экран результатов.

84) для другого компьютера, учитывая особенности его целевой платформы – микропроцессора и операционной системы. На этапе кросскомпиляции выполняется дополнительная оптимизация промежуточного и конечного исполняемого кода с учетом архитектурных особенностей целевой платформы. Это заключается в расширенном использовании систем команд и дополнительных аппаратных блоков инструкций микропроцессора. Существует также программное обеспечение, выполняющее действия, обратные кросскомпиляции – переводят программный код из низкоуровневого представления в высокоуровневое, восстанавливая исходный код из байт-кода или кода языка Ассемблера.

85) эмулирующая аппаратное обеспечение другой платформы (целевой, или хост-платформы). Виртуализация подразумевает создание особой среды, изолирующей друг от друга программы и операционные системы. Такой инструмент называют песочницей. Виртуальная машина исполняет машинно–независимый код или машинный код реального процессора. Помимо процессора, виртуальная машина может эмулировать как работу отдельных компонентов аппаратного обеспечения, так и целого реального компьютера (включая BIOS, оперативную память, жёсткий диск и другие периферийные устройства). На виртуальную машину, как и на реальный компьютер, можно устанавливать операционные системы (например, Windows можно запускать в виртуальной машине под Linux, или наоборот). Большинство оболочек виртуальных машин типа Virtual Box позволяет подключать к виртуальной операционной системе реальное оборудование, что даёт возможность, например, протестировать работу с периферийным устройством из-под ОС Windows, установленной в виртуальном контейнере, на виртуальной хост-машине для ОС Linux.




## Цель исследования

Цель работы заключается в разработке метода повышения полноты обнаружения серверных точек взаимодействия (Data Entry Points, DEP) в динамических веб-приложениях при анализе их защищённости в модели «чёрного ящика». Для этого предлагается использовать статический анализ клиентского JavaScript-кода с целью поиска функций, генерирующих HTTP-запросы к серверу, и определения возможных значений их параметров1.

## Научная новизна

Новизна работы состоит в следующем:

- Предложен метод, который использует статический анализ JavaScript-кода для поиска DEP, что позволяет выявлять серверные интерфейсы, скрытые для традиционного динамического анализа (например, недостижимые или «мёртвые» участки кода).
    
- В отличие от существующих подходов, основанных преимущественно на динамическом краулинге (обходе) приложения, статический анализ позволяет обнаруживать функции, которые не вызываются в процессе обычного взаимодействия с интерфейсом, включая скрытые и пользовательские функции1.
    
- Проведено экспериментальное сравнение предложенного метода с популярными сканерами защищённости веб-приложений, что позволяет объективно оценить его преимущества.
    

## Полученные результаты

В результате исследования:

- Разработан и реализован алгоритм статического анализа клиентского JavaScript-кода для поиска функций, порождающих HTTP-запросы к серверу, и определения возможных значений их параметров.
    
- Экспериментально показано, что использование статического анализа JavaScript-кода в дополнение к традиционному динамическому краулингу значительно повышает полноту выявления серверных точек взаимодействия в веб-приложениях.
    
- На синтетическом веб-приложении, уязвимом к SQL-инъекции, предложенный метод позволил обнаружить больше DEP по сравнению с существующими сканерами, в том числе скрытые и пользовательские функции, которые не были найдены динамическими инструментами1.
    

**Вывод:** Дополнение динамического анализа статическим анализом клиентского JavaScript-кода существенно увеличивает покрытие серверных точек взаимодействия и, как следствие, эффективность поиска уязвимостей в современных динамических веб-приложениях1.

### Citations:

1. [https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/7146306/8ac3444e-f919-40a8-90ef-7b190dcf06ea/obnaruzhenie-servernyh-tochek-vzaimodeystviya-v-veb-prilozheniyah-na-osnove-analiza-klientskogo-javascript-koda.pdf](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/7146306/8ac3444e-f919-40a8-90ef-7b190dcf06ea/obnaruzhenie-servernyh-tochek-vzaimodeystviya-v-veb-prilozheniyah-na-osnove-analiza-klientskogo-javascript-koda.pdf)
2. [https://github.com/seclab-msu/js-dep-mining-test-app](https://github.com/seclab-msu/js-dep-mining-test-app)
3. [https://arxiv.org/pdf/2001.00001.pdf](https://arxiv.org/pdf/2001.00001.pdf)

---

Answer from Perplexity: pplx.ai/share