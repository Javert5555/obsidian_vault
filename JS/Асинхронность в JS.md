# Асинхронность в JS
https://doka.guide/js/async-in-js/
https://learn.javascript.ru/event-loop#makrozadachi-i-mikrozadachi
https://learn.javascript.ru/microtask-queue
https://habr.com/ru/company/hexlet/blog/656003/

Чтобы выполнить код, нам нужен _JavaScript Engine (движок)_ — программа, которая «читает и выполняет» то, что мы написали. Самый распространённый движок среди всех — это V8, он используется в Google Chrome и Node.js.

Выполнение JS-кода — однопоточное. Это значит, что в конкретный момент времени движок может выполнять _не более одной_ строки кода. То есть вторая строка не будет выполнена, пока не выполнится первая.

Такое выполнение кода (строка за строкой) называется синхронным.

Операции, которые не дают выполнять ничего кроме них самих, пока они не завершатся, называются _**блокирующими выполнение**_.

Асинхронные операции, такие как промисы, **помещаются в очередь событий, которая запускается после завершения обработки основного потока, чтобы они не блокировали выполнение JavaScript-кода**. Поставленные в очередь операции завершатся как можно скорее, а затем вернут свои результаты в среду JavaScript.

## Стек вызовов 
При вызове какой-то функции она попадает в так называемый **стек вызовов (call stack)**.

**Стек** — это структура данных, в которой элементы упорядочены так, что последний элемент, который попадает в стек, выходит из него первым _(LIFO: last in, first out)._ Стек похож на стопку книг: та книга, которую мы кладём последней, находится сверху.

В стеке вызовов хранятся функции, до которых дошёл интерпретатор, и которые надо выполнить.

После выполнения всего блока стек станет пустым.

В синхронном коде в стеке хранится вся цепочка вызовов. Поэтому, например, рекурсия без базового случая может приводить к переполнению стека — в нём скапливается слишком большое количество вызовов.

После выполнения всего блока стек снова становится пустым.

## Цикл событий (Event loop)

Важно:
_____________________________
***Главная задача циклов событий — следить за стеком и очередью задач (task queue). Если стек пуст, цикл берет первый элемент из очереди, помещает его в стек и выполняет.***
_________

Возьмём, к примеру, функцию `setTimeout()`, она не является частью JavaScript-движка, это по сути _Web API,_ включённое в среду браузера как дополнительная функциональность.

Эта дополнительная функциональность (Web API) берёт на себя работу с таймерами, интервалами, обработчиками событий. То есть когда мы регистрируем обработчик клика на кнопку — он попадает в окружение Web API. Именно оно знает, когда обработчик нужно вызвать.

Web API использует очередь **задач** для хранения того, что нужно выполнить.

Управление тем, как должны вызываться функции Web API, берёт на себя _**цикл событий**_ (Event loop).

**Цикл событий** отвечает за выполнение кода, сбор и обработку событий и выполнение подзадач из очереди.

**Стек вызовов** и **очередь задач** называются именно стеком и очередью. Потому что вызовы из стека работают по принципу _«последний зашёл, первый вышел»_ (LIFO: last in, first out), а в очереди — по принципу _«первый зашёл, первый вышел»_ (FIFO: first in, first out).

**Очередь** — структура данных, в которой элементы упорядочены так, что первый попавший в очередь элемент покидает её первым.

Таким образом цикл событий работает с асинхронным кодом — то есть таким, который выполняется не построчно.

Очень хорошо работу цикла событий иллюстрирует [инструмент Loupe](http://latentflip.com/loupe/)
## Колбэки
**Callback** (колбэк, функция обратного вызова) — функция, которая вызывается в ответ на совершение некоторого события.

В целом, событием может быть что угодно:
-   ответ от сервера;
-   завершение какой-то длительной вычислительной задачи;
-   получение доступа к каким-то API устройства, на котором выполняется код.

Таким образом _**колбэк**_ — это первый способ обработать какое-либо асинхронное действие.

Изначально колбэки были единственным способом работать с асинхронным кодом в JavaScript. Большая часть асинхронного API Node.js была написана именно на колбэках и создана для использования с колбэками.

Это, в принципе, логично — ментальная модель достаточно простая: _«выполни эту функцию, когда случится это событие»_.

Однако у колбэков есть неприятный минус, так называемый _ад колбэков_ (callback hell).

Допустим, у нас есть ряд асинхронных задач, которые зависят друг от друга: то есть первая задача запускает по завершении вторую, вторая — третью и т. д.

```js
function request(url, onSuccess) {
  /*...*/
}

request('/api/users/1', function (user) {
  request(`/api/photos/${user.id}/`, function (photo) {
    request(`/api/crop/${photo.id}/`, function (response) {
      console.log(response)
    })
  })
})
```

Читать такое сложно, не говоря уже о тестировании, которое здесь становится очень накладным.

## Промисы (Promise) (Важная часть)
**Промис** — это объект-обёртка для асинхронного кода. Он содержит в себе состояние: вначале `pending` («ожидание»), затем — одно из: `fulfilled` («выполнено успешно») или `rejected` («выполнено с ошибкой»). Промисы придумали, чтобы организовывать асинхронный код последовательно.

В понятиях цикла событий промис работает так же, как колбэк: функция, которая должна выполниться (`resolve` или `reject`), находится в окружении Web API, а при наступлении события — попадает в очередь задач, откуда потом — в стек вызова.

## Макрозадачи и Микрозадачи

В асинхронных задачах есть разделение между макрозадачами и микрозадачами. Колбэки в промисах попадают в очередь **микрозадач**, тогда как колбэк в `setTimeout()` (все колбэки из функций, предоставляемы Web API) — в очередь **макрозадач**.

**Сразу после каждой _макрозадачи_ движок исполняет все задачи из очереди _микрозадач_ перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.**

**Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче.**

Сам скрипт `script` является макрозадачей.

Например:

```js
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");
```

Здесь будет следующий порядок исполнения кода:

1.  `"code"` появляется первым, т.к. это обычный синхронный вызов.
2.  `"promise"` появляется вторым, потому что `.then` проходит через очередь микрозадач и выполняется после текущего синхронного кода.
3.  `"timeout"` появляется последним, потому что это макрозадача.

Промисы оказались удобными, и появился даже такой термин как «промисификация» — когда асинхронную функциональность на колбэках превращали в промисы.
Однако промисы — это тоже не серебряная пуля. У них есть несколько недостатков:

-   Код не такой лаконичный, как мог быть.
-   В цепочке промисов, как на примере (со стрелочными функциями), невозможно выставить брейкпоинт, потому что нет тела функции. Приходится раскрывать функцию.
-   Стек ошибок может содержать в себе `then.then.then.then...`.
-   Вложенные условия сильно увеличивают количество кода и ухудшают читаемость.

Для решения этих проблем придумали асинхронные функции.

## Асинхронные функции
Если коротко, **асинхронные функции** — функции, которые возвращают промисы.

Асинхронная функция помечается специальным ключевым словом `async`:
```js
async function request() {}

const req = async () => {}

class SomeClass {
	async request() {}
}
```

Они _всегда_ возвращают Промис. Даже если мы явно этого не указывали, как в примерах выше, при вызове они всё равно вернут промис.

Внутри асинхронных функций можно вызывать другие асинхронные функции, без каких-либо `then()` или колбэков, с помощью ключевого слова `await`.

```js
async function loadPosts() {
	const response = await fetch('/api/posts/')
	const data = await response.json()
	return data
}
```

Все асинхронные функции внутри мы вызываем с `await` — таким образом промис, который функция возвращает, автоматически разворачивается, и мы получаем значение, которое внутри промиса было. **Мы можем обрабатывать ошибки с `try-catch`.** Как и с синхронным кодом, обработка ошибок сводится к оборачиванию опасных операций в `try-catch`:

```js
async function loadPosts() {
	try {
		const response = await fetch('/api/posts/')
		const data = await response.json()
		return data
	} catch (e) {
		console.log(e)
	}
}
```

try-catch поймает не только ошибки, которые были внутри асинхронных функций, но также и ошибки, которые возникли во время обычных синхронных операций.

**Можно ставить брейкпоинты (точки останова).** Для отладки мы можем поставить брейкпоинт куда угодно, он сработает.



# Что такое ассинхронность в JS?

