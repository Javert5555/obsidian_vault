
### **Подробный разбор Шага 7: Встраивание сообщения в контейнер (модуль M.6)**

На этом шаге происходит **замена наименее значащих битов (LSB)** пикселей изображения на биты секретного сообщения. Рассмотрим модуль **M.6** из методички пошагово.

---

## **1. Исходные данные**
- **`sMe`** — вектор, содержащий:
  - Начальную метку (`m_start`).
  - Закодированное сообщение (`M_cod`).
  - Конечную метку (`m_end`).
- **`Cv`** — одномерный вектор, полученный на Шаге 6, содержащий все пиксели изображения в порядке **B-G-R** (синий, зелёный, красный).  
  - Каждый элемент `Cv` — это **число от 0 до 255** (интенсивность цвета в одном канале пикселя).  
  - Длина `Cv`: `3 × 128 × 166 = 63 744` элемента (для изображения `128×166` пикселей, 3 канала на пиксель).

---

## **2. Алгоритм встраивания (модуль M.6)**
```mathcad
Sv := 
  for m ∈ 0..rows(sMe) – 1
    b ← D2B(sMeₘ)               // (1) Переводим символ сообщения в 8 бит
    for i ∈ 0..7
      P ← D2B(Cvᵢ₊₈·ₘ)          // (2) Берём i-й пиксель, переводим в биты
      P₀ ← bᵢ                    // (3) Заменяем LSB (P₀) на бит сообщения
      Svᵢ₊₈·ₘ ← B2D(P)           // (4) Возвращаем число в десятичный вид
  for j ∈ rows(Sv)..rows(Cv) – 1 // (5) Заполняем оставшиеся пиксели
    P ← D2B(Cvⱼ)
    P₀ ← round(rnd(1))           // (6) Случайный бит (0 или 1)
    Svⱼ ← B2D(P)
  Sv
```

### **Пошаговая работа цикла:**
### **1. Обработка каждого символа сообщения (`sMe`)**
- Для каждого символа `sMeₘ` (всего `rows(sMe) = 1157` символов):
  1. **`b ← D2B(sMeₘ)`**  
     - Символ (например, `'A' = 65`) преобразуется в **8 бит** (`01000001`).
  2. **Для каждого бита `bᵢ` (i = 0..7):**  
     - Берётся **8 пикселей** из `Cv` (по одному на бит).
     - **`P ← D2B(Cvᵢ₊₈·ₘ)`**  
       - Пиксель (например, `Cv₅ = 120`) переводится в **8 бит** (`01111000`).
     - **`P₀ ← bᵢ`**  
       - Меняется **младший бит (P₀)** на `bᵢ` (например, `0 → 1`).
     - **`Svᵢ₊₈·ₘ ← B2D(P)`**  
       - Новое значение пикселя записывается в `Sv` (теперь `01111001 = 121`).

### **2. Заполнение оставшихся пикселей (маскировка)**
- После встраивания сообщения остаются **незатронутые пиксели** (их LSB могут выдать факт скрытия данных).  
- Чтобы это скрыть:
  - **`P₀ ← round(rnd(1))`**  
    - LSB оставшихся пикселей заменяется на **случайные 0 или 1**.  
    - Это делает статистику LSB равномерной, усложняя стеганоанализ.

---

## **3. Пример работы (числовой)**
**Дано:**
- Сообщение: `'A'` (ASCII `65` = `01000001`).
- Пиксели `Cv`: `[120, 45, 200, 33, 90, 17, 255, 180, ...]`.

**Шаги:**
1. `'A' → 65 → 01000001` (8 бит).
2. Для каждого бита:
   - **Бит 0 (`0`):**  
     - Берём `Cv₀ = 120` (`01111000`).  
     - Заменяем LSB: `0111100**0** → 0111100**0**` (остаётся `120`).  
   - **Бит 1 (`1`):**  
     - Берём `Cv₁ = 45` (`00101101`).  
     - Заменяем LSB: `0010110**1** → 0010110**1**` (остаётся `45`).  
   - **...**
   - **Бит 7 (`0`):**  
     - Берём `Cv₇ = 180` (`10110100`).  
     - Заменяем LSB: `1011010**0** → 1011010**0**` (остаётся `180`).  
3. Результат:  
   - `Sv = [120, 45, 200, 33, 90, 17, 255, 180, ...]` (первые 8 пикселей почти не изменились, так как LSB совпали с битами `'A'`).  

---

## **4. Важные замечания**
### **Почему заменяется именно LSB (P₀)?**
- **LSB (бит 0)** — наименее значимый, его изменение почти не влияет на цвет пикселя.  
- Например:
  - `120` (`01111000`) → `121` (`01111001`) — визуально неотличимо.  
  - `255` (`11111111`) → `254` (`11111110`) — почти незаметно.

### **Что происходит с оставшимися пикселями?**
- Если сообщение короткое, а контейнер большой (например, `1157 × 8 = 9256` бит из `63 744`), то:
  - Остальные пиксели (`63 744 - 9256 = 54 488`) заполняются **случайными LSB**, чтобы скрыть границу сообщения.

### **Как повышается скрытность?**
1. **Порядок B-G-R** (вместо R-G-B) усложняет анализ.  
2. **Случайные LSB** в хвосте делают статистику равномерной.  
3. **Метки (`m_start`, `m_end`)** помогают извлечь сообщение, но не видны без знания ключа.

---

## **5. Вывод**
**Шаг 7 — ключевой этап LSB-стеганографии**, где:
1. Каждый бит сообщения встраивается в LSB пикселей.  
2. Остальные пиксели маскируются случайными битами.  
3. Результат (`Sv`) — это модифицированный вектор, который позже преобразуется обратно в изображение (`mushu1.bmp`).  

**Итог:** Изображение выглядит почти так же, но содержит скрытое сообщение.







### **Разбор коэффициента `i + 8·m` в модуле M.6**

В формуле **`Svᵢ₊₈·ₘ ← B2D(P)`** из шага 7 используется индекс `i + 8·m`. Давайте разберём, почему он имеет именно такой вид и как работает.

---

## **1. Общий смысл выражения**
Этот индекс определяет, **в какой именно пиксель изображения записывается очередной бит сообщения**.  
- **`i`** — номер бита в текущем символе (от 0 до 7).  
- **`m`** — номер символа в сообщении (от 0 до `rows(sMe)-1`).  
- **`8·m`** — сдвиг, чтобы перейти к следующей группе из 8 пикселей (по одному на бит символа).  

Таким образом, **`i + 8·m`** — это линейный адрес пикселя в векторе `Cv`, куда записывается `i`-й бит `m`-го символа.

---

## **2. Почему именно `8·m`?**
### **Принцип "1 символ = 8 пикселей"**
Каждый символ сообщения кодируется **8 битами** (например, `'A' = 01000001`).  
Поскольку **1 бит сообщения встраивается в 1 пиксель**, то для одного символа нужно **8 пикселей**.  

- **Первые 8 бит (символ `m=0`)** записываются в пиксели:  
  `Cv₀, Cv₁, Cv₂, ..., Cv₇` (индексы `i + 8·0 = 0,1,2,...,7`).  
- **Следующие 8 бит (символ `m=1`)** — в:  
  `Cv₈, Cv₉, Cv₁₀, ..., Cv₁₅` (индексы `i + 8·1 = 8,9,...,15`).  
- **И так далее...**

### **Пример для первых двух символов**
Допустим, сообщение начинается с `"AB"`:
- `'A'` = `65` = `01000001` → биты `[0,1,0,0,0,0,0,1]`.  
- `'B'` = `66` = `01000010` → биты `[0,1,0,0,0,0,1,0]`.  

**Пиксели, куда встраиваются биты:**
| Символ (`m`) | Бит (`i`) | Индекс в `Cv` (`i + 8·m`) | Бит сообщения |
|-------------|----------|--------------------------|---------------|
| 0 (`'A'`)   | 0        | 0 + 8·0 = **0**           | `0` (LSB `Cv₀`) |
|             | 1        | 1 + 8·0 = **1**           | `1` (LSB `Cv₁`) |
|             | ...      | ...                       | ...           |
|             | 7        | 7 + 8·0 = **7**           | `1` (LSB `Cv₇`) |
| 1 (`'B'`)   | 0        | 0 + 8·1 = **8**           | `0` (LSB `Cv₈`) |
|             | 1        | 1 + 8·1 = **9**           | `1` (LSB `Cv₉`) |
|             | ...      | ...                       | ...           |

---

## **3. Почему нельзя просто использовать `i + m`?**
Если бы индекс был `i + m`, то:
- Для `m=0`: биты `'A'` записались бы в `Cv₀, Cv₁, ..., Cv₇`.  
- Для `m=1`: биты `'B'` попали бы в `Cv₁, Cv₂, ..., Cv₈`.  

**Проблема:**  
- Бит `'B'` (индекс `i=0`, `m=1`) перезаписал бы `Cv₁`, куда уже был записан бит `'A'` (индекс `i=1`, `m=0`).  
- **Перекрытие данных** привело бы к потере информации.

**Решение:**  
- **`8·m`** гарантирует, что каждый новый символ начинается с **следующего свободного пикселя** через каждые 8 позиций.  

---

## **4. Проверка границ массива**
- Длина сообщения: `rows(sMe) = 1157` символов → требуется `1157 × 8 = 9256` пикселей.  
- Длина `Cv`: `128 × 166 × 3 = 63 744` пикселей.  
- **Условие выполняется:** `9256 < 63 744` — контейнер достаточно велик.

Если бы сообщение было длиннее, чем `63 744 / 8 = 7968` символов, программа выдала бы ошибку (выход за границы массива).

---

## **5. Альтернативные варианты размещения**
Для повышения скрытности иногда используют **нелинейное распределение** битов:
1. **Чередование битов по каналам**:  
   - Например, первый бит в `R`, второй в `G`, третий в `B`, и т.д.  
2. **Псевдослучайная перестановка**:  
   - Биты записываются не подряд, а в порядке, заданном криптографическим ключом.  
3. **Пропуск пикселей**:  
   - Встраивание битов через каждые `N` пикселей (например, в каждый 3-й).  

Но в данной работе выбран **простейший линейный вариант** для наглядности.

---

## **Вывод**
Коэффициент **`i + 8·m`** в модуле M.6 обеспечивает:
1. **Последовательное встраивание** каждого бита сообщения в отдельный пиксель.  
2. **Отсутствие перекрытий** между символами (каждый новый символ сдвигается на 8 пикселей).  
3. **Минимальную заметность** — заменяется только LSB, что сохраняет визуальное качество изображения.  

Это стандартный подход для **наивного LSB-метода**, который легко реализовать, но при желании его можно усложнить для повышения стеганографической стойкости.














### **Подробное объяснение коррекции `Mf_m ← Mf_m + 32.5 if Mf_m < 32` в шаге 12**

Этот шаг решает проблему обработки **непечатаемых ASCII-символов** (коды 0–31) в Mathcad, которые могут вызывать ошибки при преобразовании в строку. Разберёмся, почему выбрано именно `+32.5` и как это работает.

---

## **1. Проблема: Непечатаемые символы**
- **ASCII-коды 0–31** — это управляющие символы (например, `LF=10`, `CR=13`, `NUL=0`), которые:
  - Не отображаются как видимый текст.
  - Могут нарушить работу строковых функций в Mathcad (например, `vec2str`).
- **Пример**:  
  Если `Mf` содержит `[65, 10, 66]` (`'A'`, `LF`, `'B'`), попытка преобразовать это в строку может дать ошибку или неожиданный результат.

---

## **2. Решение: Смещение кодов**
Чтобы обойти ограничение:
1. **Коды < 32** увеличиваются на `32.5`, превращаясь в **дробные числа** (например, `10 → 42.5`).  
2. **Коды ≥ 32** остаются без изменений.  

**Почему именно `32.5`?**  
- **`32`** — это код первого печатаемого символа ASCII (`' '` — пробел).  
- **`0.5`** добавляется для:
  - Однозначного определения, что символ был скорректирован.
  - Возможности обратного преобразования (например, `42.5 – 32.5 = 10`).

---

## **3. Как это работает в модуле M.10**
```mathcad
Mf := for m ∈ 0..(rows(Sv1)/8 – 1)
  ...
  Mf_m ← B2D(b)          // Получаем ASCII-код символа
  Mf_m ← Mf_m + 32.5 if Mf_m < 32  // Коррекция для кодов < 32
Mf
```
**Пример обработки:**
| Исходный код | После коррекции | Комментарий |
|-------------|-----------------|-------------|
| `65` (`'A'`) | `65` (не изменён) | Код ≥ 32. |
| `10` (`LF`) | `42.5` | Код < 32 → `10 + 32.5 = 42.5`. |
| `0` (`NUL`) | `32.5` | `0 + 32.5 = 32.5`. |

---

## **4. Детали реализации**
### **4.1. Обратное преобразование (шаг 13)**
На **шаге 13** (модуль M.12) происходит восстановление исходных кодов:
```mathcad
for n ∈ 0..cols(N) – 1
  for i ∈ 0..rows(N) – 1
    M_cod1_{N_i,n} ← n if s < N_i,n ≤ e  // N_i,n — позиции скорректированных символов
```
- Если `Mf_m = 42.5` → исходный код был `42.5 – 32.5 = 10`.

### **4.2. Почему не просто `+32`?**
- **Дробная часть (`0.5`)** позволяет:
  1. Отличить скорректированные символы от обычных (например, `42.5` vs `42`).  
  2. Избежать коллизий с реальными кодами (например, `32.5` ≠ `32`).

---

## **5. Пример полного цикла**
**Дано:**  
Сообщение содержит `'A'` (65), перенос строки `LF` (10), `'B'` (66).

1. **Извлечение LSB (шаг 12)**:
   - Получаем вектор `Mf = [65, 10, 66]`.
   - Коррекция: `[65, 42.5, 66]` (так как `10 < 32`).

2. **Обработка на шаге 13**:
   - Обнаруживается `42.5` → вычисляем исходный код: `42.5 – 32.5 = 10`.
   - Итоговое сообщение: `[65, 10, 66]` → `'A\nB'`.

---

## **6. Альтернативные подходы**
Если бы не использовалось `+32.5`:
- **Вариант 1**: Пропуск кодов < 32.  
  **Проблема**: Потеря служебных символов (например, переносов строки).  
- **Вариант 2**: Замена на печатаемые аналоги.  
  **Проблема**: Усложнение алгоритма и потенциальные коллизии.  

**Преимущество `+32.5`**:
- Простота.
- Обратимость без потерь.

---

## **Вывод**
Коррекция `Mf_m ← Mf_m + 32.5 if Mf_m < 32` решает две задачи:
1. **Обходит ограничения Mathcad** на обработку управляющих символов.  
2. **Сохраняет все данные** за счёт обратимости преобразования.  

**Итог**: На шаге 13 исходное сообщение восстанавливается полностью, включая непечатаемые символы.







### **Подробный разбор Шага 13: Извлечение и восстановление скрытого сообщения**

**Цель шага:**  
Фильтрация полезного сообщения из извлеченных данных, ограниченного метками `m_start` и `m_end`, и восстановление исходных кодов символов, которые были скорректированы на шаге 12.

---

## **1. Исходные данные**
- **`Mf`** — вектор с извлеченными символами (после шага 12), где:
  - Символы с ASCII-кодами `< 32` преобразованы в формат `исходный_код + 32.5`.
  - Содержит метки `m_start="n0G@m0k"` и `m_end="KiHeu,6"`, между которыми находится полезное сообщение.
- **`N`** — матрица позиций скорректированных символов (из шага 11).

---

## **2. Алгоритм модуля M.12**
```mathcad
M_cod1 :=
  s ← 0  // Позиция начала сообщения
  e ← 0  // Позиция конца сообщения
  bs ← strlen(ml_start)  // Длина начальной метки (7)
  be ← strlen(ml_end)    // Длина конечной метки (7)
  Mf_str ← vec2str(Mf)   // Преобразуем вектор в строку
  // Поиск меток в строке
  for m ∈ 0..strlen(Mf_str) – 1
    s ← m + bs if substr(Mf_str, m, bs) = ml_start ∧ s = 0
    e ← m – 1 if substr(Mf_str, m, be) = ml_end ∧ e = 0
    break if s ≠ 0 ∧ e ≠ 0  // Обе метки найдены
  // Выделение полезного сообщения
  Mf_str ← substr(Mf_str, s, e – s + 1)
  M_cod1 ← str2vec(Mf_str)  // Обратно в вектор ASCII-кодов
  // Восстановление скорректированных символов
  for n ∈ 0..cols(N) – 1    // Перебор кодов 0..31
    for i ∈ 0..rows(N) – 1
      | break if N_i,n = 0 ∨ N_i,n > e  // Выход за границы
      | M_cod1_{N_i,n - bs} ← n if s < N_i,n ≤ e  // Восстановление кода
  M_cod1
```

---

## **3. Пошаговое выполнение**

### **3.1. Поиск меток в данных**
1. **Преобразование в строку**:
   - `Mf_str ← vec2str(Mf)` — вектор ASCII-кодов превращается в строку для поиска меток.
   - Пример: `[110, 48, 71, 64, 109, 48, 107, ...]` → `"n0G@m0k..."`.

2. **Поиск начальной метки (`ml_start`)**:
   - Просматриваем строку по 7 символов (длина метки).
   - При совпадении с `"n0G@m0k"` запоминаем позицию конца метки: `s ← m + 7`.

3. **Поиск конечной метки (`ml_end`)**:
   - Аналогично, при нахождении `"KiHeu,6"` запоминаем позицию начала метки: `e ← m – 1`.

4. **Прерывание поиска**:
   - Как только обе метки найдены (`s ≠ 0 ∧ e ≠ 0`), цикл останавливается.

### **3.2. Выделение полезного сообщения**
- **`substr(Mf_str, s, e – s + 1)`** — вырезает подстроку между метками.
- Пример:
  - Если `s = 7`, `e = 100`, то возвращаются символы с позиций 7–100.

### **3.3. Восстановление скорректированных символов**
1. **Преобразование обратно в вектор**:
   - `M_cod1 ← str2vec(Mf_str)` — получаем вектор ASCII-кодов сообщения.

2. **Коррекция управляющих символов**:
   - Для каждого возможного исходного кода `n` (0–31):
     - Используем матрицу `N`, чтобы найти все позиции, где был символ с кодом `n`.
     - Восстанавливаем исходный код: `M_cod1[pos] ← n`.
   - **Важно**: Позиции в `N` корректируются на длину начальной метки (`- bs`), так как `N` содержала позиции в полном векторе `Mf`, а не в вырезанном сообщении.

---

## **4. Пример работы**

**Дано:**
- `Mf = [110,48,71,64,109,48,107, 65,42.5,66, 75,105,72,101,117,44,54]` (метки + `'A',LF,'B'` + метки).
- `ml_start = "n0G@m0k"` (первые 7 символов).
- `ml_end = "KiHeu,6"` (последние 7 символов).

**Шаг 13:**
1. **Поиск меток**:
   - Начальная метка найдена на позиции 0 (`s = 7`).
   - Конечная метка найдена на позиции 10 (`e = 10`).

2. **Выделение сообщения**:
   - `substr(Mf_str, 7, 4)` → `[65,42.5,66]` (`'A',LF,'B'`).

3. **Восстановление символов**:
   - Для `n = 10` (LF): из `N` получаем позицию 8 в `Mf`.
   - Корректируем позицию: `8 - 7 = 1` (в вырезанном сообщении).
   - `M_cod1_1 ← 10`.

**Результат:**
- `M_cod1 = [65,10,66]` → `'A\nB'`.

---

## **5. Критические моменты**

### **5.1. Обработка граничных условий**
- Если метки не найдены, `s` и `e` останутся 0, что приведет к ошибке.
- Решение: Добавить проверку `if s = 0 ∨ e = 0 → error`.

### **5.2. Восстановление позиций**
- Вычитание `bs` (длины начальной метки) важно, так как `N` содержит позиции в исходном `Mf`, а не в вырезанном сообщении.

### **5.3. Эффективность поиска меток**
- Поиск по подстрокам (`substr`) может быть медленным для больших сообщений.
- Альтернатива: предварительно найти коды меток в векторе `Mf` без преобразования в строку.

---

## **6. Альтернативные реализации**

### **6.1. Поиск меток в векторе**
```mathcad
// Преобразуем метки в векторы ASCII-кодов
ml_start_vec := str2vec(ml_start)
ml_end_vec := str2vec(ml_end)
// Поиск совпадений в Mf
for m ∈ 0..rows(Mf) – bs
  if submatrix(Mf, m, m+bs-1, 0, 0) = ml_start_vec
    s ← m + bs
  if submatrix(Mf, m, m+be-1, 0, 0) = ml_end_vec
    e ← m – 1
```
**Плюсы**: Работает быстрее для бинарных данных.  
**Минусы**: Сложнее реализация.

---

## **Вывод**
**Шаг 13 решает ключевые задачи:**
1. **Точное выделение сообщения** между метками.
2. **Восстановление управляющих символов** с помощью матрицы `N`.
3. **Подготовка данных** для финального декодирования (если применялось шифрование).

**Итог**: На выходе получаем вектор `M_cod1` с точной копией исходного сообщения, готовый для дешифровки (шаг 14) или сохранения.