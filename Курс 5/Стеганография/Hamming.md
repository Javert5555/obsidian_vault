# Подробное пошаговое объяснение реализации стеганографии с кодом Хемминга

## 1. Инициализация класса и матрицы Хемминга

```python
def __init__(self, input_file):
    self.input_file = input_file
    self.header_size = 54  # Фиксированный размер заголовка BMP
    
    # Проверочная матрица H для (15,11)-кода Хемминга
    self.H = np.array([
        [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
        [0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
        [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],
        [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
    ])
```

**Что происходит**:
1. Создается проверочная матрица H размером 4×15
2. Каждый столбец матрицы - двоичное представление чисел от 1 до 15
3. Матрица будет использоваться для кодирования и декодирования

## 2. Процесс внедрения сообщения (embed)

### Шаг 1: Подготовка сообщения
```python
if isinstance(message, str):
    message = message.encode('utf-8')

message_length = len(message)
message = struct.pack('>I', message_length) + message
```

**Что происходит**:
1. Сообщение преобразуется в байты (если это строка)
2. Длина сообщения упаковывается в 4 байта и добавляется в начало

### Шаг 2: Преобразование в биты
```python
bits = []
for byte in message:
    bits.extend([(byte >> i) & 1 for i in range(7, -1, -1)])
```

**Что происходит**:
1. Каждый байт разбивается на 8 бит
2. Биты добавляются в общий список

### Шаг 3: Группировка битов
```python
bit_groups = [bits[i:i+4] for i in range(0, len(bits), 4)]
```

**Что происходит**:
1. Биты группируются по 4 (поскольку мы кодируем 4 бита в 15 пикселей)

### Шаг 4: Проверка размера изображения
```python
total_pixels_needed = len(bit_groups) * 15
available_pixels = self.image_size
if total_pixels_needed > available_pixels:
    raise ValueError(...)
```

**Что происходит**:
1. Проверяется, хватит ли места в изображении для сообщения

### Шаг 5: Внедрение групп битов
```python
for group in bit_groups:
    # Получаем LSB 15 пикселей
    C = [self.data[data_index + i] & 1 for i in range(15)]
    
    # Вычисляем синдром
    m_vec = np.array(group).reshape(4, 1)
    C_vec = np.array(C).reshape(15, 1)
    s = (self.H @ C_vec) % 2
    s = s ^ m_vec
    
    # Вычисляем позицию для изменения
    i = int(s[3]*8 + s[2]*4 + s[1]*2 + s[0])
    
    # Модифицируем i-й бит
    if 0 < i <= 15:
        self.data[data_index + i - 1] ^= 1
    
    data_index += 15
```

**Что происходит**:
1. Для каждой группы из 4 бит:
   - Берем LSB 15 последовательных пикселей
   - Вычисляем синдром (H·C mod 2)
   - Вычисляем позицию для изменения: i = s₃·8 + s₂·4 + s₁·2 + s₀
   - Инвертируем i-й бит (если i ≠ 0)

## 3. Процесс извлечения сообщения (extract)

### Шаг 1: Чтение групп пикселей
```python
while data_index + 15 <= len(self.data):
    C = [self.data[data_index + i] & 1 for i in range(15)]
    
    # Вычисляем сообщение
    C_vec = np.array(C).reshape(15, 1)
    m = (self.H @ C_vec) % 2
    
    bits.extend(m.flatten().tolist()[:4])
    
    data_index += 15
```

**Что происходит**:
1. Для каждой группы из 15 пикселей:
   - Извлекаем LSB
   - Вычисляем сообщение: m = H·C mod 2
   - Добавляем 4 бита сообщения в общий список

### Шаг 2: Преобразование битов в сообщение
```python
# Извлекаем длину (первые 32 бита)
message_length = 0
for i in range(32):
    message_length = (message_length << 1) | bits[i]

# Извлекаем само сообщение
message_bits = bits[32:32 + message_length*8]
```

**Что происходит**:
1. Первые 32 бита преобразуются в длину сообщения
2. Затем извлекается само сообщение

## 4. Математическая основа

Код Хемминга позволяет:
1. Закодировать 4 бита информации в 15 бит (пикселей)
2. Обнаруживать и исправлять ошибки
3. В стеганографии мы используем его для минимального изменения пикселей

Формулы:
- При внедрении: i = H·C ⊕ m
- При извлечении: m = H·C mod 2

Где:
- H - проверочная матрица
- C - LSB пикселей
- m - биты сообщения
- i - позиция для изменения

## 5. Пример работы

**Внедрение**:
1. Есть сообщение: "A" (01000001)
2. Разбиваем на группы: [0100], [0001]
3. Для первой группы:
   - Берем 15 LSB пикселей: C
   - Вычисляем H·C mod 2
   - Находим i = H·C ⊕ m
   - Инвертируем i-й бит

**Извлечение**:
1. Для тех же 15 пикселей:
   - Вычисляем m = H·C mod 2
   - Получаем исходные 4 бита

Этот метод обеспечивает высокую скрытность, так как изменяет минимальное количество пикселей для кодирования информации.