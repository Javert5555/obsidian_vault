# Подробный разбор алгоритма сокрытия сообщения методом Куттера-Джордана-Боссена

## 1. Инициализация и чтение данных

```math
\mathcal{R}_v := \text{READRGB("G:\img7\orig.bmp")}
```
- Загружается исходное RGB-изображение по указанному пути.

```
M := "Pierre did not choose a career"
```
- Определяется сообщение для встраивания (в данном случае текстовая строка).

```
B := READ_BLUE("G:\img7\orig.bmp")
```
- Извлекается синий канал изображения (B), так как метод работает именно с ним.

```
\mathcal{R}_b := \text{READ_RED("G:\img7\orig.bmp")}
\mathcal{R}_c := \text{READ_GREEN("G:\img7\orig.bmp")}
```
- Читаются красный (R) и зеленый (G) каналы для последующего восстановления изображения.

```
Lm := strlen(M) = 30
```
- Вычисляется длина сообщения (30 символов).

```
Y := cols(B)
X := rows(B)
```
- Получаются размеры изображения: Y - количество столбцов, X - количество строк.

```
\lambda := \text{READBMP("G:\img7\orig.bmp")}
```
- Читается яркость изображения (вероятно, вычисляется как взвешенная сумма каналов).

## 2. Установка параметров

```
v := 0.15
```
- Устанавливается сила встраивания (0.15 - оптимальное значение, обеспечивающее баланс между незаметностью и устойчивостью).

```
\tau := 15
```
- Количество повторений встраивания каждого бита (для повышения надежности).

```
Rr := 4
```
- Количество раундов встраивания.

```
Ko := 125
```
- Начальное значение ключа для генерации псевдослучайной последовательности.

## 3. Генерация ключей

```math
K_v := \begin{cases}
\text{for } s \in 1..2 \, \text{Rr} \\
K_s \leftarrow \text{Ko if } s = 1 \\
K_s \leftarrow \text{str2num}\left[\text{substr}\left(\text{num2str}\left(K_{s-1}\right)^2\right), 0, 3\right]\text{if } s > 1 \\
K_s \leftarrow \text{str2num}\left[\text{substr}\left(\text{num2str}\left(K_{s}\right), 0, 2\right)\right]\text{if } K_s > 255
\end{cases}
```
- Генерируется последовательность ключей:
  1. Первый ключ равен Ko (125)
  2. Каждый последующий ключ получается возведением предыдущего в квадрат и взятием первых 3 цифр
  3. Если ключ превышает 255, берутся первые 2 цифры

## 4. Подготовка сообщения

```
B' := B
```
- Создается копия синего канала для модификации.

```
Mvec ← str2vec(M)
```
- Преобразование строки сообщения в вектор символов.

```
Mvec_bin ← D2B{Mvec}_1
for j ∈ 2...rows(Mvec)
Mvec_bin ← stack{Mvec_bin,D2B{Mvec}_j}
```
- Каждый символ сообщения преобразуется в бинарный вид (вероятно, в 8-битный ASCII код), и все биты объединяются в один вектор.

## 5. Процесс встраивания

```
for i ∈ 1..τ-Lm 8
```
- Цикл по всем битам сообщения с учетом повторений (τ) и длины сообщения (Lm * 8 бит).

```
x ← floor(\(\frac{i}{Y}\)) + 1
y ← mod(i,Y) + 1
```
- Начальное определение координат (x,y) для встраивания бита.

```
for s ∈ 1..Rr
x ← mod(x + B2D[\(D2B[K_{2,s-1}]\) ⊕ submatrix(D2B(y),1,8,1,1)]X] + 1
y ← mod(y + B2D[\(D2B[K_{2,s}]\) ⊕ submatrix(D2B(x),1,8,1,1)]Y] + 1
```
- Уточнение координат с использованием ключей:
  - Ключи преобразуются в бинарный вид (D2B)
  - Выполняется операция XOR (⊕) между битами ключа и координатами
  - Результат преобразуется обратно в десятичный вид (B2D)
  - Новые координаты вычисляются по модулю размеров изображения

```
j ← cell(\(\frac{i}{\tau}\)
```
- Определение индекса бита в сообщении (с учетом повторений).

```
B'x,y ← Bx,y + (2-Mvec_bin_1)v-x,y
```
- Модификация синего канала:
  - Если бит сообщения = 1, то добавляется v*λ
  - Если бит = 0, то вычитается v*λ
  - (2-Mvec_bin_1) дает 1 при Mvec_bin=1 и -1 при Mvec_bin=0

```
B'x,y ← 255 if B'x,y > 255
B'x,y ← 0 if B'x,y < 0
```
- Обеспечение попадания значений в допустимый диапазон [0, 255].

## 6. Сохранение результата

```
S' := augment(R,G,B)
```
- Сборка нового изображения из неизмененных красного и зеленого каналов и модифицированного синего.

```
WRITERGB("G:\img7\res1.bmp") := S'
```
- Сохранение стегоизображения.

```
\[ \overline{W} = C - S' \]
WRITERGB("G:\img7\soob1.bmp") := W
```
- Вычисление и сохранение разницы между исходным и модифицированным изображением (для анализа).

## Особенности метода

1. **Избирательность канала**: Используется только синий канал, так как человеческий глаз менее чувствителен к его изменениям.

2. **Повторяемость**: Каждый бит встраивается τ=15 раз для повышения надежности извлечения.

3. **Псевдослучайное распределение**: Координаты встраивания определяются с использованием ключей, что обеспечивает безопасность.

4. **Адаптация к содержимому**: Модификация яркости зависит от исходного значения пикселя (через λ), что делает изменения менее заметными.

5. **Проверка границ**: Все операции учитывают границы изображения, предотвращая выход за пределы массива.


# Подробный разбор алгоритма извлечения сообщения методом Куттера-Джордана-Боссена

## 1. Инициализация и чтение данных

```math
Bb := READ_BLUE("G:\img7\res1.bmp")
```
- Загружается синий канал стегоизображения, содержащего скрытое сообщение.

```math
\overline{X} = cols(Bb)
X1 := rows(Bb)
```
- Получаются размеры изображения:
  - `cols(Bb)` - количество столбцов (ширина)
  - `rows(Bb)` - количество строк (высота)

```math
σ := 3
\overline{R} = 4
```
- Устанавливаются параметры:
  - `σ = 3` - радиус окрестности для прогнозирования (крест 7×7 пикселей, так как 2σ+1=7)
  - `Rr = 4` - количество раундов (должно соответствовать значению при встраивании)

## 2. Основной цикл извлечения

```math
t \leftarrow 1
```
- Инициализация счетчика повторений для текущего бита.

```math
\text{for } i \in 1..X1 \cdot Y1
```
- Цикл по всем возможным позициям пикселей в изображении (от 1 до X1×Y1).

## 3. Определение координат

```math
x \leftarrow \text{floor}(i / Y1) + 1
y \leftarrow \text{mod}(i, Y1) + 1
```
- Начальное определение координат (x,y) аналогично процессу встраивания.

```math
\text{for } s \in 1..Rr
\parallel x \leftarrow \text{mod} \left[ x + B2D \left( D2B(K_{2,s-1}) \oplus \text{submatrix}(D2B(y),1,8,1,1) \right) \right] X1 \parallel + 1
y \leftarrow \text{mod} \left[ y + B2D \left( D2B(K_{2,s}) \oplus \text{submatrix}(D2B(x),1,8,1,1) \right) \right] Y1 \parallel + 1
```
- Точное определение координат с использованием ключей (аналогично встраиванию):
  1. Ключи преобразуются в бинарный вид (D2B)
  2. Выполняется операция XOR (⊕) между битами ключа и координатами
  3. Результат преобразуется обратно в десятичный вид (B2D)
  4. Новые координаты вычисляются по модулю размеров изображения

## 4. Обработка граничных условий

```math
\text{if } \sigma < x \leq (X1 - \sigma)
\sigma1 \leftarrow (-\sigma)
\sigma2 \leftarrow \sigma
\text{if } x \leq \sigma
\sigma1 \leftarrow (1-x)
\sigma2 \leftarrow \sigma
\text{if } x > (X1-\sigma)
\sigma1 \leftarrow (-\sigma)
\sigma2 \leftarrow (X1-x)
```
- Корректировка параметров для строк:
  - Если пиксель далеко от границ, используется полный радиус σ
  - Если близко к левой границе, уменьшается левая часть окрестности
  - Если близко к правой границе, уменьшается правая часть

```math
\text{if } \sigma < y \leq (Y1-\sigma)
\sigma3 \leftarrow (-\sigma)
\sigma4 \leftarrow \sigma
\text{if } y \leq \sigma
\sigma3 \leftarrow (1-y)
\sigma4 \leftarrow \sigma
\text{if } y > (Y1-\sigma)
\sigma3 \leftarrow (-\sigma)
\sigma4 \leftarrow (Y1-y)
```
- Аналогичная корректировка для столбцов

## 5. Прогнозирование значения яркости

```math
\overline{B}_{x,y} = \frac{
\left[ \sum_{a=\sigma1}^{\sigma2} \text{Bb}_{x+a,y} \right] + 
\left[ \sum_{a=\sigma3}^{\sigma4} \text{Bb}_{x,y+a} \right] - 2 \text{Bb}_{x,y}
}{(\sigma2 - \sigma1 + \sigma4 - \sigma3)}
```
- Вычисление прогнозируемого значения яркости:
  - Суммирование значений пикселей по горизонтали (x±σ) и вертикали (y±σ)
  - Вычитание двойного значения центрального пикселя (компенсация двойного учета)
  - Нормализация на количество используемых пикселей

## 6. Сбор статистики для бита

```math
\text{Bbb}_{t} \leftarrow \text{Bb}_{x,y}
t \leftarrow t+1
```
- Сохранение текущего значения пикселя и увеличение счетчика.

```math
\text{if } t > \tau
\parallel \delta \leftarrow \frac{1}{\tau} \sum_{T=1}^{\tau} \left( \text{Bbb}_{T} - \overline{B}_{T} \right)
j \leftarrow \text{ceil}(i/\tau)
```
- После сбора τ повторений:
  - Вычисляется средняя разница между фактическими и прогнозируемыми значениями
  - Определяется индекс бита в сообщении

## 7. Определение значения бита

```math
Mvec_bin \leftarrow 0 \text{ if } \delta \leq 0
Mvec_bin \leftarrow 1 \text{ if } \delta > 0
t \leftarrow 1
```
- Если средняя разница δ ≤ 0, бит = 0
- Если δ > 0, бит = 1
- Сброс счетчика для следующего бита

## 8. Восстановление сообщения

```math
\text{for } j \in 1..rows(Mvec_bin)/8
Mvec_j \leftarrow B2D(submatrix(Mvec_bin, 8j - 7, 8j, 1, 1))
```
- Группировка битов по 8 и преобразование в символы:
  - Каждый байт (8 бит) преобразуется в десятичное число (B2D)
  - Десятичные значения интерпретируются как ASCII-коды символов

```math
M' := \begin{cases} 
\text{for } j \in 1..strlen(M) \\ 
M_j' \leftarrow \left\lfloor \frac{Mm_j}{32} \right\rfloor \text{ if } \left\lfloor \frac{Mm_j + 31}{32} \right\rfloor \text{ otherwise} \\ 
vec2str(M')
\end{cases}
```
- Дополнительная обработка символов (вероятно, для коррекции ошибок)
- Преобразование вектора символов в строку

## 9. Результат

```math
M' = "Pierre did not choose a career"
```
- Извлеченное сообщение должно совпадать с исходным.

## Ключевые особенности процесса извлечения:

1. **Слепое извлечение**: Не требует оригинального изображения, использует только стегоизображение.

2. **Прогнозирование значений**: Основано на предположении, что соседние пиксели имеют схожую яркость.

3. **Статистический подход**: Каждый бит определяется по множеству встраиваний (τ=15), что повышает надежность.

4. **Обработка границ**: Специальная логика для пикселей у краев изображения.

5. **Использование ключей**: Требует тех же ключей, что и при встраивании, для правильного определения позиций.