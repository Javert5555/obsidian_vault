
### **Подробный разбор Шага 7: Встраивание сообщения в контейнер (модуль M.6)**

На этом шаге происходит **замена наименее значащих битов (LSB)** пикселей изображения на биты секретного сообщения. Рассмотрим модуль **M.6** из методички пошагово.

---

## **1. Исходные данные**
- **`sMe`** — вектор, содержащий:
  - Начальную метку (`m_start`).
  - Закодированное сообщение (`M_cod`).
  - Конечную метку (`m_end`).
- **`Cv`** — одномерный вектор, полученный на Шаге 6, содержащий все пиксели изображения в порядке **B-G-R** (синий, зелёный, красный).  
  - Каждый элемент `Cv` — это **число от 0 до 255** (интенсивность цвета в одном канале пикселя).  
  - Длина `Cv`: `3 × 128 × 166 = 63 744` элемента (для изображения `128×166` пикселей, 3 канала на пиксель).

---

## **2. Алгоритм встраивания (модуль M.6)**
```mathcad
Sv := 
  for m ∈ 0..rows(sMe) – 1
    b ← D2B(sMeₘ)               // (1) Переводим символ сообщения в 8 бит
    for i ∈ 0..7
      P ← D2B(Cvᵢ₊₈·ₘ)          // (2) Берём i-й пиксель, переводим в биты
      P₀ ← bᵢ                    // (3) Заменяем LSB (P₀) на бит сообщения
      Svᵢ₊₈·ₘ ← B2D(P)           // (4) Возвращаем число в десятичный вид
  for j ∈ rows(Sv)..rows(Cv) – 1 // (5) Заполняем оставшиеся пиксели
    P ← D2B(Cvⱼ)
    P₀ ← round(rnd(1))           // (6) Случайный бит (0 или 1)
    Svⱼ ← B2D(P)
  Sv
```

### **Пошаговая работа цикла:**
### **1. Обработка каждого символа сообщения (`sMe`)**
- Для каждого символа `sMeₘ` (всего `rows(sMe) = 1157` символов):
  1. **`b ← D2B(sMeₘ)`**  
     - Символ (например, `'A' = 65`) преобразуется в **8 бит** (`01000001`).
  2. **Для каждого бита `bᵢ` (i = 0..7):**  
     - Берётся **8 пикселей** из `Cv` (по одному на бит).
     - **`P ← D2B(Cvᵢ₊₈·ₘ)`**  
       - Пиксель (например, `Cv₅ = 120`) переводится в **8 бит** (`01111000`).
     - **`P₀ ← bᵢ`**  
       - Меняется **младший бит (P₀)** на `bᵢ` (например, `0 → 1`).
     - **`Svᵢ₊₈·ₘ ← B2D(P)`**  
       - Новое значение пикселя записывается в `Sv` (теперь `01111001 = 121`).

### **2. Заполнение оставшихся пикселей (маскировка)**
- После встраивания сообщения остаются **незатронутые пиксели** (их LSB могут выдать факт скрытия данных).  
- Чтобы это скрыть:
  - **`P₀ ← round(rnd(1))`**  
    - LSB оставшихся пикселей заменяется на **случайные 0 или 1**.  
    - Это делает статистику LSB равномерной, усложняя стеганоанализ.

---

## **3. Пример работы (числовой)**
**Дано:**
- Сообщение: `'A'` (ASCII `65` = `01000001`).
- Пиксели `Cv`: `[120, 45, 200, 33, 90, 17, 255, 180, ...]`.

**Шаги:**
1. `'A' → 65 → 01000001` (8 бит).
2. Для каждого бита:
   - **Бит 0 (`0`):**  
     - Берём `Cv₀ = 120` (`01111000`).  
     - Заменяем LSB: `0111100**0** → 0111100**0**` (остаётся `120`).  
   - **Бит 1 (`1`):**  
     - Берём `Cv₁ = 45` (`00101101`).  
     - Заменяем LSB: `0010110**1** → 0010110**1**` (остаётся `45`).  
   - **...**
   - **Бит 7 (`0`):**  
     - Берём `Cv₇ = 180` (`10110100`).  
     - Заменяем LSB: `1011010**0** → 1011010**0**` (остаётся `180`).  
3. Результат:  
   - `Sv = [120, 45, 200, 33, 90, 17, 255, 180, ...]` (первые 8 пикселей почти не изменились, так как LSB совпали с битами `'A'`).  

---

## **4. Важные замечания**
### **Почему заменяется именно LSB (P₀)?**
- **LSB (бит 0)** — наименее значимый, его изменение почти не влияет на цвет пикселя.  
- Например:
  - `120` (`01111000`) → `121` (`01111001`) — визуально неотличимо.  
  - `255` (`11111111`) → `254` (`11111110`) — почти незаметно.

### **Что происходит с оставшимися пикселями?**
- Если сообщение короткое, а контейнер большой (например, `1157 × 8 = 9256` бит из `63 744`), то:
  - Остальные пиксели (`63 744 - 9256 = 54 488`) заполняются **случайными LSB**, чтобы скрыть границу сообщения.

### **Как повышается скрытность?**
1. **Порядок B-G-R** (вместо R-G-B) усложняет анализ.  
2. **Случайные LSB** в хвосте делают статистику равномерной.  
3. **Метки (`m_start`, `m_end`)** помогают извлечь сообщение, но не видны без знания ключа.

---

## **5. Вывод**
**Шаг 7 — ключевой этап LSB-стеганографии**, где:
1. Каждый бит сообщения встраивается в LSB пикселей.  
2. Остальные пиксели маскируются случайными битами.  
3. Результат (`Sv`) — это модифицированный вектор, который позже преобразуется обратно в изображение (`mushu1.bmp`).  

**Итог:** Изображение выглядит почти так же, но содержит скрытое сообщение.







### **Разбор коэффициента `i + 8·m` в модуле M.6**

В формуле **`Svᵢ₊₈·ₘ ← B2D(P)`** из шага 7 используется индекс `i + 8·m`. Давайте разберём, почему он имеет именно такой вид и как работает.

---

## **1. Общий смысл выражения**
Этот индекс определяет, **в какой именно пиксель изображения записывается очередной бит сообщения**.  
- **`i`** — номер бита в текущем символе (от 0 до 7).  
- **`m`** — номер символа в сообщении (от 0 до `rows(sMe)-1`).  
- **`8·m`** — сдвиг, чтобы перейти к следующей группе из 8 пикселей (по одному на бит символа).  

Таким образом, **`i + 8·m`** — это линейный адрес пикселя в векторе `Cv`, куда записывается `i`-й бит `m`-го символа.

---

## **2. Почему именно `8·m`?**
### **Принцип "1 символ = 8 пикселей"**
Каждый символ сообщения кодируется **8 битами** (например, `'A' = 01000001`).  
Поскольку **1 бит сообщения встраивается в 1 пиксель**, то для одного символа нужно **8 пикселей**.  

- **Первые 8 бит (символ `m=0`)** записываются в пиксели:  
  `Cv₀, Cv₁, Cv₂, ..., Cv₇` (индексы `i + 8·0 = 0,1,2,...,7`).  
- **Следующие 8 бит (символ `m=1`)** — в:  
  `Cv₈, Cv₉, Cv₁₀, ..., Cv₁₅` (индексы `i + 8·1 = 8,9,...,15`).  
- **И так далее...**

### **Пример для первых двух символов**
Допустим, сообщение начинается с `"AB"`:
- `'A'` = `65` = `01000001` → биты `[0,1,0,0,0,0,0,1]`.  
- `'B'` = `66` = `01000010` → биты `[0,1,0,0,0,0,1,0]`.  

**Пиксели, куда встраиваются биты:**
| Символ (`m`) | Бит (`i`) | Индекс в `Cv` (`i + 8·m`) | Бит сообщения |
|-------------|----------|--------------------------|---------------|
| 0 (`'A'`)   | 0        | 0 + 8·0 = **0**           | `0` (LSB `Cv₀`) |
|             | 1        | 1 + 8·0 = **1**           | `1` (LSB `Cv₁`) |
|             | ...      | ...                       | ...           |
|             | 7        | 7 + 8·0 = **7**           | `1` (LSB `Cv₇`) |
| 1 (`'B'`)   | 0        | 0 + 8·1 = **8**           | `0` (LSB `Cv₈`) |
|             | 1        | 1 + 8·1 = **9**           | `1` (LSB `Cv₉`) |
|             | ...      | ...                       | ...           |

---

## **3. Почему нельзя просто использовать `i + m`?**
Если бы индекс был `i + m`, то:
- Для `m=0`: биты `'A'` записались бы в `Cv₀, Cv₁, ..., Cv₇`.  
- Для `m=1`: биты `'B'` попали бы в `Cv₁, Cv₂, ..., Cv₈`.  

**Проблема:**  
- Бит `'B'` (индекс `i=0`, `m=1`) перезаписал бы `Cv₁`, куда уже был записан бит `'A'` (индекс `i=1`, `m=0`).  
- **Перекрытие данных** привело бы к потере информации.

**Решение:**  
- **`8·m`** гарантирует, что каждый новый символ начинается с **следующего свободного пикселя** через каждые 8 позиций.  

---

## **4. Проверка границ массива**
- Длина сообщения: `rows(sMe) = 1157` символов → требуется `1157 × 8 = 9256` пикселей.  
- Длина `Cv`: `128 × 166 × 3 = 63 744` пикселей.  
- **Условие выполняется:** `9256 < 63 744` — контейнер достаточно велик.

Если бы сообщение было длиннее, чем `63 744 / 8 = 7968` символов, программа выдала бы ошибку (выход за границы массива).

---

## **5. Альтернативные варианты размещения**
Для повышения скрытности иногда используют **нелинейное распределение** битов:
1. **Чередование битов по каналам**:  
   - Например, первый бит в `R`, второй в `G`, третий в `B`, и т.д.  
2. **Псевдослучайная перестановка**:  
   - Биты записываются не подряд, а в порядке, заданном криптографическим ключом.  
3. **Пропуск пикселей**:  
   - Встраивание битов через каждые `N` пикселей (например, в каждый 3-й).  

Но в данной работе выбран **простейший линейный вариант** для наглядности.

---

## **Вывод**
Коэффициент **`i + 8·m`** в модуле M.6 обеспечивает:
1. **Последовательное встраивание** каждого бита сообщения в отдельный пиксель.  
2. **Отсутствие перекрытий** между символами (каждый новый символ сдвигается на 8 пикселей).  
3. **Минимальную заметность** — заменяется только LSB, что сохраняет визуальное качество изображения.  

Это стандартный подход для **наивного LSB-метода**, который легко реализовать, но при желании его можно усложнить для повышения стеганографической стойкости.