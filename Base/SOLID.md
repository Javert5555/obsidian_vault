**SOLID** – это набор из пяти принципов объектно-ориентированного программирования, разработанный для улучшения структуры и читаемости кода.

1. Single Responsibility - Принцип единственной ответственности
2. Open Closed - Принцип открытости-закрытости
3. Liskov Substitution - Принцип подстановки Барбары Лисков
4. Interface Segregation - Принцип разделения интерфейса
5. Dependency Inversion - Принцип инверсии зависимостей

![[dbc582da9e391cca96f4ad0c978154f7.png]]

## 1. Single Responsibility (принцип единственной ответственности)

Каждый класс должен отвечать только за одну зону ответственности (действий), чтобы его было проще дополнять и менять. Изменение должно минимально затрагивать код. Следует разделить функциональность большого класса на более мелкие, отвечающие за конкретные аспекты, части.

>[!main] 
> Каждый класс должен отвечать только за одну операцию.

## 2. Open Closed (принцип Открытости-Закрытости)

Класс должен быть закрыт для изменения, но открыт для расширения. Код должен быть написан так, чтобы можно было расширять функционал, не меняя уже написанный.

>[!main]
>Классы должны  быть  открыты для расширения, но закрыты для модификации.

## 3. Liskov Substitution (принцип подстановки Барбары Лисков)

>[!main]
>Класс потомок должен исполнять функционал, который содержит родительский класс.

Если в коде программы Базовый класс заменить на его Наследника, то программа должна работать, так как в Наследнике есть все операции, которые были в Базовом. В Базовый класс нужно выносить только общую логику, которую наследники будут реализовывать. Наследников создаем только тогда, когда они правильно собираются реализовать логику Базового класса без проблем.

Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы.

Необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат. Или же результат может отличаться, но при этом относиться к тому же типу.

## 4. Interface Segregation (принцип разделения интерфейса)

>[!main]
Не следует ставить клиент в зависимость от методов (реализовывать интерфейсы), которые он не использует.

Клиенты не должны зависеть от интерфейсов, которые они не используют. Большие интерфейсы следует разбивать на интерфейсы поменьше. Так клиенты смогут использовать только те интерфейсы, которые им нужны. Это делает менее связанный код, уменьшает зависимости между элементами системы, упрощает изменения в коде.

## 5. Dependency Inversion (принцип инверсии зависимостей)

>[!main]
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от реализации. Реализация должна зависеть от абстракции.

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
  
Модули (или классы) верхнего уровня - классы, которые выполняют операцию при помощи инструмента  
Модули (или классы) нижнего уровня - инструменты, которые нужны для выполнения операций  
Абстракции – представляют интерфейс, соединяющий два класса  
Детали - специфические характеристики работы инструмента