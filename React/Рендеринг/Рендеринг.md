## Что такое рендеринг?

**Рендеринг** — это процесс, в рамках которого React опрашивает ваши компоненты, требуя от них актуальное описание той секции пользовательского интерфейса, за которую они отвечают, основываясь на текущей комбинации пропсов (`props`) и состояния (`state`).

### Обзор процесса рендеринга

React начинает процесс рендеринга с корня дерева компонентов и циклически спускается вниз, чтобы найти все компоненты, помеченные как требующие обновления. Для каждого помеченного компонента React вызывает либо `classComponentInstance.render()` (для классовых компонентов), либо `FunctionComponent()` (для функциональных компонентов) и сохраняет результат рендеринга.

Результат рендеринга компонентов обычно представлен в виде JSX-кода, который затем компилируется и развертывается как JS-код, принимая вид серии вызовов `React.createElement()`. Функция `createElement` возвращает _React-элементы_, представляющие собой простые JS-объекты, описывающие желаемую структуру пользовательского интерфейса. Пример:

``` jsx
// This JSX syntax:
return <SomeComponent a={42} b="testing">Text here</SomeComponent>

// is converted to this call:
return React.createElement(SomeComponent, {a: 42, b: "testing"}, "Text Here")

// and that becomes this element object:
{type: SomeComponent, props: {a: 42, b: "testing"}, children: ["Text Here"]}
```

Собрав результаты рендеринга всего дерева компонентов, React делает сравнение с новым деревом объектов (его часто называют «виртуальной DOM») и составляет список всех изменений, которые нужно внести в «настоящую» DOM, чтобы привести ее к желаемому в данный момент виду. Процесс сопоставления двух деревьев и вычисления разницы между ними называется [согласованием](https://ru.reactjs.org/docs/reconciliation.html).

_Объектная Модель Документа (DOM) – это программный интерфейс (API) для HTML и XML документов. DOM предоставляет структурированное представление документа и определяет то, как эта структура может быть доступна из программ, которые могут изменять содержимое, стиль и структуру документа. Представление DOM состоит из структурированной группы узлов и объектов, которые имеют свойства и методы. По существу, DOM соединяет веб-страницу с языками описания сценариев либо языками программирования._

### Этапы рендеринга и фиксации

Команда разработчиков React разделила этот процесс на два этапа:

-   этап рендеринга (render phase) — рендеринг всех компонентов и вычисление изменений;
    
-   этап фиксации (commit phase) — процесс применения изменений к DOM.
    

Как только React обновит DOM на этапе фиксации, он соответствующим образом актуализирует все рефы (refs), чтобы они указывали на запрошенные DOM-узлы и экземпляры компонентов. Затем он синхронно выполняет методы жизненного цикла компонентов componentDidMount и componentDidUpdate и хуки useLayoutEffect.

После небольшого тайм-аута React выполняет все хуки useEffect. Этот момент также известен как этап пассивных эффектов (passive effects).

Важно понимать, что **«рендеринг» не означает «обновление DOM», то есть компонент может отрендериться без каких-либо видимых изменений**. Когда React рендерит компонент:

-   после рендеринга компонента может быть возвращен тот же результат, что и в прошлый раз, — изменения при этом не требуются;
    
-   в конкурентном режиме React может рендерить компонент несколько раз, но при этом каждый раз сбрасывать результат рендеринга, если другие обновления делают текущие результаты рендеринга неактуальными.

### Очередь рендеринга

По завершении первичного рендеринга можно воспользоваться одним из нескольких способов, чтобы сообщить React о постановке в очередь повторного рендеринга:

-   классовые компоненты:
    
    -   `this.setState()`;
        
    -   `this.forceUpdate()`;
        
-   функциональные компоненты:
    
    -   хуки `useState` для задания состояния;
        
    -   редюсеры `useReducer` для вызова функций dispatch;
        
-   прочее:
    
    -   повторный вызов `ReactDOM.render(<App>)` (что эквивалентно вызову `forceUpdate()` для корневого компонента).

## Поведение рендеринга по умолчанию

Важно помнить следующий факт:

**По умолчанию после рендеринга родительского компонента React рекурсивно рендерит _все_ дочерние компоненты внутри родителя!**

Допустим, у нас есть дерево компонентов `A > B > C > D`, которые мы уже отобразили на странице. Пользователь щелкает кнопку в компоненте B, которая приращает счетчик. Происходит следующее:

-   Мы вызываем функцию `setState()` в компоненте B, которая ставит в очередь повторный рендеринг B.
    
-   React начинает проход рендеринга с самого верха дерева.
    
-   React видит, что `A` не помечен как нуждающийся в обновлении, и проходит мимо.
    
-   React видит пометку на `B` о необходимости обновления и производит его рендеринг. B, как и в прошлый раз, возвращает `<C />`.
    
-   `C` изначально _не_ имел пометки о необходимости обновления. Но поскольку отрендерился родительский компонент `B`, React движется сверху вниз и попутно рендерит `C`. Компонент `C` снова возвращает `<D />`.
    
-   `D` также не нуждался в рендеринге, но поскольку отрендерился его родительский компонент `C`, React движется еще ниже и также рендерит `D`.
    

Другими словами:

**Рендеринг компонента приводит по умолчанию к рендерингу _всех_ вложенных в него компонентов!**

Также следует учитывать другой важный момент:

**При обычном рендеринге для React не имеет значения, изменились пропсы или нет, — он в любом случае будет рендерить дочерние компоненты, просто потому, что отрендерился родительский компонент.**

Следует помнить, что **в рендеринге _нет_ ничего страшного, — с его помощью React узнает, нужно ли ему внести какие-либо изменения в DOM!**

### Правила рендеринга в React

Одно из главных правил рендеринга в React заключается в том, что **рендеринг должен быть «чистым» и не приводить к каким-либо побочным эффектам.** Довольно скользкое и неоднозначное требование, ведь большинство побочных эффектов не очевидны и не приводят к каким-то фатальным ошибкам. Например, строго говоря, метод `console.log()` считается побочным эффектом, но он не приводит к каким-то проблемам. Мутирование пропа — однозначно побочный эффект, но, _вполне вероятно_, ничего не сломается. Наличие AJAX-вызова посреди рендеринга тоже относится к очевидным побочным эффектам, что в ряде случаев приводит к неожиданному поведению приложения (в зависимости от типа запроса).

-   Логика рендеринга _не может_:
    
    -   мутировать существующие переменные и объекты;
        
    -   создавать случайные значения, такие как `Math.random()` или `Date.now()`;
        
    -   делать сетевые запросы;
        
    -   ставить в очередь обновления состояния.
        
-   Логика рендеринга _может_:
    
    -   мутировать новые объекты, созданные во время рендеринга;
        
    -   генерировать ошибки;
        
    -   «лениво инициализировать» еще не созданные данные, например кэшированное значение.

Про согласование и рендеринг: https://ru.reactjs.org/docs/reconciliation.html
Полная статья: https://habr.com/ru/company/otus/blog/595321/