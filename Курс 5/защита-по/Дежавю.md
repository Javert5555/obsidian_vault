# Вопросы по дисциплине «Защита программ и данных»

## 1. Обоснование необходимости анализа программ.
Актуальность задачи анализа программных реализаций обусловлена следующими факторами:
1. Компьютеризация всех областей национальной экономики России.
2. Многообразие программных средств обработки информации и используемых в них средств защиты.
3. Большой разброс в уровне подготовленности разработчиков.
4. Широкое распространение программных средств зарубежного производства.
5. Регулярное появление новых версий программных продуктов, которые могут отличаться средствами защиты.

## 2. Метод экспериментов с «черным ящиком».
Программа рассматривается как «черный ящик», преобразующий входные данные. Аналитик проводит эксперименты, манипулируя входными данными и анализируя результаты.

**Особенности:**
1. Эффективен для простых алгоритмов.
2. Не зависит от программной реализации.

**Трудности:**
1. Нет гарантий соответствия угаданного алгоритма действительности.
2. Проблемы с анализом сложных форматов данных.

**Примеры экспериментов:**
1. Анализ формата заголовков бинарных файлов.
2. Проверка наличия марканта (случайно генерируемое число или строка, используемое в криптографических системах для затруднения выявления одинаковых фрагментов в потоке зашифрованных данных) в криптосистеме.
3. Определение типа криптографического преобразования (поточный/блочный шифр).

## 3. Статический метод.
Статический метод основан на анализе исполняемых файлов программы без её запуска. Основной инструмент — **дизассемблеры**, которые преобразуют машинный код в ассемблерный листинг.
**Достоинства:**
1. Позволяет полностью восстановить алгоритмы защиты (при отсутствии защиты от дизассемблирования).
2. Не зависит от сложности алгоритмов.

**Недостатки:**
1. Проблема восстановления символических имен.
2. Сложность различения команд и данных.
3. Ошибки в определении границ машинных команд.

**Классификация дизассемблеров:**
- «Глупые» (dumb): Быстрые, но неточные (встроенные в отладчики).
- «Умные» (smart): Точные, но медленные (IDA Pro).

## 4. Программные отладочные средства динамического метода.
Основной инструмент — отладчики (OllyDbg, WinDbg), использующие:
1. **Флаг трассировки (TF)**: Пошаговое выполнение.
2. **Точки останова**: Остановка на заданных командах.
3. **Отладочные регистры**: Аппаратные точки останова.

**Возможности отладчиков:**
1. Пошаговый проход программы.
2. Установка условных точек останова.
3. Просмотр и изменение регистров, памяти.

**Ограничения:**
1. Невозможность установки точек останова в ПЗУ.
2. Риск зацикливания.
3. Защита программ от отладки.

## 5. Методика изучения программ динамическим методом.

Анализ программы динамическим методом включает три этапа:
#### 1. Поиск подходов к интересующим функциям
1. **Метод маяков**: Установка точек останова на системные вызовы (например, обращения к файловой системе).
2. **Метод Step-Trace**: Пошаговый проход программы с чередованием режимов Step (без входа в функции) и Trace (с входом).
#### 2. Анализ потоков данных
- **Метод аппаратной точки останова**: Отслеживание изменений в буферах памяти.
- **Метод Step-Trace второго этапа**: Поиск функций, изменяющих интересующие данные.
#### 3. Анализ функций
1. Изучение дизассемблированных листингов.
2. Проверка гипотез о работе алгоритмов через тестовые программы.

**Преимущества динамического метода:**
1. Целенаправленный анализ.
2. Возможность наблюдения состояния памяти и регистров.
3. Комбинация с другими методами (статическим и «черным ящиком»).

## 6. Особенности анализа оверлейных программ.
Оверлейные программы загружают в оперативную память только те фрагменты кода, которые выполняются в данный момент, освобождая память от неиспользуемых частей. Это усложняет анализ, так как точки останова, установленные в удаленных фрагментах, теряются. Для решения проблемы рекомендуется устанавливать точку останова в диспетчере оверлеев, который никогда не выгружается из памяти. Это позволяет отладчику восстанавливать потерянные точки останова при каждом изменении расположения кода.

## 7. Особенности анализа графических программ Windows.
Графические программы Windows возвращают управление операционной системе после инициализации и получают его только при обработке сообщений. Для анализа таких программ модифицируют метод Step-Trace:

1. Определяют адрес оконной функции с помощью утилиты Spy++.
2. Устанавливают точку останова в оконную функцию, но не в начало, чтобы избежать срабатывания на нерелевантные сообщения (например, WM_COMMAND).
3. Трассировка начинается с этой точки останова.

Для диалоговых окон используют альтернативные подходы, например, установку точек останова на функции создания диалогов (например, DialogBoxParamW).

## 8. Анализ параллельного кода.
Параллельные программы могут выполнять один и тот же код в нескольких потоках, что приводит к хаотичным остановкам при трассировке. Рекомендации:

1. Удалять все точки останова перед началом трассировки, чтобы контролировать только один поток.
2. Использовать команду Disable для временного отключения точек останова.
3. Избегать установки точек останова на функции, используемые несколькими потоками.

Некоторые отладчики (например, WinDbg) поддерживают точки останова для конкретных потоков, но их работа может быть некорректной.

## 9. Особенности анализа кода в режиме ядра Windows.
Анализ кода ядра требует специальных отладчиков, таких как Syser или WinDbg. Особенности:

1. **Syser** перехватывает функции ядра и приостанавливает систему при работе.    
2. Рекомендуется запускать Syser в виртуальной машине для удобства перезагрузки.
3. Условные точки останова могут работать некорректно.
4. Код ядра выполняется в контексте разных процессов, что усложняет анализ.
5. Для драйверов точки останова следует устанавливать после их загрузки, но до выполнения.

Анализ требует осторожности, так как ошибки могут привести к невозможности загрузки системы.

## 10. Вспомогательные инструменты анализа программ.
1. **ProcMon**: Мониторит обращения к дискам, создание процессов, загрузку библиотек и использование ресурсов. Позволяет фильтровать события и анализировать стеки вызовов.
2. **Process Explorer**: Показывает детальную информацию о процессах, включая открытые объекты, потоки и стек вызовов. Позволяет приостанавливать процессы, управлять приоритетами и закрывать хэндлы.
3. **Spy++**: Определяет адреса оконных функций и свойства окон.
4. **Антивирусные мониторы**: Используются для выявления вредоносного поведения.

Эти инструменты помогают быстро получать информацию о работе программы и выявлять подозрительные активности.

## 11. Классификация систем защиты программного обеспечения. Системы, устанавливаемые на скомпилированные модули ПО;

**Системы, устанавливаемые на скомпилированные модули ПО** наиболее удобны для производителя ПО, так как легко можно защитить уже полностью готовое и оттестированное ПО, а потому и наиболее популярны. В то же время стойкость этих систем достаточно низка (в зависимости от принципа действия СЗ), так как для обхода защиты достаточно определить точку завершения работы "конверта" защиты и передачи управления защищенной программе, а затем принудительно ее сохранить в незащищенном виде

## 12. Классификация систем защиты программного обеспечения. Системы, встраиваемые в исходный код ПО до компиляции;

**Системы, встраиваемые в исходный код ПО до компиляции** неудобны для производителя ПО, так как возникает необходимость обучать персонал работе с программным интерфейсом (API) системы защиты с вытекающими отсюда денежными и временными затратами. Кроме того, усложняется процесс тестирования ПО и снижается его надежность, так как кроме самого ПО ошибки может содержать API системы защиты или процедуры, его использующие. Но такие системы являются более стойкими к атакам, потому что здесь исчезает четкая граница между системой защиты и как таковым ПО.

## 13. Классификация систем защиты программного обеспечения. Комбинированные (Алгоритмы запутывания)

Самыми стойкими к атакам являются комбинированные системы.

Алгоритмы запутывания - используются хаотические переходы в разные части кода, внедрение ложных процедур - "пустышек", холостые циклы, искажение количества реальных параметров процедур ПО, разброс участков кода по разным областям ОЗУ и т. п.

Рассматриваемый алгоритм может быть реализован в виде полиморфных преобразований кода, когда преобразование модифицируемого кода не является взаимно однозначным, т. е. после упаковки и последующей распаковки кода получается код, не идентичный оригиналу, но выполняющий те же самые действия. Перечислим некоторые наиболее простые полиморфные преобразования:

1. **Вставка "пустышек"**: добавление бесполезных команд (например, `nop`).
2. **Ложные условные переходы**: вставка команд `jnz` с заведомо ложными условиями.
3. **Замена команд синонимами**: например, `mov eax, ebx` заменяется на эквивалентную последовательность `push ebx; pop eax`.
4. Замена регистров и (или) локальных переменных, используемых командами.

**Эффект**: усложняет статический анализ и дизассемблирование.

## 14. Классификация систем защиты программного обеспечения. Комбинированные (Алгоритмы мутации)

Алгоритмы мутации - создаются таблицы соответствия операндов-синонимов и замена их друг на друга при каждом запуске программы по определенной схеме или случайным образом, случайные изменения структуры программы.

Алгоритм мутации может быть реализован с использованием искусственного усложнения структуры программы:

1. **Косвенные вызовы функций**: вызов через указатели (`call [pFunction]`).
2. вызов функции в отдельном потоке;
3. вызов функции через пул потоков;
4. вызов функции через передачу некоторому окну нестандартного сообщения;
5. вызов функции по таймеру (предполагается, что текущий поток программы не создает никаких окон);
6. вызов функции через асинхронный ввод-вывод;
7. использование нестандартных способов сравнения данных, например, вместо стандартных машинных команд сравнения (cmp, test) можно использовать арифметические и логические команды (add, sub, and, or и т.д.).

## 15. Классификация систем защиты программного обеспечения. Комбинированные (Алгоритмы компрессии данных)

**Алгоритмы компрессии данных** - программа упаковывается, а затем распаковывается по мере выполнения. Реализуется за счет использования динамического изменения кода программы.

Метод основан на том, что код программы, за исключением небольшой части — распаковщика, хранится в исполняемом файле в искаженном виде, а преобразуется к нормальному виду лишь в оперативной памяти, в ходе выполнения программы. При попытке дизассемблировать программу с динамически изменяемым кодом дизассемблер правильно дизассемблирует только распаковщик (если в отношении распаковщика не применены другие методы защиты от анализа), а большую часть кода программы интерпретирует как данные.

Динамическое изменение кода программы, выполняемое не одномоментно, а регулярно, фактически делает программу оверлейной — и каждый момент времени большая часть кода программы недоступна для отладочных средств. Поэтому данный способ динамического изменения кода позволяет обеспечить защиту не только от статического, но и от динамического метода анализа кода. Особенно мощная защита обеспечивается в том случае, если в программе поддерживается несколько различных алгоритмов модификации кода, и при каждой упаковке фрагмента кода алгоритм упаковки выбирается случайным образом (при распаковке кода выбор алгоритма однозначен). Также повышает эффективность защиты от анализа случайный выбор адресов оперативной памяти, по которым размещаются распакованные фрагменты кода.

## 16. Классификация систем защиты программного обеспечения. Комбинированные (Алгоритмы шифрования данных)



## 17. Классификация систем защиты программного обеспечения. Комбинированные (Методы затруднения отладки)

## 18. Схема противостояния технических методов и средств защиты

## 19. Достоинства и недостатки основных систем защиты.

## 20. классификация СЗ от НСД по принципу функционирования системы Парольной защиты

## 21. классификация СЗ от НСД по принципу функционирования Системы "привязки" ПО

## 22. классификация СЗ от НСД по принципу функционирования Программно-аппаратные средства защиты ПО с электронными ключами

## 23. Показатели эффективности систем защиты.

## 24. Описание субъектно-ориентированной модели компьютерной

## 25. Описание НСД на основе субъектно-ориентированной модели

## 26. Модели взаимодействия программной закладки с атакуемой системой. Модель «наблюдатель»

## 27. Модели взаимодействия программной закладки с атакуемой системой. Модель «перехват»

## 28. Модели взаимодействия программной закладки с атакуемой системой. Модель «искажение» Несанкционированное использование средств динамического изменения полномочий

## 29. Модели взаимодействия программной закладки с атакуемой системой. Модель «искажение» Порождение дочернего процесса системным процессом и Модификация машинного кода монитора безопасности объектов.

## 30. Модели взаимодействия программной закладки с атакуемой системой. Модель «искажение» Стелс-технологии

## 31. Предпосылки к внедрению программных закладок.

## 32. уязвимости ПО: переполнения буферов;

## 33. уязвимости ПО: отсутствие необходимых проверок входных данных;

## 34. уязвимости ПО: 3использование некорректного контекста безопасности в ходе выполнения тех или иных функций;

## 35. уязвимости ПО: использование устаревших функций системы, ранее бывших безобидными, но ставших опасными в новых условиях

## 36. Методы внедрения программных закладок: маскировка под прикладноеПО

## 37. Методы внедрения программных закладок: маскировка под системное ПО

## 38. Методы внедрения программных закладок подмена системного ПО

## 39. Методы внедрения программных закладок: прямое и косвенное ассоциирование