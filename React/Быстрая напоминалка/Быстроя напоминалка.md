## JSX
После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.

По умолчанию React DOM экранирует все значения, включённые в JSX перед тем как отрендерить их. Это гарантирует, что вы никогда не внедрите чего-либо, что не было явно написано в вашем приложении. Всё преобразуется в строчки, перед тем как быть отрендеренным. Это помогает предотвращать атаки межсайтовым скриптингом (XSS).

Babel компилирует JSX в вызовы `React.createElement()`.

Следующие два примера кода эквивалентны между собой:

``` jsx
const element = (
  <h1 className="greeting">
    Привет, мир!
  </h1>
);
```

``` jsx
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Привет, мир!'
);
```

## Рендеринг элементов


Элемент описывает то, что вы хотите увидеть на экране:

``` jsx
const element = <h1>Hello, world</h1>;
```

В отличие от DOM-элементов, элементы React — это простые объекты, не отнимающие много ресурсов. React DOM обновляет DOM, чтобы он соответствовал переданным React-элементам.

**Элементы** можно перепутать с более известной концепцией «**компонентов**». С компонентами мы ознакомимся в следующей главе. **Элементы** — это то, «из чего сделаны» **компоненты**.

## Компоненты

``` jsx
let Welcome = (props) => {
  return <h1>Привет, {props.name}</h1>;
}
```

Эта функция — компонент, потому что она получает данные в одном объекте («пропсы») в качестве параметра и возвращает React-элемент. Такие компоненты называются «функциональными», так как они буквально являются функциями.

Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того, функциональный он или классовый.

## Передача аргументов в обработчики событий

Внутри цикла часто нужно передать дополнительный аргумент в обработчик события. Например, если `id` — это идентификатор строки, можно использовать следующие варианты:

``` jsx
const sendMessage = (e, message) => {
    e.preventDefault()
    console.log(message)
}

<form onSubmit={(e) => sendMessage(e, 'Отправлено')}>
        <button type="submit">Отправить</button>
</form>
```

## Списки и ключи

Ключи помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени:

Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи.

Как правило, элементам внутри `map()` нужны ключи.

Ключи должны быть уникальными среди соседних элементов

**Ключи внутри массива должны быть уникальными только среди своих соседних элементов. Им не нужно быть уникальными глобально. Можно использовать один и тот же ключ в двух разных массивах.**

``` jsx
function NumberList(props) {
  const numbers = props.numbers;
  return (
    <ul>
      {numbers.map((number) =>        <ListItem key={number.toString()}                  value={number} />      )}    </ul>
  );
}
```