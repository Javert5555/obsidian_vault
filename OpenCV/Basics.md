## Чтение изображений и видео

imread - возвращает матрицу пикселей.
``` python
img = cv.imread('./photos/cat.jpg')
>>>
[[[ 37  58  56]
  [ 48  70  68]
  [ 38  60  58]
  ...
  [162 152 142]
  [164 160 149]
  [162 160 149]]
  ...
  [188 188 188]
  [194 192 192]
  [195 193 193]]]
```

`imshow('Cat', img)` - отображает изображение с меткой 'Cat'.

Параметр `0` в `cv.waitKey(0)` - это задержка в миллисекундах. Если он установлен в 0, функция будет бесконечно ожидать, пока не будет нажата клавиша. Если во время ожидания нажата клавиша, функция вернет код ASCII нажатой клавиши.

`cv.VideoCapture()` - функция в библиотеке OpenCV, используемая для чтения видео ввода из камеры или файла. Функция возвращает объект VideoCapture, который представляет входной видеопоток и может использоваться для чтения кадров из источника видео ввода.

```python
import cv2 as cv

capture = cv.VideoCapture('./videos/dog.mp4') # получить ввод из видеофайла
# capture = cv.VideoCapture(0) # получить ввод из веб-камеры

while True:
    # получаем каждый кадр (frame) видео и статус был ли он успешно получен(isTrue)
    isTrue, frame = capture.read()

    # если кадр не был получен выходим из цикла
    if not isTrue:
        break

    # отображаем этот кадр
    cv.imshow('Video', frame)

    # выходим из цикла если мы ждём 20 миллисекунд или при нажатии клавиши 'd'
    if cv.waitKey(20) & 0xFF==ord('d'):
        break

# освобождение ресурсов видеопотока после завершения цикла
capture.release()
# закрытие всех окон OpenCV после освобождения ресурсов видеопотока
cv.destroyAllWindows()
```

Аргументам `cv.VideoCapture()` являются либо целые числа (0, 1, 2, 3, ...), которые обозначают видео/веб-камеры, подключённые к компьютеру, либо путь к видеофайлу

Объект VideoCapture имеет несколько методов и свойств:
- Метод `isOpened()` может использоваться для проверки, открыт ли видеопоток или нет.
- Метод `read()` считывает видео кадр, за кадром. Возвращает два значения: _**булево значение**_, указывающее, успешно ли была выполнена операция чтения текущего кадра, и соответствующий кадр в виде NumPy массива.
- Метод get() может использоваться для получения значения определенного свойства видеопотока, такого как ширина, высота, FPS (кадров в секунду) и общая длина видео. 
- Метод set() может использоваться для установки значения определенного свойства видеопотока.
- Объект VideoCapture должен быть освобожден с помощью метода release() после использования для освобождения используемых системой ресурсов.
- Метод destroyAllWindows() может быть использован для закрытия всех окон OpenCV.

Функция cv.VideoCapture() может использоваться в сочетании с другими функциями OpenCV для выполнения различных задач обработки видео, таких как изменение разрешения видео, извлечение кадров и сохранение видео.


>[!error]
>Ошибка 215 всегда означает, что функция не может найти изображение или видеокадр означает:
>cv2.error: OpenCV(4.9.0) D:\a\opencv-python\opencv-python\opencv\modules\highgui\src\window.cpp:971: error: (-215:Assertion failed) size.width>0 && size.height>0 in 
function 'cv::imshow'

## Масштабирование и изменение размеров изображений и видео, разрешения видео

`img.shape` возвращает информацию о размерах изображения, а именно кортеж включающий количество строк, столбцов и каналов (если изображение цветное). Например, если `img.shape` возвращает (100, 200, 3), это означает, что изображение имеет 100 строк, 200 столбцов и 3 канала (RGB), т.е. высота = 100 пикселям, ширина = 200 пикселям, число каналов = 3 канала (RGB).


`cv.resize()` используется для изменения размера изображения. Эта функция принимает два обязательных аргумента: изображение, которое необходимо изменить, и новый размер изображения.

```python
# функция которая будет сжимать изображение (уменьшать в размерах) в значение scale
# не работает для live-видео
def rescaleFrame(frame, scale=0.75):
    # уменьшаем размер изображения в scale-раз
    width = int(frame.shape[1] * scale)
    height = int(frame.shape[0] * scale)
    # создали новый кортеж с количеством столбцов и строк
    dimensions = (width, height)

    return cv.resize(frame, dimensions, interpolation=cv.INTER_AREA)
```

В `cv.resize(frame, dimensions, interpolation=cv.INTER_AREA)` изменяет размер изображения в переменной `frame` на новый размер, определенный в `dimensions`. Кроме того, функция принимает необязательный аргумент `interpolation`, который устанавливается по умолчанию на `cv.INTER_AREA`. Этот аргумент определяет метод интерполяции, который будет использоваться для изменения размера изображения. В данном случае, `cv.INTER_AREA` используется для ресайза изображения с сохранением пропорций. Этот метод подходит для ресайза изображений с сохранением их качества. Следовательно, `cv.resize(frame, dimensions, interpolation=cv.INTER_AREA)` изменяет размер изображения в переменной `frame` на новый размер, определенный в `dimensions`, с сохранением пропорций изображения.

### Изменение размера изображения

```python
import cv2 as cv

# функция которая будет сжимать изображение (уменьшать в размерах) в значение scale
def rescaleFrame(frame, scale=0.75):
    # уменьшаем размер изображения в scale-раз
    width = int(frame.shape[1] * scale)
    height = int(frame.shape[0] * scale)
    # создали новый кортеж с количеством столбцов и строк
    dimensions = (width, height)

    return cv.resize(frame, dimensions, interpolation=cv.INTER_AREA)

img = cv.imread('./photos/cat_large.jpg')
img_resized = rescaleFrame(img, 0.25)
cv.imshow('Cat', img)
cv.imshow('Cat_resized', img_resized)
cv.waitKey(0)
```

### Изменение размера кадров видео

```python
import cv2 as cv

# функция которая будет сжимать изображение (уменьшать в размерах) в значение scale
def rescaleFrame(frame, scale=0.75):
    # уменьшаем размер изображения в scale-раз
    width = int(frame.shape[1] * scale)
    height = int(frame.shape[0] * scale)
    # создали новый кортеж с количеством столбцов и строк
    dimensions = (width, height)

    return cv.resize(frame, dimensions, interpolation=cv.INTER_AREA)

capture = cv.VideoCapture('./videos/dog.mp4')

while True:
    # получаем каждый кадр (frame) видео и статус был ли он успешно получен(isTrue)
    isTrue, frame = capture.read()
    
    # если кадр не был получен, выходим из цикла
    if not isTrue:
        break

    frame_resized = rescaleFrame(frame, 0.3)

    # отображаем соответствующий кадр
    cv.imshow('Video', frame)
    # отображаем соответствующий кадр, изменённый в размере
    cv.imshow('Video_resized', frame_resized)

    # выходим из цикла если мы ждём 20 миллисекунд или при нажатии клавиши 'd'
    if cv.waitKey(20) & 0xFF==ord('d'):
        break
  
# освобождение ресурсов видеопотока после завершения цикла
capture.release()
# закрытие всех окон OpenCV после освобождения ресурсов видеопотока
cv.destroyAllWindows()
```


В OpenCV, `capture.set(3, width)` используется для установки новой ширины видеопотока. Здесь, `capture` представляет объект класса `cv2.VideoCapture()`, который используется для чтения видеопотока, а `3` - это код, который указывает на свойство ширины видеопотока. Аналогично для высоты.

```python
def changeRes(capture, width, height):
    # только для live-видео, например с видео с веб-камеры, не будет работать с видеофайлами, которые уже существуют
    capture.set(3, width)
    capture.set(4, height)
```

```python
def changeRes(width, height):
    # только для live-видео, например с видео с веб-камеры, не будет работать с видеофайлами, которые уже существуют
    capture.set(3, width)
    capture.set(4, height)

img = cv.imread('./photos/cat_large.jpg')

capture = cv.VideoCapture(0)

changeRes(480, 180)

while True:
    # получаем каждый кадр (frame) видео и статус был ли он успешно получен(isTrue)
    isTrue, frame = capture.read()
    # если кадр не был получен выходим из цикла
    if not isTrue:
        break

    # отображаем этот кадр
    cv.imshow('Video', frame)
    
    # выходим из цикла если мы ждём 20 миллисекунд или при нажатии клавиши 'd'
    if cv.waitKey(20) & 0xFF==ord('d'):
        break

# освобождение ресурсов видеопотока после завершения цикла
capture.release()
# закрытие всех окон OpenCV после освобождения ресурсов видеопотока
cv.destroyAllWindows()
```

## Рисование на изображениях (кадрах)

```python
import cv2 as cv
import numpy as np

# создаем трехмерный массив numpy размером 500x500x3, заполненный нулями
# тип данных массива - 'uint8', что означает, что значения в массиве будут 8-разрядными целыми числами без знака (от 0 до 255)
# этот массив может использоваться для представления цветного изображения с тремя каналами:
# красным, зеленым и синим (RGB). Каждый пиксель изображения представлен тройкой значений, по одному для каждого канала
# поскольку все значения изначально равны нулю, результирующее изображение будет полностью черным.
blank = np.zeros((500, 500, 3), dtype='uint8')
cv.imshow('Blank', blank)
cv.waitKey(0)
```

### 1. Раскрасим изображение в определённый цвет

```python
import cv2 as cv
import numpy as np

blank = np.zeros((500, 500, 3), dtype='uint8')
# 1. Раскрасить изображение в определённый цвет
blank[:] = 0,255,0
cv.imshow('Green', blank)
cv.waitKey(0)
```

![[Pasted image 20240416140758.png]]

### 2. Раскрасим прямоугольную область изображения высотой 100 пикселей и шириной 200 пикселей

```python
import cv2 as cv
import numpy as np

blank = np.zeros((500, 500, 3), dtype='uint8')
cv.imshow('Blank', blank)

  
# 2. Раскрасить изображение в определённый цвет
blank[200:300, 200:400] = 0,0,255
cv.imshow('Red rectangle', blank)

cv.waitKey(0)
```


![[Pasted image 20240416141107.png]]

### 3. Нарисуем прямоугольник с помощью метода `rectangle`

`rectangle(blank, (0,0), (250, 250), (0,255,0), thickness=2)` - данный метод рисует прямоугольник на изображении, представленном пустым массивом numpy (чёрном изображении). Прямоугольник определяется координатами его `верхнего левого угла (0,0)` и `нижнего правого угла (250,250)`, с зеленым `цветом (0,255,0)`, заданным в формате RGB, и `толщиной в 2 пикселя`.

У точек (0,0), (250, 250) - первый аргумент, координата по оси x (номер пикселя по оси x), второй аргумент, координата по оси y (номер пикселя по оси y).
_**Нумерация пикселей идёт слева-направо и сверху-вниз.**_

```python
import cv2 as cv
import numpy as np

blank = np.zeros((500, 500, 3), dtype='uint8')
cv.imshow('Blank', blank)

# 2. Прямоугольник
# thickness - толщина границы в пикселях
cv.rectangle(blank, (0,0), (250, 250), (0,255,0), thickness=2)
cv.imshow('Rectangle', blank)

cv.waitKey(0)
```

![[Pasted image 20240416141722.png]]

`thickness=cv.FILLED` заполняет указанную область, выбранным цветом (аналогично `thickness=-1`)
```python
cv.rectangle(blank, (0,0), (250, 250), (0,255,0), thickness=cv.FILLED)
cv.imshow('Rectangle', blank)
```

![[Pasted image 20240416142355.png]]

Создаём прямоугольник ширина и высота, которого в 2 раза меньше, чем у изображения
```python
cv.rectangle(blank, (0,0), (blank.shape[1]//2, blank.shape[0]//2), (0,255,0), thickness=-1)
cv.imshow('Rectangle', blank)
```

![[Pasted image 20240416142756.png]]

### 4. Нарисуем круг с помощью метода `circle`
`(blank.shape[1]//2, blank.shape[0]//2): Point` - координаты центра
`50: int` - длина радиуса
`(0,0,255): Scalar` - цвет
`thickness=2: int` - ширина границы

```python
cv.circle(blank, (blank.shape[1]//2, blank.shape[0]//2), 50, (0,0,255), thickness=2)
cv.imshow('Circle', blank)
```

![[Pasted image 20240416143422.png]]

### 5. Нарисуем линию с помощью метода `line`

`(0,0): Point` - координата начальной точки
`(blank.shape[1]//2, blank.shape[0]//2): Point` - координата финальной точки
`(255,255,255): Scalar` - цвет 
`thickness=2: int` - ширина линии

```python
cv.line(blank, (0,0), (blank.shape[1]//2, blank.shape[0]//2), (255,255,255), thickness=2)
cv.imshow('Line', blank)
```

![[Pasted image 20240416231214.png]]

### 6. Отображение текста на картинке

`'Test text': str` - текст, который надо отобразить
`(225, 225): Point` - точка где начинается текст
`fontFace: int` - шрифт текста
`1.0: float` - масштаб шрифта
`(0,255,0): Scalar` - цвет
`2: int` - вес шрифта

```python
cv.putText(blank, 'Test text', (225, 225), cv.FONT_HERSHEY_TRIPLEX, 1.0, (0,255,0), 2)
cv.imshow('Text', blank)
```

![[Pasted image 20240416231850.png]]

## Основные функции

### 1. Преобразование изображения в оттенки серого

```python
gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
cv.imshow('Gray', gray)
```

![[Pasted image 20240416233053.png]]

### 2. Размытие изображения (размытие по гауссу)

Малый эффект размытия применяется для удаления шумов с изображения.

Фильтр размытия по Гауссу работает путем замены каждого пикселя на изображении средневзвешенным значением соседних пикселей, где веса определяются распределением по Гауссу. Это приводит к сглаживанию изображения и уменьшению высокочастотного шума. Размер ядра размытия (в данном случае 7x7) определяет размер окрестности, который используется для вычисления средневзвешенного значения. Больший размер ядра приведет к более выраженному эффекту размытия, в то время как меньший размер ядра сохранит больше деталей на изображении.

`border type = (cv.BORDER_DEFAULT)` указывает, как фильтр размытия должен обрабатывать пиксели, выходящие за границы изображения. Параметр cv.BORDER_DEFAULT использует пограничный режим по умолчанию, который эквивалентен cv.BORDER_REFLECT_101 для большинства функций OpenCV. Это означает, что граничные пиксели зеркально отражены, так что граничный пиксель слева от изображения совпадает с крайним вторым слева пикселем на изображении

``` python
# ksize = (7, 7) - нечётные числа
blur = cv.GaussianBlur(img, (7, 7), cv.BORDER_DEFAULT)
cv.imshow('Blur', blur)
```

### 3. Краевой каскад (Edge cascade) (обнаружение краёв)

Алгоритм обнаружения краев _**Canny**_ - широко используемый алгоритм обнаружения краев в компьютерном зрении. Алгоритм включает в себя несколько шагов для обнаружения краев на изображении, включая подавление шума, вычисление градиента, не максимальное подавление и установление порога гистерезиса.

В OpenCV алгоритм обнаружения границ Canny реализован с использованием функции cv.Canny. Функция принимает четыре параметра: входное изображение `image`, нижнее `threshold1` и верхнее `threshold2` пороговые значения для определения порога гистерезиса и необязательный параметр для размера диафрагмы фильтра Собеля `aperture size`.

Нижний `threshold1` и верхний `threshold2` пороговые значения используются для определения того, какие пиксели на изображении считаются краями. Пиксели с величиной градиента выше верхнего порога считаются сильными границами, в то время как пиксели с величиной градиента ниже нижнего порога считаются не краями. Пиксели с величиной градиента между двумя пороговыми значениями считаются слабыми краями и включаются в конечную карту краев только в том случае, если они соединены с сильными краями.

Параметр `aperture size` определяет размер фильтра Собеля, используемого для расчета величины градиента. Больший размер `aperture` приведет к более сглаженному градиенту, в то время как меньший размер `aperture` приведет к более детальному градиенту.

```python
canny = cv.Canny(img, 125, 175)
cv.imshow('Canny', canny)
```

![[Pasted image 20240416235544.png]]

Алгоритм обнаружения краев Canny - мощный инструмент для обнаружения краев на изображениях, но он может быть чувствителен к шуму и другим факторам, которые могут повлиять на расчет градиента. Поэтому часто рекомендуется применять _**методы шумоподавления, такие как размытие по Гауссу**_, прежде чем применять алгоритм обнаружения краев Canny. 

```python
blur = cv.GaussianBlur(img, (5, 5), cv.BORDER_DEFAULT)
cv.imshow('Blur', blur)

canny = cv.Canny(blur, 125, 175)
cv.imshow('Canny', canny)
```

![[Pasted image 20240417000557.png]]

### 4. Расширение изображения (используя полученные края)

Функция cv.dilate в OpenCV используется для применения операции расширения к изображению. Расширение - это морфологическая операция, которая расширяет границы ярких областей изображения путем добавления слоя пикселей вокруг них. Эта операция может быть полезна для закрытия небольших промежутков между яркими областями, увеличения размера ярких областей или усиления контраста между светлыми и темными областями.

Функция cv.dilate принимает три параметра: входное изображение `src`, ядро `kernel` для определения формы структурирующего элемента, используемого для расширения, и количество итераций `iterations` для выполнения операции расширения. Количество итераций `iterations` означает, что операция расширения будет выполнена `iterations` раз, при этом выходные данные каждой итерации становятся входными данными для следующей итерации.

Размер ядра и количество итераций могут повлиять на результат операции расширения. Большее ядро или большее количество итераций приведет к более выраженному эффекту расширения, в то время как меньшее ядро или меньшее количество итераций приведет к более тонкому эффекту.

```python
canny = cv.Canny(blur, 125, 175)
cv.imshow('Canny', canny)

# Расширение изображения используя полученные края
dilated = cv.dilate(canny, (7, 7), iterations=3)
cv.imshow('Dilated', dilated)
```

![[Pasted image 20240417004606.png]]

### 5. Эрозия

Функция cv.erode в OpenCV используется для применения операции эрозии к изображению. Эрозия - это морфологическая операция, которая уменьшает границы ярких областей изображения путем удаления слоя пикселей вокруг них. Эта операция может быть полезна для удаления небольших ярких областей, уменьшения размера ярких областей или усиления контраста между яркими и темными областями.

Функция cv.erode принимает три параметра: входное изображение `src`, ядро `kernel` для определения формы структурирующего элемента, используемого для эрозии, и количество итераций `iterations` для выполнения операции эрозии. Количество итераций `iterations` означает, что операция расширения будет выполнена `iterations` раз, при этом выходные данные каждой итерации становятся входными данными для следующей итерации. Размер ядра и количество итераций могут повлиять на результат операции удаления. Большее ядро или большее количество итераций приведет к более выраженному эффекту эрозии, в то время как меньшее ядро или меньшее количество итераций приведет к более незаметному эффекту.

С помощью эрозии из расширенного изображения можно вернуть почти начальный edge casade (при условии, что аргументы `kernel` и `iterations` одинаковы в функциях `dilate` и `erode`).

```python
# Расширение изображения используя полученные края
dilated = cv.dilate(canny, (7, 7), iterations=3)
cv.imshow('Dilated', dilated)

# Эрозия
eroded = cv.erode(dilated, (7, 7), iterations=3)
cv.imshow('Eroded', eroded)
```

![[Pasted image 20240417005144.png]]

### 6. Изменение размера изображений

У метода `cv.resize` по умолчанию аргумент `interpolation = cv.INTER_AREA`, это полезно при уменьшении размера изображения, но при увеличении нужно использовать либо `INTER_LINEAR`, либо `INTER_CUBIC`. `INTER_CUBIC` - самый медленный из всех, но выдаёт лучший результат (высокое качество полученного изображения).

```python
# Изменение размера изображения
# по умолчанию аргумент interpolation = cv.INTER_AREA
resized = cv.resize(img, (500, 500))
resized_large = cv.resize(img, (900, 800), interpolation=cv.INTER_LINEAR)
cv.imshow('Resized', resized)
cv.imshow('Resized large', resized_large)
```

![[Pasted image 20240417011232.png]]

### 7. Обрезка изображений

```python
# указываем сначала левый верхний/нижний пиксель, затем правый верхний/нижний пиксель
cropped = img[50:200, 200:400]
cv.imshow('Cropped', cropped)
```

![[Pasted image 20240417011551.png]]

## Трансформация (преобразование) изображений

### 1. Трансляция изображения
Трансляция - сдвиг изображения по оси x и y.

Функция `cv.warpAffine(img, transMat, dimensions)` в OpenCV используется для трансляции изображений. Она применяет аффинное преобразование к изображению, в частности перевод, который сдвигает изображение на заданное количество пикселей в горизонтальном и вертикальном направлениях. Параметры функции следующие:
`img`: входное изображение, подлежащее переводу.
`transMat`: матрица преобразования, определяющая перевод. Это матрица 2x3, которая включает значения перевода. 
`dimensions`: Размеры выходного изображения после трансляции обычно указываются как ширина и высота изображения. Используя эту функцию, вы можете эффективно перемещать изображение в любом направлении, предоставляя соответствующую матрицу перевода

```python
import cv2 as cv
import numpy as np

img = cv.imread('./photos/park.jpg')
cv.imshow('Boston', img)

# translation
def translate(img, x, y):
    transMat = np.float32([[1,0,x], [0,1,y]]) # создаём матрицу преобразования (transMat). Эта матрица будет использоваться для преобразования изображения
    dimensions = (img.shape[1], img.shape[0])  # определяем размеры изображения
    return cv.warpAffine(img, transMat, dimensions)

# -x --> сдвиг влево
# -y --> сдвиг вверх
# x --> сдвиг вправо
# y --> сдвиг вниз

translated = translate(img, -100, -100)

cv.imshow('translated', translated)

cv.waitKey(0)
```

![[Pasted image 20240423140320.png]]

###  2. Поворот изображения

Можно указать любую точку вращения

Функция `getRotationMatrix2D` в OpenCV используется для создания матрицы вращения, которая может использоваться для поворота изображения или набора точек в 2D-пространстве. Функция принимает три параметра:
`center`: центр поворота, указанный как набор из двух значений (x, y).
`angle`: угол поворота, указанный в градусах.
`scale`: коэффициент масштаба, который определяет, насколько изображение или точки должны быть масштабированы во время поворота

``` python
# rotation
def rotate(img, angle, rotPoint=None):
    (height, width) = img.shape[:2]

    if rotPoint is None:
        rotPoint = (width // 2, height // 2)

    rotMat = cv.getRotationMatrix2D(rotPoint, angle, 1.0)
    dimensions = (width, height)

    return cv.warpAffine(img, rotMat, dimensions)

# -angle - поворот по часовой стрелке
# angle - поворот против часовой стрелки

rotated = rotate(img, -45)

cv.imshow('rotated', rotated)
```

![[Pasted image 20240423140619.png]]

При большем повороте уже "повёрнутого" изображения углы будут просто срезаться

```python
rotated_rotated = rotate(rotated, -45)
cv.imshow('rotated_rotated', rotated_rotated)
```

![[Pasted image 20240423140949.png]]

###  3. Изменение размера изображения

Функция `cv.resize()` в OpenCV используется для изменения размера изображения до указанной ширины и высоты. Функция принимает три параметра:
`img`: входное изображение, размер которого необходимо изменить.
`dsize`: желаемый размер выходного изображения, указанный как набор из двух значений (ширина, высота).
`interpolation`: метод интерполяции, используемый для изменения размера изображения. Параметр interpolation определяет метод, используемый для интерполяции значений пикселей при изменении размера изображения. Доступные опции в OpenCV:
`cv.INTER_NEAREST`: интерполяция по ближайшему соседу. Это самый быстрый метод, но он может привести к образованию неровных краев и может не подходить для увеличения размера изображений.
`cv.INTER_LINEAR`: билинейная интерполяция. Этот метод создает более плавные края, чем интерполяция по ближайшему соседу, но он все равно может создавать некоторые артефакты.
`cv.INTER_AREA`: интерполяция на основе области. Этот метод используется для уменьшения дискретизации изображения и предназначен для сохранения общей формы и размера изображения. 
`cv.INTER_CUBIC`: бикубическая интерполяция. Этот метод дает результаты высочайшего качества, но он также и самый медленный. 
`cv.INTER_LANCZOS4`: интерполяция Ланцоша. Этот метод аналогичен бикубической интерполяции, но в нем используется более сложное ядро интерполяции.

```python
resized = cv.resize(img, (500, 500), interpolation=cv.INTER_CUBIC)
cv.imshow('resized', resized)
```

![[Pasted image 20240423141635.png]]
![[Pasted image 20240423141650.png]]

###  4. Переворачивание изображения

Функция `cv.flip` в OpenCV используется для переворачивания 2D-массива, такого как изображение, вокруг вертикальной, горизонтальной или обеих осей. Функция `cv.flip` переворачивает массив на основе указанного `flipCode`.

`flipCode: 0` - переворачивание по вертикали
`flipCode: 1` - переворачивание по горизонтали
`flipCode: -1` - переворачивание как по горизонтали, так и по вертикали

```python
flip = cv.flip(img, 0)
cv.imshow('flip', flip)
```

![[Pasted image 20240423142347.png]]

```python
flip = cv.flip(img, 1)
cv.imshow('flip', flip)
```

![[Pasted image 20240423142549.png]]

```python
flip = cv.flip(img, -1)
cv.imshow('flip', flip)
```

![[Pasted image 20240423142649.png]]

###  4. Обрезка изображения

```python
cropped = img[200:400, 300:400]
# 200:400 - первая точка обрезки
# 300:400 - вторая точка обрезки
cv.imshow('cropped', cropped)
```

![[Pasted image 20240423142939.png]]