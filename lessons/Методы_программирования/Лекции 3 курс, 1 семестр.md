# ЛЕКЦИЯ № 1 06.09.2022

## Структура данных. Основные виды структуры данных

**Структура данных** – это контейнер, который хранит данные в определенном макете. Этот макет позволяет структуре данных быть эффективной в некоторых операциях и неэффективной в других.

Виды:
1) _Линейные_ – элементы образуют последовательность или линейный список, обход узлов линеен. Примеры: Массивы, Связанный список, стеки и очереди.
2) _Нелинейные_ - если обход узлов нелинейный, в данные не последовательны. Пример: граф и деревья

**Основные структуры данных**
1) Массивы
2) Стеки
3) Очереди
4) Связанные списки
5) Графы
6) Деревья
7) Префиксные деревья
8) Хэш таблицы

**Массивы**
_Массив_ – это самая простая и широко используемая структура данных. другие структуры данных, такие как стеки и очереди являются производными от массивов.
Каждому элементу данных присваивается числовое значение (индекс), который соответствует позиции элемента в массиве. Большинство языков определяют начальный индекс массива как 0.
Бывают одномерные и двумерные массивы.

**Вопросы:**
1)     Найти второй минимальный элемент массива
2)     Первые неповторяющиеся целые числа в массиве
3)     Объединить два отсортированных массива
4)     Изменение порядка положительных и отрицательных значений в массиве

**Стеки**

_Стек_ – абстрактный тип данных, представляющий собой список элементов, организованных по принципу **LIFO** (последний пришел, первый вышел)
Примером стека может быть куча книг, расположенных в вертикальном порядке. Для того чтобы получить книгу, которая где-то посередине, вам нужно будет удалить все книги, размещенные на ней.

**Основные операции:**
1) Push – вставляет элемент сверху
2) Pop – возвращает верхний элемент после удаления из стека
3) InEmpty – возвращает true, если стек пуст
4) Top – возвращает верхний элемент без удаления из стека

**Вопросы:**
1) Реализовать очередь с помощью стека
2) Сортировка значений в стеке
3) Реализация двух стеков в массиве

**Очереди**
Подобно стекам, _очередь_ – хранит элемент последовательным образом. Существенное отличие от стека использование FIFO

Пример очереди – очередь людей. Последний занял последним и будешь, а первый первым ее и покинет.

Основные операции
1)     Enqueue () – вставляет элемент в конец очереди
2)     Dequeue () – удалет элемент из начала очереди
3)     isEmpty () – возвращает значение true, если очередь пуста
4)     Top () – возвращает первый элемент очереди

Вопросы:
1)     Реализовать стек с помощью очереди
``` python
from random import randint
from collections import deque
my_list = deque()
for i in range(10):
    my_list.append(randint(0,10))
print(my_list)
my_list.appendleft(my_list.pop())
print(my_list)
```
2)     Реверс первых N элементов очереди
``` python
from random import randint
my_list = [randint(0, 10) for i in range(10)]
n = int(input())
new_list = list()
print(my_list)
for i in range(n):
    new_list.append(my_list.pop(0))
new_list.reverse()
new_list.extend(my_list)
print(new_list)
```
3)     Генерация двоичных чисел от 1 до N с помощью очереди
``` python
from collections import deque
from random import randint
queue = deque()
n = int(input())
q = deque()
q.append('1')
# запускается `n` раз
for i in range(n):
    # снять передний элемент
    front = str(q.popleft())
    # добавляет 0 и 1 к первому элементу queue и
    # ставит в queue обе строки
    q.append(front + '0')
    q.append(front + '1')
    # печать переднего элемента
print(q)
```

Д/з – рассказать про Дек

# ЛЕКЦИЯ № 2 13.09.2022

**Связанный список**

Связанный список – массив, где каждый элемент является отдельным объектом из двух элементов – данных и ссылки на следующий узел.
Принципиальным преимуществом перед массивом является структурная гибкость элементом связного списка может не совпадать с порядком расположения элементов в памяти компьютера, а порядок обхода списка всегда явно задаётся его внутренними связями.
Бывают:
1.     **Однонаправленный** - каждый узел хранит адрес или ссылку на следующий узел в списке, и последний узел имеет следующий адрес или ссылку как NULL.
1 -> 2 -> 3 -> 4 -> NULL
2.     **Двунаправленный** - две ссылки, связанные с каждым узлом, одним из опорных пунктов на следующий узел и один к предыдущему узлу.
NULL <-> 1 <-> 2 <-> 3 <-> NULL
Связные списки кардинально отличаются от обычных массивов на программном уровне
3.     **Круговой** - все узлы соединяются, образуя круг. В конце нет NULL. Циклический список может быть одно- или двукратным циклическим связанным списком.
1 -> 2 -> 3 -> 1

Самое частое, линейный однонаправленный список. Пример – файловая система.

Основные операции:
·       InsertAtAnd – вставка заданного элемента в конец списка
·       InsertArHead – вставка элемента в начало списка
·       Delete – удаляет заданный элемент из списка
·       DeleteAtHead – удаляет первый элемент списка
·       Search – возвращает заданный элемент из списка
·       isEmpty – возвращает True, если связанный список пуст

Вопросы:
1.     Реверс связанного списка
``` python
class Node:
    """Linked list is either None or a value and a link to the next list."""
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
head = Node(1, Node(2, Node(3, Node(4))))
def print_list(head, end='\n'):
    while head:
        print(head.data, end=' -> ' if head.next else '')
        head = head.next
    print(end=end)
print_list(head)
def reverse_list(head, tail=None):
    while head:
        head.next, tail, head = tail, head, head.next
    return tail
```
2.     Определение цикла в связанном списке
``` python
from linked_list import Node, LinkedList
node1 =  Node(5)
node2 =  Node(6)
node3 =  Node(7)
node4 =  Node(8)
node5 =  Node(9)
ll = LinkedList()
ll.insert_back(node1)
ll.insert_back(node2)
ll.insert_back(node3)
ll.insert_back(node4)
ll.insert_back(node5)
node5.next = node3
addresses = {}
temp_node = node1
while (temp_node):
   address = id(temp_node)
   print(address)
   if address not in addresses:
       addresses[address] = 1
   else:
       print('cycle in a linked list')
       print(temp_node.data)
       break
   temp_node = temp_node.next
```
3.     Возврат N элемента из конца в связанном списке
``` python
from llist import dllist, dllistnode
lst = dllist([1, 2, 3])
print(lst.nodeat(len(lst) - n))
Задание 4 Удаление дубликатов из связанного списка
for i in range(lst):
    for j in range(lst):
        if lst.nodeat(i) == lst.nodeat(j):
            lst.remove(j)
```
4.     Удаление дубликатов из связанного списка
``` python
from structlinks.DataStructures import DoublyLinkedList
from random import randint
lst = DoublyLinkedList()
new_lst = DoublyLinkedList()  
for i in range(5):
    lst.append(randint(0,10))
new_lst.extend(lst)
new_lst.invert()
print(lst)
print(new_lst)
n=int(input())
print(lst[len(lst) - n])
lst2 = DoublyLinkedList([1,2,3,1,4,5,3,3])
print(lst2)
lst2 = DoublyLinkedList(set(lst2))
print (lst2)
```

# ЛЕКЦИЯ № 3 21.09.2022
``` python
from random import randint  
from collections import deque  
def realize_stek():  
    my_list = [randint(0,10) for i in range(10)]    print(my_list)  
    new_list = [my_list[-1]]  
    new_list.extend(my_list[:len(my_list) -1])    print(new_list)  
def rev_n_elem(n):  
    lis = [randint(0, 10) for i in range(10)]  
    new_lis = []    print(lis)    for i in range(n):  
        new_lis.append(lis.pop(0))  
    new_lis.reverse()  
    new_lis.extend(lis)    print(new_lis)  
def gen_bin_q(n):  
    q = deque()  
    q.append('1')    for i in range(n):  
        front = str(q.popleft())  
        q.append(front + '0')  
        q.append(front + '1')
        print(front, end = ' ')  
gen_bin_q(100000)
```


# ЛЕКЦИЯ № 4 27.09.2022

## Стратегия скользящего окна для алгоритмов решения

Метод скользящего окна – алгоритм трансформации, позволяющий сформировать членов временного ряда набор данных, который может служить обучающим множеством для построения модели прогнозирования.
Под окном в данном случае понимается временной интервал, содержащий набор значений, которые используются для формирования обучающего примера. В процессе работы алгоритма окно смещается по временной последовательности на единицу наблюдения, и каждое положение окна образует один пример.
Например, если еженедельно поступают данные о продажах в течение 50 недель и установлено окно в 5 недель, то в первом примере используются данные с 1 по 5 неделю, а целевым значением будут данные за 6-ю неделю. Во втором случае используются данные со 2 по 6 неделю, а в качестве целевого значения берутся данные за 7-ю неделю и т.д.
Обработка данных методом скользящего окна применяется при предварительной обработке данных в задачах прогнозирования, когда на вход анализатора (например, нейронной сети) требуется подавать значения нескольких смежных отсчётов исходного набора данных. Термин скользящее окно отражает сущность обработки – выделяется некоторый непрерывный отрезок данных, называемый окном, а окно, в свою очередь, перемещается, «скользит» по всему исходному набору данных.
В результате будет получен набор данных, где в одном поле будет содержаться значение, соответствующее текущему отсчёту (оно будет иметь то же имя, что и в исходном наборе), а слева и справа от него будут расположены поля со значениями, смещёнными от текущего отсчёта в прошлое и в будущее соответственно.

# Лекция 5 4.10.2022
Графы — это абстрактный способ представления типов отношений, например дорог, соединяющих города, и других видов сетей. Граф – **совокупность точек, соединенных линиями**. Точки называются вершинами, или узлами, а линии – ребрами, или дугами. Степень входа вершины – количество входящих в нее ребер, степень выхода – количество исходящих ребер.

Вот список всех терминов, относящихся к теории графов, которые вам нужно знать:
- **путь** — последовательность рёбер, соединяющая разные (неповторяющиеся) вершины;
- **маршруты** — это те же пути, только они не требуют последовательности разных вершин;
- **цикл** — группа вершин, связанных вместе в замкнутую цепь. На рисунке выше вершины [1,2,4] составляют цикл;
- **связный граф** — граф, в котором между любой парой вершин имеется один путь;
- **дерево** — связный граф, не содержащий цикла;
- **неориентированный граф** — граф, в котором рёбра не имеют направления. На рисунке выше показан как раз неориентированный граф. В таком неориентированном графе можно перемещаться вдоль ребра в любом из двух направлений;
- **ориентированный граф** — граф, в котором рёбра имеют направления и обозначаются стрелками. В таком ориентированном графе можно перемещаться вдоль ребра только в указанном направлении.

# Лекция 5  
  
## Матрицы смежности
_Матрица смежности_ — один из способов представления графа в виде матрицы.
Матрица смежности представляет собой граф в виде двумерной матрицы с размерами V x V, где V — количество вершин графа. Матрицы смежности огнём лучше всего применять, когда V² примерно равно E (числу рёбер), то есть когда граф плотный. Запись a_ij обозначает, сколько рёбер соединяют вершину i и вершину j.

![[Pasted image 20221018143907.png]]

Код:    
Следующий код используется для создания матрицы смежности неориентированного графа. Чтобы код создавал матрицу смежности для ориентированного графа, измените функцию add_edge, удалив вторую строку внутри неё: matrix[v][u] = 1;  
``` python
n, m = map(int, input().split())
adj = [[0]*n for _ in range(n)]
 
for it in range(m):
    r, c = map(int, input().split())
    adj[r-1][c-1] = adj[c-1][r-1] = 1
 
print(adj)
```
**Списки смежности**
Список смежности — **один из способов представления графа в виде коллекции списков вершин**. Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

Другой распространенный способ представления графов в коде — списки смежности. Суть в том, что вы создаёте списки соседей для каждой вершины, а затем помещаете все эти списки в другой список. Их лучше всего применять, когда в графе небольшое количество рёбер, то есть когда граф разрежённый. Если у вас взвешенный граф, т.е. каждое ребро графа имеет какой-то вес, то в списке будут содержаться пары для рёбер (сосед, вес).  
  
Код:  
``` python
1.  graph = {'A': set(['B', 'C']),
2.           'B': set(['A', 'D', 'E']),
3.           'C': set(['A', 'F']),
4.           'D': set(['B']),
5.           'E': set(['B', 'F']),
6.           'F': set(['C', 'E'])}
```

``` c++
#include<bits/stdc++.h>using namespace std;void addEdge(vector<int> adj[], int u, int v){  
adj[u].push_back(v);  
adj[v].push_back(u);//удаляем эту строку для ориентированных графов  
}int main(){  
int v = 5; //5 вершин  
vector<int> adj[v];  
addEdge(adj, 0, 1);  
addEdge(adj, 0, 4);  
addEdge(adj, 1, 2);  
addEdge(adj, 1, 3);  
addEdge(adj, 1, 4);  
addEdge(adj, 2, 3);  
addEdge(adj, 3, 4);  
}
```
  
**Поиск в глубину**
Теперь, когда мы научились представлять графы в коде, можем приступить к изучению некоторых алгоритмов на графах! Начнём с поиска в глубину (DFS) и завершим поиском в ширину (BFS). Чтобы не загромождать статью, алгоритмы поиска пути не будут здесь рассматриваться (интересующиеся могут ознакомиться с алгоритмом поиска кратчайшего пути Беллмана-Форда).  
  
Поиск в глубину — это один из базовых алгоритмов на графах. Он применяется для поиска расстояния от одной вершины до других вершин в графе. Это алгоритм обхода.  
  
Поиск в глубину помечает каждую вершину в графе одной из двух меток: посещённая или не посещённая. Алгоритм помечает каждую вершину как посещённую, если удаётся избежать циклов. Он работает следующим образом:  
1. Помещаем любую из вершин графа на стек.  
2. Берём элемент со стека и добавляем его в список посещённых.  
3. Создаём список соседей этой вершины. Добавляем в стек те, что не находятся в списке посещённых.  
4. Повторяем 2 и 3 пункты, пока стек не опустеет.
![[Pasted image 20221018144025.png]]

Код:  
``` js  
// при условии, что мы имеем дело со смежным списком
// например, таким: adj = {A: [B,C], B:[D,F], ... }
function dfs(adj, v, t) {
    // adj - смежный список
    // v - посещенный узел (вершина)
    // t - пункт назначения
    // это общие случаи
    // либо достигли пункта назначения, либо уже посещали узел
    if(v === t) return true
    if(v.visited) return false
    // помечаем узел как посещенный
    v.visited = true
    // исследуем всех соседей (ближайшие соседние вершины) v
    for(let neighbor of adj[v]) {
        // если сосед не посещался
        if(!neighbor.visited) {
            // двигаемся по пути и проверяем, не достигли ли мы пункта назначения
            let reached = dfs(adj, neighbor, t)
            // возвращаем true, если достигли
            if(reached) return true
        }
    }
    // если от v до t добраться невозможно
    return false
}
```
Поиск в ширину  
Поиск в ширину —  ещё один алгоритм обхода графов. Вместе с алгоритмом поиска вглубь он составит большую часть увлекательных соревнований по программированию, по крайней мере, тех из них, что относятся к графам.  
  
Поиск в ширину тоже помещает каждую вершину в графе в одну из двух категорий: посещённых или непосещённых. И цель у обоих алгоритмов одна и та же: помечать каждую вершину в графе как посещённую, если удаётся избежать циклов. Вот как работает алгоритм поиска в ширину:  
  
Помещаем любую вершину в графе в конец очереди.  
Берём элемент в начале очереди и добавляем его в список посещённых.  
Создаём список соседей этой вершины. Добавляем в конец очереди непосещённые.  
Повторяем 2 и 3 пункты, пока очередь не опустеет.  
Как видите, алгоритм поиска в ширину очень похож на алгоритм поиска в глубину. Однако вместо того, чтобы спускаться вниз по ветви графа или дерева, как это делает алгоритм поиска в глубину, алгоритм поиска в ширину проходит каждый уровень.  
``` js
// при условии, что мы имеем дело со смежным списком
// например, таким: adj = {A:[B,C,D], B:[E,F], ... }
function bfs(adj, s, t) {
    // adj - смежный список
    // s - начальная вершина
    // t - пункт назначения
    // инициализируем очередь
    let queue = []
    // добавляем s в очередь
    queue.push(s)
    // помечаем s как посещенную вершину во избежание повторного добавления в очередь
    s.visited = true
    while(queue.length > 0) {
        // удаляем первый (верхний) элемент из очереди
        let v = queue.shift()
        // abj[v] - соседи v
        for(let neighbor of adj[v]) {
            // если сосед не посещался
            if(!neighbor.visited) {
                // добавляем его в очередь
                queue.push(neighbor)
                // помечаем вершину как посещенную
                neighbor.visited = true
                // если сосед является пунктом назначения, мы победили
                if(neighbor === t) return true
            }
        }
    }
    // если t не обнаружено, значит пункта назначения достичь невозможно
    return false
}
```
дз: аглоритмы обхода в глубину/ширину код

# Лекция 6

## Основные термины

**Дерево** — это связный, ациклический граф.

**Дерево** — это, по сути, один из частных случаев графа. Древовидная модель может быть весьма эффективна в случае представления динамических данных, особенно тогда, когда у разработчика стоит цель быстрого поиска информации, в тех же базах данных, к примеру. Еще **древом** называют структуру данных, которая представляет собой совокупность элементов, а также отношений между этими элементами, что вместе образует **иерархическую древовидную структуру**.
![](https://otus.ru/journal/wp-content/uploads/2021/02/Screenshot_1-4.png)

Каждый элемент — это вершина или **узел** дерева. Узлы, соединенные направленными дугами, называются **ветвями**. Начальный узел — это **корень** дерева (корневой узел). **Листья** — это узлы, в которые входит 1 ветвь, причем не выходит ни одной.
Общую терминологию можно посмотреть на левой и правой части картинки ниже:
![](https://otus.ru/journal/wp-content/uploads/2021/02/Screenshot_2-3.png)

Какие **свойства** есть у каждого древа:
- существует узел, в который не входит ни одна ветвь;
- в каждый узел, кроме корневого узла, входит 1 ветвь.

На практике деревья нередко применяют, изображая различные иерархии. Очень популярны, к примеру, генеалогические древа — они хорошо известны. Все узлы с ветвями, исходящими из единой общей вершины, являются потомками, а сама вершина называется предком (родительским узлом). Корневой узел не имеет предков, а листья не имеют потомков.
Также у дерева есть **высота (глубина)**. Она определяется числом уровней, на которых располагаются узлы дерева. Глубина пустого древа равняется нулю, а если  речь идет о дереве из одного корня, тогда единице. В данном случае на нулевом уровне может быть лишь одна вершина – корень, на 1-м – потомки корня, на 2-м – потомки потомков корня и т. д..

Ниже изображен графический вывод древа с 4-мя уровнями (дерево имеет глубину, равную четырем):
![](https://otus.ru/journal/wp-content/uploads/2021/02/Screenshot_3-3.png)

**Поддеревом** называют часть древообразной структуры, которую можно представить в виде отдельного дерева.
Древо может быть **упорядоченным** — в данном случае ветви, которые исходят из каждого узла, упорядочены по некоторому критерию.
***Степень вершины*** в древе — это число ветвей (дуг), выходящих из этой вершины. Степень равняется максимальной степени вершины, которая входит в дерево. В этом случае листьями будут узлы, имеющие нулевую степень. По величине степени деревья бывают:  
— двоичные (степень не больше двух);
— сильноветвящиеся (степень больше двух).

Деревья — это **рекурсивные структуры**, ведь каждое поддерево тоже является деревом. Каждый элемент такой рекурсивной структуры является или пустой структурой, или компонентом, с которым связано конечное количество поддеревьев.
Когда мы говорим о рекурсивных структурах, то действия с ними удобнее описывать посредством рекурсивных алгоритмов.

## Обход древа
Чтобы выполнить конкретную операцию над всеми вершинами, надо все эти узлы просмотреть.  Данную задачу называют **обходом дерева**. То есть обход представляет собой упорядоченную последовательность узлов, в которой каждый узел встречается лишь один раз.
В процессе обхода все узлы должны посещаться в некотором, заранее определенном порядке. Есть ряд способов обхода, вот три основные:
- прямой (префиксный, preorder);
- симметричный (инфиксный, inorder);
- обратный (постфиксный, postorder).

Существует много древовидных структур данных: двоичные (бинарные), красно-черные, В-деревья, матричные, смешанные и пр. Поговорим о бинарных.

## Бинарные (двоичные) деревья
Бинарные имеют степень не более двух. То есть двоичным древом можно назвать динамическую структуру данных, где каждый узел имеет не большое 2-х потомков. В результате двоичное дерево состоит из элементов, где каждый из элементов содержит информационное поле, а также не больше 2-х ссылок на различные поддеревья. На каждый элемент древа есть только одна ссылка.
![](https://otus.ru/journal/wp-content/uploads/2021/02/Screenshot_4-1.png)

У бинарного древа каждый текущий узел — это структура, которая состоит из 4-х видов полей. Какие это поля:
— информационное (ключ вершины);
— служебное (включена вспомогательная информация, однако таких полей может быть несколько, а может и не быть вовсе);
— указатель на правое поддерево;
— указатель на левое поддерево.
Самый удобный вид бинарного древа — бинарное дерево поиска.

ДЗ: типы рекурсивных алгоритмов.
Виды рекурсивных алгоритмов:
-   **рекурсивная** формула;
-   **рекурсивная** функция;
-   **рекурсивная** последовательность;
-   **рекурсивный алгоритм**;
-   **рекурсивная** программа;
-   **рекурсивное** изображение.

# Лекция 7

## Алгоритмы сортировки

### Алгоритм кучи
Одно из наиболее известных применений кучи — сортировка при помощи кучи или пирамидальная сортировка (англ. heapsort). В данной сортировке из элементов списка снача строится куча, потом элементы по одному удаляются из кучи — сначала наибольший элемент, потом - наибольший из оставшихся и т. д. При этом кучу можно хранить там же, где хранятся элементы самого списка, тем самым пирамидальная сортировка имеет сложность O(nlog⁡n), но при этом не требует дополнительной памяти (как сортировка слиянием) и не является вероятностной (как быстрая сортировка Хоара). Также при помощи кучи можно организовать структуру данных «очередь с приоритетами». В очереди каждому элементу сопоставляется приоритет — некоторое целое число. При удалении элемента из очереди удаляется не тот элемент, который был добавлен раньше (как в обычной очереди), а элемент с наибольшим приоритетом. То есть элементы в очереди с приоритетами можно хранить в куче, сравнивая их при этом по приоритету.  
  
В очереди с приоритетами также есть операция изменения приоритета элемента. Для этого реализованы две функции — повышения и понижения приоритета. При повышении приоритета элемент поднимается вверх, поэтому эта функция реализована аналогично операции добавления элемента. При понижении приоритета элемент спускается вниз, как в операции удаления элемента.

### Двоичная куча
Двоичная куча (binary heap) – просто реализуемая структура данных, позволяющая быстро (за логарифмическое время) добавлять элементы и извлекать элемент с максимальным приоритетом (например, максимальный по значению).  

Двоичная куча представляет собой полное бинарное дерево, для которого выполняется _основное свойство кучи_: приоритет каждой вершины больше приоритетов её потомков. В простейшем случае приоритет каждой вершины можно считать равным её значению. В таком случае структура называется _max-heap_, поскольку корень поддерева является максимумом из значений элементов поддерева. В этой статье для простоты используется именно такое представление. Напомню также, что дерево называется _полным бинарным_, если у каждой вершины есть не более двух потомков, а заполнение уровней вершин идет сверху вниз (в пределах одного уровня – слева направо).
![[daaefbcebe7ff642c26088a2415b5b0b.png]]

Таким образом, двоичная куча имеет структуру дерева логарифмической высоты (относительно количества вершин), позволяет за логарифмическое же время добавлять элементы и извлекать элемент с максимальным приоритетом за константное время. В то же время двоичная куча проста в реализации и не требует дополнительной памяти.

# Лекция 8

## Хеш-таблицы
Хеш-таблицы – это тип структуры данных, в которой адрес или значение индекса элемента данных генерируются из хеш-функции. Это ускоряет доступ к данным, поскольку значение индекса ведет себя как ключ к значению данных. Другими словами, в хэш-таблице хранятся пары ключ-значение, но ключ генерируется с помощью функции хеширования.
Таким образом, функция поиска и вставки элемента данных становится намного быстрее, поскольку сами значения ключей становятся индексом массива, в котором хранятся данные.
Пожалуй, главное свойство hash-таблиц — все три операции: вставка, поиск и удаление — в среднем выполняются за время _O_(1), среднее время поиска по ней также равно _O_(1) и _O_(n) в худшем случае.

**Простое представление хеш-таблиц**
Чтобы разобраться, что такое хеш-таблицы, представьте, что вас попросили создать библиотеку и заполнить ее книгами. Но вы не хотите заполнять шкафы в произвольном порядке.
Первое, что приходит в голову — разместить все книги в алфавитном порядке и записать все в некий справочник. В этом случае не придется искать нужную книгу по всей библиотеке, а только по справочнику.
А можно сделать еще удобнее. Если изначально отталкиваться от названия книги или имени автора, то лучше использовать некий алгоритм хеширования, который обрабатывает входящее значение и выдает номер шкафа и полки для нужной книги.
Зная этот алгоритм хэширования, вы быстро найдете нужную книгу по ее названию.

Учтите, что хеш-функция должна иметь следующие свойства:
·        Всегда возвращать один и тот же адрес для одного и того же ключа;
·        Не обязательно возвращает разные адреса для разных ключей;
·        Использует все адресное пространство с одинаковой вероятностью;
·        Быстро вычислять адрес.

**Борьба с коллизиями (они же столкновения)**
В идеальном случае, когда заранее известны все пары ключ-значение, достаточно легко реализовать идеальную хеш-таблицу, в которой время поиска будет постоянным (используется идеальная хеш-функция, которая определяет положения в таблице по целым значениям и без столкновений).
Но в большинстве случаев приходится бороться с коллизиями. Обычно применяются методы цепочек и открытой индексации.

**Метод цепочек**
Этот метод часто называют **открытым хешированием**. Его суть проста — элементы с одинаковым хешем попадают в одну ячейку в виде связного списка
То есть, если ячейка с хешем уже занята, но новый ключ отличается от уже имеющегося, то новый элемент вставляется в список в виде пары ключ-значение.
Если выбран метод цепочек, то вставка нового элемента происходит за _O_(1), а время поиска зависит от длины списка и в худшем случае равно _O_(n). Если количество ключей **_n_**, а распределяем по **_m_**-ячейкам, то соотношение **_n/m_** будет коэффициентом заполнения.
В python метод цепочек реализуется так:
``` python
# Реализация хеш-таблицы в Python
hashTable = [[],] * 10
def checkPrime(n):
    if n == 1 or n == 0:
        return 0
    for i in range(2, n//2):
        if n % i == 0:
            return 0
    return 1
def getPrime(n):
    if n % 2 == 0:
        n = n + 1
    while not checkPrime(n):
        n += 2
    return n
def hashFunction(key):
    capacity = getPrime(10)
    return key % capacity
def insertData(key, data):
    index = hashFunction(key)
    hashTable[index] = [key, data]
def removeData(key):
    index = hashFunction(key)
    hashTable[index] = 0
insertData(123, "apple")
insertData(432, "mango")
insertData(213, "banana")
insertData(654, "guava")
print(hashTable)
removeData(123)
print(hashTable)
```

Проверка ячейки и создание списка

**Открытая индексация (или закрытое хеширование)**

Второй распространенный метод — открытая индексация. Это значит, что пары ключ-значение хранятся непосредственно в хеш-таблице. А алгоритм вставки проверяет ячейки в некотором порядке, пока не будет найдена пустая ячейка. Порядок вычисляется на лету.
Самая простая в реализации последовательность проб — линейное пробирование (или линейное исследование). Здесь все просто — в случае коллизии, следующие ячейки проверяются линейно, пока не будет найдена пустая ячейка.
А алгоритм поиска ищет ячейки в том же порядке, что и при вставке, пока не найдет нужный элемент или пустую ячейку, которая говорит о том, что ключ отсутствует. В случае, если таблица будет заполнена, ее придется динамически расширять.
Метод линейного пробирования для открытой индексации на C++:
``` c++
class HashEntry {
private:
int key;
int value;
public:
HashEntry(int key, int value) {
this->key = key;
this->value = value;
}
int getKey() {
return key;
}
int getValue() {
return value;
}
void setValue(int value) {
this->value = value;
}
};
```

**Самое главное**
Хеширование и хеш-таблицы применяются для более удобного хранения пар ключ-значение. Если нужна максимальная эффективность, то используйте хеш-таблицы со списками будет намного быстрее, чем обычная таблица.

ДЗ: распечатать все лекции и выучить их на проверку и сделать пример из книги "Грокаем алгоритмы(авокадо)"
``` python
values=[0]*10
def getHash(str):
    hash=0
    for el in str:
        hash+=ord(el)
    return hash
def getKey(hash):
	return hash % len(values)
values[getKey(getHash("avocado"))] = 10
values[getKey(getHash("tomato"))] = 15
values[getKey(getHash("apelsin"))] = 13
print(values)
print(values[getKey(getHash("avocado"))])
```
