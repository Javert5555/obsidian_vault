Docker - это средство упаковки, доставки и запуска приложения.

Image (образ) Docker — это шаблон, доступный только для чтения, который содержит набор инструкций по созданию контейнера, который может работать на платформе Docker. Он предоставляет удобный способ упаковки приложений и предварительно настроенных серверных сред, которые вы можете использовать в личных целях или совместно использовать с другими пользователями Docker.

Образ контейнера Docker (Docker container image) — это легкий, автономный исполняемый пакет программного обеспечения, который включает в себя все необходимое для запуска приложения: код, среду выполнения, системные инструменты, системные библиотеки и настройки.

![[servlet.jpg]]


**Ключевое отличие образа Docker от контейнера заключается в том, что образ Docker — это неизменяемый шаблон, доступный только для чтения, который определяет, как будет реализован контейнер. Контейнер Docker — это экземпляр образа Docker во время выполнения, который создается при выполнении команды `docker run`.**

Полезные команды:

1. `docker ps` - выводит информацию о всех запущенных контейнерах.
	- `docker ps -a` - выводит информацию о всех контейнерах;
	- `docker ps -q` - выводит id запущенных контейнеров (`docker ps -qa`  - выводит id всех контейнеров);
	
2. `docker build /path` - создать Docker `image` из файла Dockerfile и «контекста». Контекст сборки — это набор файлов, расположенных по указанному пути (path) или URL-адресу.
	- `docker build -t image-name /path` - создать Docker `image` c названием `image-name`;

3. `docker images` - выводит информацию о всех образах.
   - `docker rmi image-name`  - удаляет образ с именем image-name (так же можно удалять по id `docker rmi image-id`);
   - `docker rmi -f image-name` - останавливает все запущенные контейнеры, связанные с этим образом, после чего удаляет образ.

4. `docker run image-name` - создать и запустить новый контейнер из образа image-name.
	- `docker run --name container-name image-name` - создать и запустить новый контейнер с именем container-name из образа image-name;
	- `docker run -d image-name` - создать контейнер и запустить этот контейнер в режиме 'демон' (в фоновом режиме);
	- `docker run --rm image-name` - создать и запустить новый контейнер из образа image-name, после остановки (завершения) контейнера, удалить этот контейнер;
	- `docker run -p 8080:8000` - Чтобы опубликовать порт для нашего контейнера, необходимо использовать флаг --publish (-p для краткости) в команде запуска docker. Команда --publish имеет следующий формат: `[host port]:[container port]`. Итак, если бы мы хотели открыть порт 8000 внутри контейнера для порта 8080 снаружи контейнера, мы бы передали 8080:8000 флагу --publish;
	- `docker run -e VAR1=value1 --env VAR2=value2 image-name` - устанавливает простые переменные среды (не массивы) в контейнере, который вы запускаете, или перезаписывает переменные, определенные в Dockerfile образа, который вы запускаете;
	- `docker run -v /doesnt/exist:/foo -w /foo -i image-name` - Флаг -v монтирует текущий рабочий каталог в контейнер. 
	- `docker run image-name command-name params` - создать и запустить контейнер из образа `image-name` после чего выполнить внутри него команду `command-name` с параметрами (аргументами) `params`.


Для завершения контейнера Docker предоставляет команды docker stop и docker kill. Обе команды docker kill и docker stop выглядят одинаково, но их внутреннее выполнение отличается. Команды docker stop выдают сигнал SIGTERM, тогда как команды docker kill отправляют сигнал SIGKILL.

5. `docker stop container` - остановить (завершить) один или несколько запущенных контейнеров (`container` - имя или id этого контейнера).
	- `docker stop $(docker ps -q)` - завершить все запущенные контейнеры;

6. `docker kill container` - остановить (убить) один или несколько запущенных контейнеров (`container` - имя или id этого контейнера).
	- `docker kill $(docker ps -q)` - завершить все запущенные контейнеры;

7. `docker rm` - удаляет контейнер по id или name.
	- `docker rm $(docker ps -qa)` - удалить все существующие контейнеры;
	- `docker rm $(docker ps -q)` - удалить все запущенные контейнеры;
	- `docker rm -f container-name` - останавливает запущенный контейнер с названием `container-name`, и удаляет его.

8. `docker pull image-name` - скачать image с названием image-name с dockerhub.
   - `docker pull image-name:tag` - скачать image версии соответствующей тегу с названием image-name с dockerhub.

9. `docker start container-name` - запустить контейнер с названием `container-name`.

10. `docker pause container-name` - приостановить запущенный контейнер с названием `container-name`. Возобновить работу контейнера можно с помощью команды: `docker unpause container-name`

11. `docker inspect container-id` - выводит подробную информацию о контейнере с id `container-id`.
    - `docker image inspect image-id` - выводит подробную информацию об образе с id `image-id`.

12. `docker stats container-id` - выводит подробную информацию о ресурсах, которые потребляет (использует) контейнер с id `container-id`.

13. `docker logs container-name` - посмотреть логи контейнера с именем `container-name`.
    - `docker logs -f container-name` - видеть актуальные (постоянно обновляющиеся) логи контейнера с именем `container-name`.

14. `docker exec -it container-id /bin/bash` - позволяет войти в интерактивный режим `-it` контейнера с id `container-id`, где внутри контейнера запускается оболочка Bash (`/bin/bash`), которая предоставляет пользователю доступ к рабочей среде контейнера.

15. `docker system prune -a --volumes` - удаляет все остановленные контейнеры, все сети не используемые хотя бы одним контейнером, все анонимные тома (volumes), не используемые хотя бы одним контейнером, все образы (images), с которыми не связан хотя бы один контейнер, все сборки кэша.

Создаёт из образа с названием image-name контейнер и запускает его в режиме демона, с названием container-name, на порту 80 локально и на порту 80 внутри контейнера, и после остановки работы контейнера удаляет его:
```
docker run --rm --name container-name -d -p 80:80 image-name
```

Войти в докер контейнер с названием container-name (можно и по id) в консоли bash:
``` sh
docker exec -it container-name sh
```

Данная команда создаёт образ с названием (позволяет задать имя тег `-t`) `image-name`, где вместо `/path` указывается путь к директории, где находится dockerfile.
``` bash
docker build -t image-name /path
```

Данная команда создаёт контейнер и запускает его на 5 секунд.
``` bash
docker run image-name sleep 5
```

# Docker volumes

Тома (или Docker Volumes) в Docker - это файловые системы (постоянные хранилища данных), расположенные на хост-машине вне контейнеров, которые позволяют сохранять данные для контейнеров даже после их перезапуска. Они представляют собой папки на ПК, связанные с контейнерами, и Docker отражает их содержимое внутри приложения.

Даже после того, как контейнер был остановлен или удалён данные из тома (volume) остались не тронутыми.

1. `docker volume ls` - посмотреть все доступные тома(volumes) на локальном хосте

2. `docker run -d --rm --name web1 -p 80:80 -v C:/docker_projects/test/nginx/data:/usr/share/nginx/html nginx` - создать и запустить контейнер с _**хостовым**_ volume по пути `C:/docker_projects/test/nginx/data` для директории контейнера по пути `/usr/share/nginx/html`
   - `docker run -d --rm --name web1 -p 80:80 -v first_volume:/some_dir_1 -v second_volume:/some_dir_2 nginx` - создать и запустить контейнер с несколькими томами (volumes)

3. `docker run -d --rm --name web1 -p 80:80 -v /usr/share/nginx/html nginx` - создать и запустить контейнер с _**анонимным**_ volume для директории контейнера по пути `/usr/share/nginx/html`. Анонимные тома (volumes) удаляются после удаления контейнера.

4. `docker run -d --rm --name web1 -p 80:80 -v web_data:/usr/share/nginx/html nginx` - создать и запустить контейнер с _**именным**_ (`web_data`) volume для директории контейнера по пути `/usr/share/nginx/html`

5. `docker volume create volume_name` - создать именной volume с именем `volume_name`

6. `docker volume rm volume_name` - удаляет том (volume) с названием `volume_name`.

Удаление неиспользуемых Docker volumes на Windows можно выполнить с помощью следующих команд:

1. **Удаление неиспользуемых томов**:
   ```bash
   docker volume prune
   ```

2. **Удаление анонимных томов**:
   ```bash
   docker volume rm $(docker volume ls -q)
   ```

3. **Удаление конкретного тома**:
   ```bash
   docker volume rm <имя_тома>
   ```


## Docker network

В Docker network (сеть) представляет собой механизм, который позволяет контейнерам соединяться и общаться друг с другом или с внешними нагрузками, не являющимися контейнерами Docker. По умолчанию у контейнеров включена сетевая функциональность, и они могут устанавливать исходящие соединения. Контейнер не имеет информации о типе сети, к которой он подключен, или о том, являются ли его пиры также контейнерами Docker или нет. Контейнер видит только сетевой интерфейс с IP-адресом, шлюзом, таблицей маршрутизации, службами DNS и другими деталями сети. В Docker можно создавать пользовательские определенные пользователем сети и подключать к ним несколько контейнеров. После подключения к пользовательской сети контейнеры могут общаться друг с другом, используя IP-адреса контейнеров или их имена.

>[!info]
>При создании все контейнеры попадают в дефолтную сеть (default), где могут общаться через ip-адреса, но не через dns-имена.

_Также в Docker доступны различные драйверы для работы с сетями, такие как bridge (мост), overlay (наложение), ipvlan (IPvlan) и macvlan (MACvlan), каждый из которых предоставляет основные функциональности для работы с сетями. Создание и управление сетями в Docker позволяют эффективно организовывать коммуникацию между контейнерами и внешними ресурсами._

### Bridge
Docker сеть типа _**bridge**_ - это сетевой драйвер по умолчанию в Docker, который используется для создания мостовых сетей. Мостовые сети позволяют контейнерам обмениваться данными между собой и с хостом, что позволяет им общаться в пределах одной машины, если для них не описываются другие сети. Контейнеры в этой сети получают свои ip-адреса (по умолчанию 172.17.0.0/16) и могут обращаться друг к другу по ip-адресам, и по dns-именам.

1. `docker network create --driver bridge bridge_net_name` - создать сеть типа `bridge` с названием `bridge_net_name`
2. `docker run --net bridge_net_name image_name` - создать и запустить контейнер от образа `image-name`, работающий в `bridge` сети `bridge_net_name`

### Host
Сеть типа _**host**_ в Docker устраняет сетевую изолированность между контейнером и хостом, позволяя контейнеру напрямую использовать сетевые ресурсы хоста. В этом режиме контейнер становится видимым в сети как физическое устройство, и Docker демон направляет трафик на контейнеры по их MAC-адресам. Сеть типа _**host**_ полезна, так как контейнер не получает собственного IP-адреса (он получает IP-адрес самого хоста) и не изолирован от хоста Docker, что может быть полезно в определенных сценариях.

1. `docker network create --driver host host_net_name` - создать сеть типа `host` с названием `host_net_name`
2. `docker run --net host_net_name image_name` - создать и запустить контейнер от образа `image-name`, работающий в `host` сети `host_net_name`

### None
Сеть типа "none" в Docker означает, что контейнер не будет иметь собственного сетевого интерфейса и не будет подключен к сети. Это означает, что контейнер не будет иметь своего IP-адреса и не будет доступен извне. Хотя контейнеры в такой сети могут использовать локальные ресурсы хоста, они будут изолированы от других контейнеров и внешних сетей. Сеть типа "none" полезна в случаях, когда контейнеру не требуется сетевое взаимодействие или когда требуется максимальная изоляция.

1. `docker network create --driver none none_net_name` - создать сеть типа `host` с названием `none_net_name`
2. `docker run --net none_net_name image_name` - создать и запустить контейнер от образа `image-name`, работающий в `none` сети `none_net_name`
### Команды

1. `docker network ls` - посмотреть какие есть типы сетей в docker

2. `docker network create net_name` - создать сеть с названием `net_name` (по умолчанию создаётся тип `bridge`)

3. `docker network inspect net_name` - посмотреть подробную информацию про сеть с именем `net_name` (вместо имени можно указывать id)

4. `docker network rm net_name` - удалить сеть с именем `network` (вместо имени можно указывать id)

5. `docker network create -d bridge --subnet 192.168.10.0/24 --gateway 192.168.10.1 myNet192` - создать сеть со своими параметрами

6. `docker network connect net_name container_name` - подключить контейнер к сети с именем `net_name` (можно использовать id - сети) (если контейнер был уже подключён к какой-то сети, то он будет просто подключён к ещё одной сети).

7. `docker network disconnect net_id container_name` - отключить контейнер от сети с id `net_id`.

8. `docker network prune` - Удаление неиспользуемых сети Docker на Windows можно выполнить с помощью следующей команды:

### Пример 1
`docker run --rm -it --name cont1 --net myNet1 nicolaka/netshoot /bin/bash` - запустим первый контейнер в сети `myNet1`

`docker run --rm -it --name cont2 --net myNet1 nicolaka/netshoot /bin/bash` - запустим второй контейнер в сети `myNet2`

```bash
%% можем пропинговать из первого контейнера второй контейнер по имени и ip-АДРЕСУ %%
ip a
ping cont2

%% можем пропинговать из второго контейнера первый контейнер по имени и ip-АДРЕСУ %%
ip a
ping cont1
```

### Пример 2
`docker network create myNet2` - создаём новую сеть типа bridge
`docker run --rm -it --name cont1 --net myNet2 nicolaka/netshoot /bin/bash` - запустим первый контейнер в сети `myNet2`

`docker run --rm -it --name cont2 --net myNet1 nicolaka/netshoot /bin/bash` - запустим второй контейнер в сети `myNet2`

```bash
%% в итоге мы не сможем пропинговать из первого контейнера второй контейнер и по имени и ip-АДРЕСУ %%
ip a
ping cont2

%% в итоге мы не сможем пропинговать из второго контейнера первый контейнер и по имени и ip-АДРЕСУ %%
ip a
ping cont1
```

## Dockerfile

Докер файл необходим для создания собственных образов (images).
Докер файл состоит из следующих компонентов:
1. `FROM ubuntu:22.04` - базовый образ;
2. `Label author=Javert` - описание образа (необязательная опция, здесь можно указать любую информацию о нашем образе), это описание будет видно в информации об образе;
3. `RUN apt-get update`
   `RUN apt-gt install nginx -y` - команды (описание команд)
4. `WORKDIR /var/www/html/` - рабочая директория;
5. `COPY file2/index.html .`
   `COPY file2/script.sh /opt/script.sh` - с помощью команды `COPY` можно копировать файлы, которые находятся на локальной машине в наш image;
6. `RUN chmod +x /opt/script.sh` - команды для работы с файлами;
7. `ENV OWNER="Javert"`
   `ENV TYPE=demo` - можно указать переменные среды, т.е. при запуске контейнера внутри него будут существовать указанные переменные среды, которые смогут использовать программы;

>[!info]
Мы можем добавить новые или перезаписать существующие переменные окружения с помощью параметра `-e`, при запуске контейнера командой `docker run -e key=value`

>[!info]
Так же эти переменные среды можно использовать в самом dockerfile, например  в команде `RUN`: `ENV OWNER=Javert` и `RUN echo ${OWNER} > /opt/info`. В таком случае выполнение команд происходит раньше чем задание (или перезапись) переменных через параметр `-e` в команде `docker run -e key=value`

8. `EXPOSE 80` - можно указать порты, указывает к каким портам нужно подключаться другим контейнерам и хосту к данному контейнеру (несёт больше информативную роль, так как по сути ничего не делает);
9. `ENTRYPOINT ["echo"]` - описание команд, которые выполнятся внутри контейнера при его запуске;
10. `CMD ["Hello first docker"]` - описание команд, которые выполнятся внутри контейнера при его запуске.

### Основные моменты

Инструкция `COPY` в Dockerfile используется для копирования файлов и каталогов из локальной файловой системы в создаваемый Docker-образ. Эта инструкция позволяет перенести необходимые файлы и каталоги в контейнер во время сборки образа.
Синтаксис инструкции `COPY` в Dockerfile:
`COPY [--chown=<user>:<group>] <src>... <dest>`

- `<src>` - это локальный путь к файлу или каталогу, который необходимо скопировать в контейнер.
- `<dest>` - это путь внутри контейнера, куда будут скопированы файлы или каталоги.
- `--chown=<user>:<group>` - это опция для изменения владельца и группы файлов в контейнере.

Инструкция `WORKDIR` в Dockerfile используется для определения рабочего каталога внутри контейнера. Это позволяет установить директорию, в которой будут выполняться все последующие инструкции Dockerfile.

>[!warning]
>Инструкция `WORKDIR` ВЛИЯЕТ на инструкцию `COPY` для пути внутри контейнера, если мы не указываем абсолютный путь.

>[!info]
`ENTRYPOINT`, в отличие от `CMD` не позволяет перезаписать команды, которые выполнятся внутри контейнера при его запуске. Т.е. `ENTRYPOINT` - неизменяемые команды, `CMD` - изменяемые команды.

>[!info]
Инструкция `RUN` в Dockerfile выполняется во время сборки образа Docker и создает новый слой образа. Когда Dockerfile используется для создания образа в первый раз, Docker загружает слои, определенные базовым образом (например, Ubuntu), и каждый последующий слой представляет собой файл. При создании контейнера добавляется слой, в который можно вносить изменения, поверх всех остальных слоев.

>[!info]
`COPY /files/index.html /var/www/html/` - при использовании инструкции `COPY`, если мы копируем что-то (например, `/files/index.html`), в какую-то директорию, нужно ОБЯЗАТЕЛЬНО поставить `/` в конце пути (после названия директории, куда мы хотим скопировать файлы) `/var/www/html/`.

>[!info]
Инструкция `EXPOSE` в Dockerfile используется для информирования Docker о том, что контейнер будет слушать указанные сетевые порты во время выполнения. Это не открывает порты или делает их доступными извне контейнера, но лишь документирует, какие порты приложение в контейнере ожидает использовать.

>[!info]
Если мы используем инструкцию `EXPOSE` в Dockerfile, то при запуске команды `docker run`, мы можем указать опцию `-P`, в данном случае мы пробросим случайные порты к указанным в инструкциях `EXPOSE`.

### Пример для `-P`:
``` dockerfile
FROM ubuntu
LABEL author="Javert"
RUN apt-get update
RUN apt-get install nginx -y
EXPOSE 80
EXPOSE 443/tcp
CMD [ "nginx", "-g", "daemon off;" ]
```

``` cmd
docker run -d --rm --name cont -P newdocker:v02
```

Результат:
![[Pasted image 20240304011049.png]]


### Команды:
1. `docker build -t image_name /path` - создать образ, описанный в dockerfile (`/path` - это путь к директории, где находится dockerfile), с именем `image_name`;
2. `docker tag image_id new_image_name:v01` - задаёт имя `new_image_name` (в имени только маленькие буквы) образу с id = `image_id`, (так же дополнительно можно задать версию `v01` через `:`)

## Docker Compose
Docker Compose:
- используется для управления одним или несколькими контейнерами;
- содержит инструкции по запуску контейнеров;
- упрощает автоматизацию запуска контейнеров;
- описывается в YAML-файле: `docker-compose.yml`.

Пример файла `docker-compose.yml`:
```yml
version: "3.5" # указывается версия самого docker compose
services: # описание всех контейнеров, которые мы будем запускать
	web-server: # название приложения (контейнера)
		# вместо image, можно использовать build: /path/to/dockerfile
		image: nginx:stable # image из которого будет собираться контейнер
		container_name: mynginx # задать название контейнера
		command: echo "start" # команда, которая будет запущена, при запуске контейнера
		volumes: # тома (или Docker Volumes) контейнера
			- /opt/web/html:/var/www/html
			- /opt/web/pics:/var/www/pictures
			- nginx-config:/var/www/config
		environment: # можно задать переменные окружения контейнера
			- NGINX_HOST=web.hostname.com
			- NGINX_PORT=80
		ports: # можно указать порты для хоста и контейнера
			- 80:80
			- 443:443
		restart: unless-stopped # возможные значения:  always/no/on-failure
							   # правило, которое указывает, что деалть контейнеру при
		                       # его остановке, перезагрузке и так далле, (в данном
		                       # случае: при перезагрузке
		                       # сервера контейнер будет иметь то же состояние, что и
		                       # до перезагрузки)
		networks: # указываются сети контейнера (в которых будет запускаться контейнер)
			default:
				driver: bridge # тип сети
				name: webnet # название сети
		depends-on: # приложение web-server, будет запущено, только когда запустятся
				    # сервисы app-db и app-redis
			- app-db
			- app-redis
# описание именным томов
volumes:
  nginx-config:
networks: # описание сетей, которые используют сервисы
  internet:
    name: internet
    driver: bridge
  appnet:
    name: appnet
    driver: bridge

```

### links [deprecated] (устарело)
_В файле docker-compose.yml, раздел "links" используется для связывания контейнеров в сети Docker. Ключевое слово "links" позволяет устанавливать связи между различными сервисами, что обеспечивает доступ к одному контейнеру из другого.
_Пример использования "links" в файле docker-compose.yml:
```yml
version: '3'
services:
  webapp:
    image: mywebapp
    ports:
      - "8080:80"
  db:
    image: mysql
    environment:
      MYSQL_ROOT_PASSWORD: example
    links:
      - webapp
```
_В данном примере у нас есть два сервиса: "webapp" и "db". Сервис "webapp" запущен на порту 8080 и связан с сервисом "db" с помощью ключевого слова "links". Это означает, что сервис "webapp" сможет обращаться к сервису "db" по имени "db" внутри сети Docker.
_Таким образом, использование "links" в файле docker-compose.yml позволяет устанавливать связи между контейнерами и обеспечивать коммуникацию между ними.

### Команды

>[!info]
`docker-compose` - старое обозначение
`docker compose` - новое обозначение

``` bash
# Собирает сервисы, описанные в конфигурационных файлах
docker compose build

# Запускает собранные сервисы
docker compose up

# Запуск контейнеров на фоне с флагом -d
docker compose up -d

# Если какой-то из сервисов завершит работу,
# то остальные будут остановлены автоматически
docker compose up --abort-on-container-exit

# Запустит сервис application и выполнит внутри команду make install
docker compose run application make install

# А так мы можем запустить сервис и подключиться к нему с помощью bash
docker compose run application bash

# С флагом --rm запускаемые контейнеры будут автоматически удаляться
docker compose run --rm application bash

# Останавливает и удаляет все сервисы,
# которые были запущены с помощью up
docker compose down

# Останавливает, но не удаляет сервисы, запущенные с помощью up
# Их можно запустить снова с помощью docker-compose start
docker compose stop

# посмотреть логи наших сервисов (если, например, они работают в detach моде, при этом если мы выйдем из логов контейнеры продолжат работать дальше)
docker compose logs -f
```

- docker compose build — собрать проект
- docker compose up -d — запустить проект
- docker compose down — остановить проект
- docker compose logs -f [service name] — посмотреть логи сервиса
- docker compose ps — вывести список контейнеров
- docker compose exec [service name] [command» — выполнить команду в контейнере
- docker compose images — список образов

## .dockerignore
Файл `.dockerignore` используется для указания файлов и директорий, которые не должны быть включены в контейнер при сборке образа Docker. Это помогает уменьшить размер образа, ускорить процесс сборки и обеспечить безопасность, исключив лишние файлы и конфиденциальные данные. В этом файле можно указать шаблоны для игнорирования файлов и директорий, аналогично .gitignore в Git.