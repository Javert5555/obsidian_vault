Ключевыми понятиями парадигмы ООП являются понятия "класс" и "объект". Описанием объекта является класс, а объект представляет экземпляр этого класса.

Для создания класса в PHP используется ключевое слово `class`, после которого идет название класса и фигурные скобки `{}` - блок кода класса. Чтобы создать объект класса, применяется ключевое слово `new`:

```php
class User
{}

$user = new User();
print_r($user); // User Object ( )
```

>[!info]
>При этом неважно, определяется класс до или после создания объекта. Например, мы можем сначала определить переменную класса, а потом определить этот класс:
>```php
$user = new User();
print_r($user); // User Object ( )
>
>class User
{}
>```

## Свойства и методы

В PHP свойства и методы класса определяются следующим образом:
### Свойства

Свойства класса объявляются внутри класса с указанием модификатора доступа (public, protected, private) и начального значения.Доступ к свойствам осуществляется через оператор доступа `->` с использованием `$this` внутри методов класса.

Динамические свойства, создаваемые во время выполнения, являются public. 

Наследуемые свойства возвращаются методом `ReflectionClass::getProperties()`, но не private-свойства родительских классов.

### Методы

Методы класса объявляются внутри класса с указанием модификатора доступа (public, protected, private) и реализацией логики. Вызов методов осуществляется через оператор `->` с передачей аргументов в круглых скобках.

>[!info]
>Статические методы вызываются через оператор `::` без использования `$this` и не могут обращаться к свойствам экземпляра.

### Присваивание объектов

При присваивании объекта создается копия ссылки на тот же объект, изменение копии не влияет на оригинал. Присваивание объекта не то же самое, что присваивание по ссылке или копирование значения.

## $this

В PHP переменная `$this` является специальной псевдопеременной, которая ссылается на текущий экземпляр класса. Она используется внутри методов класса для доступа к свойствам и методам того же объекта.

- **Ссылка на текущий объект**: Когда вы используете `$this` внутри класса, она указывает на объект, с которым вы в данный момент работаете. Это позволяет вам обращаться к другим свойствам и методам этого объекта с помощью оператора `->`. Например, если у вас есть свойство `name`, вы можете получить к нему доступ с помощью `$this->name`.

- **Вызов методов**: Вы также можете вызывать методы того же класса, используя `$this`. Например, если у вас есть метод `getName()`, вы можете вызвать его из другого метода так: `$this->getName()`.

### Пример

Вот простой пример, чтобы проиллюстрировать, как работает `$this`:

```php
class Animal {
    public $type;

    public function __construct($type) {
        $this->type = $type; // Доступ к свойству через $this
    }

    public function describe() {
        return "Это " . $this->type; // Вызов другого метода через $this
    }
}

$dog = new Animal("Собака");
echo $dog->describe(); // Вывод: Это Собака
```

>[!info]
>После `$this->` не нужен знак доллара `$` перед именем свойства: `$this->type = $type;`
### Ключевые моменты

- **Контекст экземпляра**: `$this` может использоваться только внутри методов класса и ссылается на экземпляр класса, в котором был вызван метод.

- **Доступ к свойствам и методам**: Используйте `$this->property` для доступа к свойствам и `$this->method()` для вызова методов.

>[!warning]
>**Не для статического контекста**: `$this` не может использоваться в статических методах. В статическом контексте вы будете использовать `self::` для обращения к свойствам или методам класса.

>[!info]
`$this` можно писать только внутри области, ограниченной `class {}`

Использование `$this` является основополагающим в объектно-ориентированном программировании на PHP, так как оно позволяет эффективно инкапсулировать и взаимодействовать с данными и поведением объекта.

## Сравнение объектов

При сравнении объектов классов следует принимать во внимание ряд особенностей. В частности, при использовании оператора равенства == два объекта считаются равными, если они представляют один и тот же класс и их свойства имеют одинаковые значения.

А при использовании оператора эквивалентности === оба объекта считаются равными, если обе переменных классах указывают на один и тот же экземпляр класса.

```php
class User
{
    public string $name;
    public string $email;
    public int $age;

    public function __construct(string $name, string $email, int $age) {
        $this->name = $name;
        $this->email = $email;
        $this->age = $age;
    }

    public function hello () {
        var_export($this->name . ' ' . $this->email . ' ' . $this->age);
    }
}

$user1 = new User('name1', 'email1', 21);
$user2 = new User('name1', 'email1', 21);
$user3 = new User('name1', 'email1', 22);
$user4 = $user1;

var_export($user1 == $user2); // true
var_export($user1 == $user3); // false
var_export($user1 == $user4); // true

var_export($user1 === $user2); // false
var_export($user1 === $user3); // false
var_export($user1 === $user4); // true
```